package main

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/chenjie199234/Corelib/pbex"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	stringsPackage  = protogen.GoImportPath("strings")
	regexpPackage   = protogen.GoImportPath("regexp")
	bytesPackage    = protogen.GoImportPath("bytes")
	strconvPackage  = protogen.GoImportPath("strconv")
	httpPackage     = protogen.GoImportPath("net/http")
	fmtPackage      = protogen.GoImportPath("fmt")
	jsonPackage     = protogen.GoImportPath("encoding/json")
	protoPackage    = protogen.GoImportPath("google.golang.org/protobuf/proto")
	contextPackage  = protogen.GoImportPath("context")
	rpcPackage      = protogen.GoImportPath("github.com/chenjie199234/Corelib/rpc")
	commonPackage   = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/common")
	metadataPackage = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/metadata")
	errorPackage    = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/error")
	bufpoolPackage  = protogen.GoImportPath("github.com/chenjie199234/Corelib/bufpool")
)

// generateFile generates a _rpc.pb.go file containing rpc service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_rpc.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		genService(file, g, service)
	}
	return g
}
func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-go-rpc. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-rpc ", version)
	g.P("// \tprotoc         ", protocVersion)
	g.P("// source: ", file.Desc.Path())
	g.P()
}
func genService(file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	geninit(file, g, service)
	genPath(file, g, service)
	genClient(file, g, service)
	genServer(file, g, service)
}

type uniquefield struct {
	messagename string
	fieldname   string
	keyorvalue  string
}

func geninit(file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	allreg := make(map[string]struct{}, 10) //key is message name + field name,value is reg rule
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		getallreg(method.Input, allreg)
	}
	if len(allreg) > 0 {
		for reg := range allreg {
			if _, e := regexp.Compile(reg); e != nil {
				panic("reg: '" + reg + "' syntax wrong")
			}
		}
		g.P("var _", service.GoName, "Regs map[string]*", g.QualifiedGoIdent(regexpPackage.Ident("Regexp")))
		g.P("func init(){")
		g.P("_", service.GoName, "Regs=make(map[string]*", g.QualifiedGoIdent(regexpPackage.Ident("Regexp")), ")")
		g.P("var e error")
		for reg := range allreg {
			g.P("if _", service.GoName, "Regs[", strconv.Quote(reg), "] ,e = ", g.QualifiedGoIdent(regexpPackage.Ident("Compile")), "(", strconv.Quote(reg), ");e!=nil{")
			g.P("panic(\"protoc-gen-go-rpc will check all regexp before generate this code,this may happen when the golang version build protoc-gen-go-rpc and golang version run this code isn't same and the two version's regexp package is different\")")
			g.P("}")
		}
		g.P("}")
		g.P()
	}
}
func getallreg(m *protogen.Message, allreg map[string]struct{}) {
	for _, field := range m.Fields {
		fop := field.Desc.Options().(*descriptorpb.FieldOptions)
		if field.Desc.Kind() == protoreflect.BytesKind || field.Desc.Kind() == protoreflect.StringKind {
			if proto.HasExtension(fop, pbex.E_StringBytesRegMatch) {
				match := proto.GetExtension(fop, pbex.E_StringBytesRegMatch).([]string)
				for _, v := range match {
					allreg[v] = struct{}{}
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesRegNotMatch) {
				notmatch := proto.GetExtension(fop, pbex.E_StringBytesRegNotMatch).([]string)
				for _, v := range notmatch {
					allreg[v] = struct{}{}
				}
			}
		} else if field.Desc.Kind() == protoreflect.MessageKind {
			if field.Desc.IsMap() {
				//map
				if field.Message.Fields[0].Desc.Kind() == protoreflect.StringKind {
					if proto.HasExtension(fop, pbex.E_MapKeyStringRegMatch) {
						match := proto.GetExtension(fop, pbex.E_MapKeyStringRegMatch).([]string)
						for _, v := range match {
							allreg[v] = struct{}{}
						}
					}
					if proto.HasExtension(fop, pbex.E_MapKeyStringRegNotMatch) {
						notmatch := proto.GetExtension(fop, pbex.E_MapKeyStringRegNotMatch).([]string)
						for _, v := range notmatch {
							allreg[v] = struct{}{}
						}
					}
				}
				if field.Message.Fields[1].Desc.Kind() == protoreflect.BytesKind || field.Message.Fields[1].Desc.Kind() == protoreflect.StringKind {
					if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegMatch) {
						match := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegMatch).([]string)
						for _, v := range match {
							allreg[v] = struct{}{}
						}
					}
					if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegNotMatch) {
						notmatch := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegNotMatch).([]string)
						for _, v := range notmatch {
							allreg[v] = struct{}{}
						}
					}
				} else if field.Message.Fields[1].Desc.Kind() == protoreflect.MessageKind {
					getallreg(field.Message.Fields[1].Message, allreg)
				}
			} else {
				//[]message or message
				getallreg(field.Message, allreg)
			}
		}
	}
}
func genPath(file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		pathname := "RpcPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		g.P("var ", pathname, "=", strconv.Quote(pathurl))
	}
	g.P()
}
func genServer(file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	// Server interface.
	serverName := service.GoName + "RpcServer"

	g.P("type ", serverName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")), ",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*", g.QualifiedGoIdent(method.Output.GoIdent), ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	// Server handler
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		fname := "func _" + service.GoName + "_" + method.GoName + "_RpcHandler"
		p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		freturn := g.QualifiedGoIdent(rpcPackage.Ident("OutsideHandler"))
		g.P(fname, "(", p1, ")", freturn, "{")
		g.P("return func(ctx *"+g.QualifiedGoIdent(rpcPackage.Ident("Context")), "){")
		g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
		g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(ctx.GetBody(),req);e!=nil{")
		g.P("ctx.Abort(", g.QualifiedGoIdent(rpcPackage.Ident("ERRREQUEST")), ")")
		g.P("return")
		g.P("}")
		if haschecker(method.Input) {
			checker("req.", method.Input, g, true)
		}
		g.P("resp,e:=handler(ctx,req)")
		g.P("if e!=nil{")
		g.P("ctx.Abort(e)")
		g.P("return")
		g.P("}")
		g.P("if resp == nil{")
		g.P("resp = new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("}")
		g.P("respd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(resp)")
		g.P("ctx.Write(respd)")
		g.P("}")
		g.P("}")
	}

	//Server Register
	g.P("func Register", serverName, "(engine *", g.QualifiedGoIdent(rpcPackage.Ident("RpcServer")), ",svc ", serverName, ",allmids map[string]", g.QualifiedGoIdent(rpcPackage.Ident("OutsideHandler")), ")error{")
	g.P("//avoid lint")
	g.P("_=allmids")
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		r, e := parseMethodComment(string(method.Comments.Trailing))
		if e != nil {
			panic(e)
		}
		fname := "_" + service.GoName + "_" + method.GoName + "_RpcHandler(svc." + method.GoName + ")"
		pathname := "RpcPath" + service.GoName + method.GoName
		if len(r.mids) > 0 {
			g.P("{")
			str := ""
			for _, mid := range r.mids {
				str += ","
				str += strconv.Quote(mid)
			}
			str = str[1:]
			g.P("requiredMids:=[]string{", str, "}")
			g.P("mids:=make([]", g.QualifiedGoIdent(rpcPackage.Ident("OutsideHandler")), ",0)")
			g.P("for _,v:=range requiredMids{")
			g.P("if mid,ok:=allmids[v];ok{")
			g.P("mids = append(mids,mid)")
			g.P("}")
			g.P("}")
			g.P("mids = append(mids,", fname, ")")
			g.P("if e := engine.RegisterHandler(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
			g.P("return e")
			g.P("}")
			g.P("}")
		} else {
			g.P("if e := engine.RegisterHandler(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
			g.P("return e")
			g.P("}")
		}
	}
	g.P("return nil")
	g.P("}")
}
func genClient(file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	// Client interface.
	clientName := service.GoName + "RpcClient"
	lowclientName := strings.ToLower(clientName[:1]) + clientName[1:]

	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")), ",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*", g.QualifiedGoIdent(method.Output.GoIdent), ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	g.P("type ", lowclientName, " struct{")
	g.P("cc *", g.QualifiedGoIdent(rpcPackage.Ident("RpcClient")))
	g.P("}")
	g.P("func New", clientName, "(c *", g.QualifiedGoIdent(rpcPackage.Ident("ClientConfig")), ",selfgroup,selfname,peergroup,peername string)(", clientName, ",error){")
	g.P("cc,e:=", g.QualifiedGoIdent(rpcPackage.Ident("NewRpcClient")), "(c,selfgroup,selfname,peergourp,peername)")
	g.P("if e != nil {")
	g.P("return nil, e")
	g.P("}")
	g.P("return &", lowclientName, "{cc:cc},nil")
	g.P("}")
	g.P()
	// Client handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		pathname := "RpcPath" + service.GoName + method.GoName
		p1 := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")", freturn, "{")
		g.P("if req == nil {")
		g.P("return nil,", g.QualifiedGoIdent(rpcPackage.Ident("ERRREQUEST")))
		g.P("}")

		check("req.", method.Input, service, g, false)

		g.P("reqd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(req)")
		if proto.HasExtension(mop, pbex.E_Timeout) {
			var timeout time.Duration
			timeoutstr := proto.GetExtension(mop, pbex.E_Timeout).(string)
			if timeoutstr != "" {
				var e error
				timeout, e = time.ParseDuration(timeoutstr)
				if e != nil {
					panic(fmt.Sprintf("method: %s in service: %s with timeout: %s format error:%s", method.Desc.Name(), service.Desc.Name(), e))
				}
			}
			g.P("callback,e:=c.cc.Call(ctx,", strconv.FormatInt(timeout.Nanoseconds(), 10), ",", pathname, ",reqd,", metadataPackage.Ident("GetAllMetadata"), "(ctx))")
		} else {
			g.P("callback,e:=c.cc.Call(ctx,0,", pathname, ",reqd,", metadataPackage.Ident("GetAllMetadata"), "(ctx))")
		}
		g.P("if e.(*", g.QualifiedGoIdent(errorPackage.Ident("Error")), ") != nil {")
		g.P("return nil,e")
		g.P("}")
		g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(callback,resp);e!=nil{")
		g.P("return nil,", g.QualifiedGoIdent(rpcPackage.Ident("ERRRESPONSE")))
		g.P("}")
		g.P("return resp, nil")
		g.P("}")
	}
}
func check(prefix string, message *protogen.Message, service *protogen.Service, g *protogen.GeneratedFile, server bool) {
	for _, field := range message.Fields {
		fop := field.Desc.Options().(*descriptorpb.FieldOptions)
		if fop == nil {
			continue
		}
		switch field.Desc.Kind() {
		case protoreflect.BoolKind:
			//bool or []bool
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g, server)
			}
			boolcheck(prefix, field.GoName, field.Desc.IsList(), fop, g, server)
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Sfixed32Kind:
			fallthrough
			//int32 or []int32
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Sfixed64Kind:
			//int64 or []int64
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g, server)
			}
			intcheck(prefix, field.GoName, field.Desc.IsList(), fop, g, server)
		case protoreflect.Uint32Kind:
			fallthrough
		case protoreflect.Fixed32Kind:
			fallthrough
			//uint32 or []uint32
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Fixed64Kind:
			//uint64 or []uint64
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g, server)
			}
			uintcheck(prefix, field.GoName, field.Desc.IsList(), fop, g, server)
		case protoreflect.FloatKind:
			//float32 or []float32
			fallthrough
		case protoreflect.DoubleKind:
			//float64 or []float64
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g, server)
			}
			floatcheck(prefix, field.GoName, field.Desc.IsList(), fop, g, server)
		case protoreflect.EnumKind:
			//enum or []enum
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g, server)
			}
			enumcheck(prefix, field.GoName, field.GoIdent, field.Desc.IsList(), fop, g, server)
		case protoreflect.BytesKind:
			//[]bytes or [][]bytes
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g, server)
			}
			stringlencheck(prefix, field.GoName, field.Desc.IsList(), fop, g, server)
			bytescheck(prefix, field.GoName, field.Desc.IsList(), fop, service, g, server)
		case protoreflect.StringKind:
			//string or []string
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g, server)
			}
			stringlencheck(prefix, field.GoName, field.Desc.IsList(), fop, g, server)
			stringcheck(prefix, field.GoName, field.Desc.IsList(), fop, service, g, server)
		case protoreflect.MessageKind:
			//message or []message or map
			if field.Desc.IsMap() {
				//map
				elementnumcheck(prefix, field.GoName, fop, g, server)
			} else if field.Desc.IsList() {
				//[]message
				elementnumcheck(prefix, field.GoName, fop, g, server)
				messagecheck(prefix, field.GoName, true, fop, g, server)
			} else {
				//message
				messagecheck(prefix, field.GoName, false, fop, g, server)
			}
		}
	}
}
func elementnumcheck(prefix, fieldname string, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile, server bool) {
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenEq) {
		leneq := proto.GetExtension(fop, pbex.E_MapRepeatedLenEq).(uint64)
		g.P("if len(", prefix+fieldname, ")!=", leneq, "{")
		if server {

		} else {

		}
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenNotEq) {
		lennoteq := proto.GetExtension(fop, pbex.E_MapRepeatedLenNotEq).(uint64)
		g.P("if len(", prefix+fieldname, ")==", lennoteq, "{")
		if server {

		} else {

		}
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenGt) {
		lengt := proto.GetExtension(fop, pbex.E_MapRepeatedLenGt).(uint64)
		g.P("if len(", prefix+fieldname, ")<=", lengt, "{")
		if server {

		} else {

		}
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenGte) {
		lengte := proto.GetExtension(fop, pbex.E_MapRepeatedLenGte).(uint64)
		g.P("if len(", prefix+fieldname, ")<", lengte, "{")
		if server {

		} else {

		}
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenLt) {
		lenlt := proto.GetExtension(fop, pbex.E_MapRepeatedLenLt).(uint64)
		g.P("if len(", prefix+fieldname, ")>=", lenlt, "{")
		if server {

		} else {

		}
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenLte) {
		lenlte := proto.GetExtension(fop, pbex.E_MapRepeatedLenLte).(uint64)
		g.P("if len(", prefix+fieldname, ")>", lenlte, "{")
		if server {

		} else {

		}
		g.P("}")
	}
}
func boolcheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile, server bool) {
	if proto.HasExtension(fop, pbex.E_BoolEq) {
		booleq := proto.GetExtension(fop, pbex.E_BoolEq).(bool)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			g.P("if v!=", booleq, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "!=", booleq, "{")
			g.P("}")
		}
	}
}
func intcheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile, server bool) {
	if proto.HasExtension(fop, pbex.E_IntIn) {
		in := proto.GetExtension(fop, pbex.E_IntIn).([]int64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range in {
				g.P("if v!=", v, "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range in {
				g.P("if ", prefix+fieldname, "!=", v, "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_IntNotIn) {
		notin := proto.GetExtension(fop, pbex.E_IntNotIn).([]int64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range notin {
				g.P("if v==", v, "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range notin {
				g.P("if ", prefix+fieldname, "==", v, "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_IntGt) {
		gt := proto.GetExtension(fop, pbex.E_IntGt).(int64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<=", gt, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<=", gt, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntGte) {
		gte := proto.GetExtension(fop, pbex.E_IntGte).(int64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<", gte, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<", gte, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntLt) {
		lt := proto.GetExtension(fop, pbex.E_IntLt).(int64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>=", lt, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">=", lt, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntLte) {
		lte := proto.GetExtension(fop, pbex.E_IntLte).(int64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>", lte, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">", lte, "{")
			g.P("}")
		}
	}
}
func uintcheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile, server bool) {
	if proto.HasExtension(fop, pbex.E_UintIn) {
		in := proto.GetExtension(fop, pbex.E_UintIn).([]uint64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range in {
				g.P("if v!=", v, "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range in {
				g.P("if ", prefix+fieldname, "!=", v, "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_UintNotIn) {
		notin := proto.GetExtension(fop, pbex.E_UintNotIn).([]uint64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range notin {
				g.P("if v==", v, "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range notin {
				g.P("if ", prefix+fieldname, "==", v, "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_UintGt) {
		gt := proto.GetExtension(fop, pbex.E_UintGt).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<=", gt, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<=", gt, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintGte) {
		gte := proto.GetExtension(fop, pbex.E_UintGte).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<", gte, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<", gte, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintLt) {
		lt := proto.GetExtension(fop, pbex.E_UintLt).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>=", lt, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">=", lt, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintLte) {
		lte := proto.GetExtension(fop, pbex.E_UintLte).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>", lte, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">", lte, "{")
			g.P("}")
		}
	}
}
func floatcheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile, server bool) {
	if proto.HasExtension(fop, pbex.E_FloatIn) {
		in := proto.GetExtension(fop, pbex.E_FloatIn).([]float64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range in {
				g.P("if v!=", v, "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range in {
				g.P("if ", prefix+fieldname, "!=", v, "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatNotIn) {
		notin := proto.GetExtension(fop, pbex.E_FloatNotIn).([]float64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range notin {
				g.P("if v==", v, "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range notin {
				g.P("if ", prefix+fieldname, "==", v, "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatGt) {
		gt := proto.GetExtension(fop, pbex.E_FloatGt).(float64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<=", gt, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<=", gt, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatGte) {
		gte := proto.GetExtension(fop, pbex.E_FloatGte).(float64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<", gte, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<", gte, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatLt) {
		lt := proto.GetExtension(fop, pbex.E_FloatLt).(float64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>=", lt, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">=", lt, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatLte) {
		lte := proto.GetExtension(fop, pbex.E_FloatLte).(float64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>", lte, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">", lte, "{")
			g.P("}")
		}
	}
}
func enumcheck(prefix, fieldname string, ident protogen.GoIdent, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile, server bool) {
	if islist {
		g.P("for _,v:=range ", prefix+fieldname, "{")
		g.P("if _,ok:=", g.QualifiedGoIdent(ident), "_name[v];!ok{")
		g.P("}")
		g.P("}")
	} else {
		g.P("if _,ok:=", g.QualifiedGoIdent(ident), "_name[", prefix+fieldname, "];!ok{")
		g.P("}")
	}
}
func stringlencheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile, server bool) {
	if proto.HasExtension(fop, pbex.E_StringBytesLenEq) {
		leneq := proto.GetExtension(fop, pbex.E_StringBytesLenEq).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)!=", leneq, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")!=", leneq, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenNotEq) {
		lennoteq := proto.GetExtension(fop, pbex.E_StringBytesLenNotEq).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)==", lennoteq, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")==", lennoteq, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenGt) {
		lengt := proto.GetExtension(fop, pbex.E_StringBytesLenGt).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)<=", lengt, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")<=", lengt, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenGte) {
		lengte := proto.GetExtension(fop, pbex.E_StringBytesLenGte).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)<", lengte, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")<", lengte, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenLt) {
		lenlt := proto.GetExtension(fop, pbex.E_StringBytesLenLt).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)>=", lenlt, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")>=", lenlt, "{")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenLte) {
		lenlte := proto.GetExtension(fop, pbex.E_StringBytesLenLte).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)>", lenlte, "{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")>", lenlte, "{")
			g.P("}")
		}
	}
}
func bytescheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, service *protogen.Service, g *protogen.GeneratedFile, server bool) {
	if proto.HasExtension(fop, pbex.E_StringBytesIn) {
		in := proto.GetExtension(fop, pbex.E_StringBytesIn).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, v := range in {
				g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)!=", strconv.Quote(v), "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range in {
				g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)!=", strconv.Quote(v), "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesNotIn) {
		notin := proto.GetExtension(fop, pbex.E_StringBytesNotIn).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, v := range notin {
				g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)==", strconv.Quote(v), "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range notin {
				g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)==", strconv.Quote(v), "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesRegMatch) {
		match := proto.GetExtension(fop, pbex.E_StringBytesRegMatch).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, m := range match {
				g.P("if !_", service.GoName, "Regs[", strconv.Quote(m), "].Match(v){")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, m := range match {
				g.P("if !_", service.GoName, "Regs[", strconv.Quote(m), "].Match(", prefix+fieldname, "){")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesRegNotMatch) {
		notmatch := proto.GetExtension(fop, pbex.E_StringBytesRegNotMatch).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, m := range notmatch {
				g.P("if _", service.GoName, "Regs[", strconv.Quote(m), "].Match(v){")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, m := range notmatch {
				g.P("if _", service.GoName, "Regs[", strconv.Quote(m), "].Match(", prefix+fieldname, "){")
				g.P("}")
			}
		}
	}
}
func stringcheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, service *protogen.Service, g *protogen.GeneratedFile, server bool) {
	if proto.HasExtension(fop, pbex.E_StringBytesIn) {
		in := proto.GetExtension(fop, pbex.E_StringBytesIn).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, v := range in {
				g.P("if v!=", strconv.Quote(v), "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range in {
				g.P("if ", prefix+fieldname, "!=", strconv.Quote(v), "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesNotIn) {
		notin := proto.GetExtension(fop, pbex.E_StringBytesNotIn).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, v := range notin {
				g.P("if v==", strconv.Quote(v), "{")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range notin {
				g.P("if ", prefix+fieldname, "==", strconv.Quote(v), "{")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesRegMatch) {
		match := proto.GetExtension(fop, pbex.E_StringBytesRegMatch).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, m := range match {
				g.P("if !_", service.GoName, "Regs[", strconv.Quote(m), "].MatchString(v){")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, m := range match {
				g.P("if !_", service.GoName, "Regs[", strconv.Quote(m), "].MatchString(", prefix+fieldname, "){")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesRegNotMatch) {
		notmatch := proto.GetExtension(fop, pbex.E_StringBytesRegNotMatch).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, m := range notmatch {
				g.P("if _", service.GoName, "Regs[", strconv.Quote(m), "].Match(v){")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, m := range notmatch {
				g.P("if _", service.GoName, "Regs[", strconv.Quote(m), "].Match(", prefix+fieldname, "){")
				g.P("}")
			}
		}
	}
}
func messagecheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile, service bool) {
	if proto.HasExtension(fop, pbex.E_MessageNotNil) {
		//message not nil extension can only be set to true
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if ", prefix+fieldname, "==nil{")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "==nil{")
			g.P("}")
		}
	}
}
