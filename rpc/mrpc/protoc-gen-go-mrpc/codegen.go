package main

import (
	"fmt"
	"sort"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func genfile(plugin *protogen.Plugin, file *protogen.File) {
	f := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+"_mrpc.pb.go", file.GoImportPath)
	//package
	dealPackage(f, file)
	//import
	dealImports(f, file)
	//path
	dealPath(f, file)
	//client struct
	dealClientStruct(f, file)
	//client Handlefunc
	dealClientHandlefunc(f, file)
	//client new
	dealClientNew(f, file)
	//server struct
	dealServerStruct(f, file)
	//server handlefunc
	dealServerHandlefunc(f, file)
	//server register
	dealServerRegister(f, file)
}
func dealPackage(f *protogen.GeneratedFile, file *protogen.File) {
	f.P("// Code generated by protoc-gen-go-mrpc. DO NOT EDIT.")
	f.P()
	f.P(fmt.Sprintf("package %s", file.GoPackageName))
	f.P()
}
func dealImports(f *protogen.GeneratedFile, file *protogen.File) {
	deal := func(imports map[string]struct{}) {
		if len(imports) == 0 {
			return
		}
		temp := make([]string, len(imports))
		count := 0
		for v := range imports {
			temp[count] = v
			count++
		}
		sort.Strings(temp)
		for _, v := range temp {
			f.P(fmt.Sprintf("%s", v))
		}
	}
	//std package
	importsSTD := make(map[string]struct{})
	importsSTD[strconv.Quote("context")] = struct{}{}

	//third package
	importsTHIRD := make(map[string]struct{})
	importsTHIRD[strconv.Quote("github.com/chenjie199234/Corelib/rpc/mrpc")] = struct{}{}
	importsTHIRD[strconv.Quote("google.golang.org/protobuf/proto")] = struct{}{}
	//self package
	importsSELF := make(map[string]struct{})
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if method.Input.GoIdent.GoImportPath.String() != "" && method.Input.GoIdent.GoImportPath.String() != file.GoImportPath.String() {
				importsSELF[method.Input.GoIdent.GoImportPath.String()] = struct{}{}
			}
			if method.Output.GoIdent.GoImportPath.String() != "" && method.Output.GoIdent.GoImportPath.String() != file.GoImportPath.String() {
				importsSELF[method.Output.GoIdent.GoImportPath.String()] = struct{}{}
			}
		}
	}
	f.P("import (")
	f.P("//std")
	deal(importsSTD)
	f.P()
	f.P("//third")
	deal(importsTHIRD)
	f.P()
	if len(importsSELF) > 0 {
		f.P("//project")
		deal(importsSELF)
	}
	f.P(")")
	f.P()
}
func dealPath(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		for _, method := range service.Methods {
			pathname := fmt.Sprintf("PathMrpc%s%s", service.GoName, method.GoName)
			path := fmt.Sprintf("/%s/%s", service.GoName, method.GoName)
			f.P(fmt.Sprintf("var %s = %s", pathname, strconv.Quote(path)))
		}
		f.P()
	}
}
func dealClientStruct(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Mrpc%sClient", service.GoName)
		f.P(fmt.Sprintf("type %s struct{", structname))
		f.P("c *mrpc.MrpcClient")
		f.P("}")
	}
}
func dealClientHandlefunc(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Mrpc%sClient", service.GoName)
		for _, method := range service.Methods {
			inputpac := method.Input.Desc.(protoreflect.Descriptor).ParentFile().Package()
			outputpac := method.Output.Desc.(protoreflect.Descriptor).ParentFile().Package()
			var input string
			var output string
			if string(inputpac) == string(file.GoPackageName) {
				input = fmt.Sprintf("%s", method.Input.GoIdent.GoName)
			} else {
				input = fmt.Sprintf("%s.%s", inputpac, method.Input.GoIdent.GoName)
			}
			if string(outputpac) == string(file.GoPackageName) {
				output = fmt.Sprintf("%s", method.Output.GoIdent.GoName)
			} else {
				output = fmt.Sprintf("%s.%s", outputpac, method.Output.GoIdent.GoName)
			}
			path := fmt.Sprintf("/%s/%s", service.GoName, method.GoName)
			f.P(fmt.Sprintf("func (c *%s)%s(ctx context.Context,req *%s)(*%s,*mrpc.MsgErr){", structname, method.GoName, input, output))
			f.P("reqd,_:=proto.Marshal(req)")
			f.P(fmt.Sprintf("respd,err:=c.c.Call(ctx,%s,reqd)", strconv.Quote(path)))
			f.P("if err!=nil{")
			f.P("return nil,err")
			f.P("}")
			f.P("if respd == nil{")
			f.P(fmt.Sprintf("return &%s{},nil", output))
			f.P("}")
			f.P(fmt.Sprintf("resp:=new(%s)", output))
			f.P("if e:=proto.Unmarshal(respd,resp);e!=nil{")
			f.P("//this is impossible")
			f.P("return nil,mrpc.Errmaker(mrpc.ERRRESPONSE,mrpc.ERRMESSAGE[mrpc.ERRRESPONSE])")
			f.P("}")
			f.P("return resp,nil")
			f.P("}")
		}
	}
}
func dealClientNew(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Mrpc%sClient", service.GoName)
		f.P(fmt.Sprintf("func New%s(c *mrpc.MrpcClient)*%s{", structname, structname))
		f.P(fmt.Sprintf("return &%s{c:c}", structname))
		f.P("}")
	}
}
func dealServerStruct(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Mrpc%sService", service.GoName)
		f.P(fmt.Sprintf("type %s struct {", structname))
		f.P("Midware func()map[string][]mrpc.OutsideHandler")
		for _, method := range service.Methods {
			inputpac := method.Input.Desc.(protoreflect.Descriptor).ParentFile().Package()
			outputpac := method.Output.Desc.(protoreflect.Descriptor).ParentFile().Package()
			var input string
			var output string
			if string(inputpac) == string(file.GoPackageName) {
				input = fmt.Sprintf("%s", method.Input.GoIdent.GoName)
			} else {
				input = fmt.Sprintf("%s.%s", inputpac, method.Input.GoIdent.GoName)
			}
			if string(outputpac) == string(file.GoPackageName) {
				output = fmt.Sprintf("%s", method.Output.GoIdent.GoName)
			} else {
				output = fmt.Sprintf("%s.%s", outputpac, method.Output.GoIdent.GoName)
			}
			f.P(fmt.Sprintf("%s func(context.Context, *%s) (*%s,*mrpc.MsgErr)", method.GoName, input, output))
		}
		f.P("}")
		f.P()
	}
}
func dealServerHandlefunc(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Mrpc%sService", service.GoName)
		for _, method := range service.Methods {
			inputpac := method.Input.Desc.(protoreflect.Descriptor).ParentFile().Package()
			f.P(fmt.Sprintf("func (s *%s)%s(ctx context.Context,in []byte)([]byte,*mrpc.MsgErr) {", structname, unexport(method.GoName)))
			if string(inputpac) == string(file.GoPackageName) {
				f.P(fmt.Sprintf("req := &%s{}", method.Input.GoIdent.GoName))
			} else {
				f.P(fmt.Sprintf("req := &%s.%s{}", inputpac, method.Input.GoIdent.GoName))
			}
			f.P("if e:=proto.Unmarshal(in,req);e!=nil{")
			f.P("return nil,mrpc.Errmaker(mrpc.ERRREQUEST,mrpc.ERRMESSAGE[mrpc.ERRREQUEST])")
			f.P("}")
			f.P(fmt.Sprintf("resp,err:=s.%s(ctx,req)", method.GoName))
			f.P("if err!=nil{")
			f.P("return nil,err")
			f.P("}")
			f.P("if resp!=nil{")
			f.P("d,_:=proto.Marshal(resp)")
			f.P("return d,err")
			f.P("}")
			f.P("return nil,nil")
			f.P("}")
		}
	}
}

func dealServerRegister(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Mrpc%sService", service.GoName)
		f.P(fmt.Sprintf("func Register%s(engine *mrpc.MrpcServer, instance *%s) {", structname, structname))
		f.P("var allmids map[string][]mrpc.OutsideHandler")
		f.P("if instance.Midware!=nil{allmids=instance.Midware()}")
		for _, method := range service.Methods {
			pathname := fmt.Sprintf("PathMrpc%s%s", service.GoName, method.GoName)
			f.P(fmt.Sprintf("//%s", method.GoName))
			_, timeout := commentTrail(strings.TrimSpace(strings.TrimSuffix(string(method.Comments.Trailing), "\n")))
			f.P(fmt.Sprintf("if instance.%s != nil {", method.GoName))
			f.P(fmt.Sprintf("if mids,ok := allmids[%s];ok && len(mids)!=0{", pathname))
			f.P(fmt.Sprintf("engine.RegisterHandler(%s,%d,append(mids,instance.%s)...)", pathname, timeout, unexport(method.GoName)))
			f.P("}else{")
			f.P(fmt.Sprintf("engine.RegisterHandler(%s,%d,instance.%s)", pathname, timeout, unexport(method.GoName)))
			f.P("}")
			f.P("}")
		}
		f.P("}")
		f.P()
	}
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }

func commentTrail(trail string) (string, int64) {
	if trail == "" {
		return "GET", 0
	}
	httpmethod := ""
	timeout := int64(0)
	trails := strings.Split(trail, ",")
	for _, t := range trails {
		tt := strings.Split(t, ":")
		if len(tt) != 2 {
			panic("unknown trail comment")
		}
		switch tt[0] {
		case "httpmethod":
			httpmethod = strings.TrimSpace(strings.ToUpper(tt[1]))
		case "timeout":
			temptimeout := ""
			temptimeoutunit := ""
			for i, v := range tt[1] {
				if v < '0' || v > '9' {
					temptimeout = tt[1][:i]
					temptimeoutunit = tt[1][i:]
					break
				}
				if i == len(tt[1])-1 {
					temptimeout = tt[1]
				}
			}
			if temptimeout == "" {
				timeout = 0
			} else {
				timeout, _ = strconv.ParseInt(temptimeout, 10, 64)
				if timeout < 0 {
					panic("timeout less then 0")
				}
			}
			switch temptimeoutunit {
			case "":
			case "ms":
			case "s":
				timeout = timeout * 1000
			default:
				panic("timeout unit only support 'ms' and 's'")
			}
		}
	}
	if httpmethod == "" {
		httpmethod = "GET"
	}
	return httpmethod, timeout
}
