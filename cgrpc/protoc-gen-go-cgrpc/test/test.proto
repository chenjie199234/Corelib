//protoc -I ../../../pbex -I . --go_out=paths=source_relative:. *.proto
syntax="proto3";
package test;
option go_package="github.com/chenjie199234/Corelib/grpc/protoc-gen-go-grpc/test;test";
import "pbex.proto";
service test {
	rpc hello(helloreq)returns(helloresp){
		option (pbex.method)="get";
		option (pbex.grpc_midwares)="user";
		option (pbex.grpc_midwares)="limit";
	}
}
enum TestEnum {
	ENUMA=0;
	ENUMB=1;
}
message test_data{
	int32 i32=1[(pbex.int_in)=1];
	repeated int32 ri32=2[(pbex.int_not_in)=1];
	uint32 ui32=3[(pbex.uint_in)=1];
	repeated uint32 rui32=4[(pbex.map_repeated_len_gt)=2,(pbex.uint_not_in)=1];
	int64 i64=5;
	repeated int64 ri64=6;
	uint64 ui64=7;
	repeated uint64 rui64=8;
	bytes bs=9;
	repeated bytes rbs=10;
	string ss=11;
	repeated string rss=12[(pbex.string_bytes_reg_not_match)="123*"];
	float f=13;
	repeated float rf=14;
	double d=15;
	repeated double rd=16;
	TestEnum e=17;
	repeated TestEnum re=18;
	test_data m=19;
	repeated test_data rm=20;

	map<int32,int32> mi32_i32=21;
	map<int32,uint32> mi32_ui32=22;
	map<int32,int64> mi32_i64=23;
	map<int32,uint64> mi32_ui64=24;
	map<int32,bytes> mi32_bs=25;
	map<int32,string> mi32_ss=26;
	map<int32,float> mi32_f=27;
	map<int32,double> mi32_d=28;
	map<int32,TestEnum> mi32_e=29;
	map<int32,test_data> mi32_m=30;

	map<uint32,int32> mui32_i32=31;
	map<uint32,uint32> mui32_ui32=32;
	map<uint32,int64> mui32_i64=33;
	map<uint32,uint64> mui32_ui64=34;
	map<uint32,bytes> mui32_bs=35;
	map<uint32,string> mui32_ss=36[(pbex.map_value_string_bytes_reg_not_match)="789*"];
	map<uint32,float> mui32_f=37;
	map<uint32,double> mui32_d=38;
	map<uint32,TestEnum> mui32_e=39;
	map<uint32,test_data> mui32_m=40;

	map<int64,int32> mi64_i32=41;
	map<int64,uint32> mi64_ui32=42;
	map<int64,int64> mi64_i64=43;
	map<int64,uint64> mi64_ui64=44;
	map<int64,bytes> mi64_bs=45;
	map<int64,string> mi64_ss=46;
	map<int64,float> mi64_f=47;
	map<int64,double> mi64_d=48;
	map<int64,TestEnum> mi64_e=49;
	map<int64,test_data> mi64_m=50;

	map<uint64,int32> mui64_i32=51;
	map<uint64,uint32> mui64_ui32=52;
	map<uint64,int64> mui64_i64=53;
	map<uint64,uint64> mui64_ui64=54;
	map<uint64,bytes> mui64_bs=55;
	map<uint64,string> mui64_ss=56;
	map<uint64,float> mui64_f=57;
	map<uint64,double> mui64_d=58;
	map<uint64,TestEnum> mui64_e=59;
	map<uint64,test_data> mui64_m=60[(pbex.map_value_message_not_nil)=true];

	map<string,int32> mss_i32=61[(pbex.map_key_string_reg_not_match)="notkey*"];
	map<string,uint32> mss_ui32=62;
	map<string,int64> mss_i64=63;
	map<string,uint64> mss_ui64=64;
	map<string,bytes> mss_bs=65;
	map<string,string> mss_ss=66;
	map<string,float> mss_f=67;
	map<string,double> mss_d=68;
	map<string,TestEnum> mss_e=69;
	map<string,test_data> mss_m=70;
}
message helloreq{
	int32 i32=1[(pbex.int_in)=1];
	repeated int32 ri32=2[(pbex.int_not_in)=1];
	uint32 ui32=3[(pbex.uint_in)=1];
	repeated uint32 rui32=4[(pbex.map_repeated_len_gt)=2,(pbex.uint_not_in)=1];
	int64 i64=5;
	repeated int64 ri64=6;
	uint64 ui64=7;
	repeated uint64 rui64=8;
	bytes bs=9;
	repeated bytes rbs=10;
	string ss=11;
	repeated string rss=12[(pbex.string_bytes_reg_match)="abc*"];
	float f=13;
	repeated float rf=14;
	double d=15;
	repeated double rd=16;
	TestEnum e=17;
	repeated TestEnum re=18;
	test_data m=19[(pbex.message_not_nil)=true];
	repeated test_data rm=20[(pbex.message_not_nil)=true];

	map<int32,int32> mi32_i32=21;
	map<int32,uint32> mi32_ui32=22;
	map<int32,int64> mi32_i64=23;
	map<int32,uint64> mi32_ui64=24;
	map<int32,bytes> mi32_bs=25;
	map<int32,string> mi32_ss=26;
	map<int32,float> mi32_f=27;
	map<int32,double> mi32_d=28;
	map<int32,TestEnum> mi32_e=29;
	map<int32,test_data> mi32_m=30;

	map<uint32,int32> mui32_i32=31;
	map<uint32,uint32> mui32_ui32=32;
	map<uint32,int64> mui32_i64=33;
	map<uint32,uint64> mui32_ui64=34;
	map<uint32,bytes> mui32_bs=35;
	map<uint32,string> mui32_ss=36[(pbex.map_value_string_bytes_reg_match)="xyz*"];
	map<uint32,float> mui32_f=37;
	map<uint32,double> mui32_d=38;
	map<uint32,TestEnum> mui32_e=39;
	map<uint32,test_data> mui32_m=40;

	map<int64,int32> mi64_i32=41;
	map<int64,uint32> mi64_ui32=42;
	map<int64,int64> mi64_i64=43;
	map<int64,uint64> mi64_ui64=44;
	map<int64,bytes> mi64_bs=45;
	map<int64,string> mi64_ss=46;
	map<int64,float> mi64_f=47;
	map<int64,double> mi64_d=48;
	map<int64,TestEnum> mi64_e=49;
	map<int64,test_data> mi64_m=50;

	map<uint64,int32> mui64_i32=51;
	map<uint64,uint32> mui64_ui32=52;
	map<uint64,int64> mui64_i64=53;
	map<uint64,uint64> mui64_ui64=54;
	map<uint64,bytes> mui64_bs=55;
	map<uint64,string> mui64_ss=56;
	map<uint64,float> mui64_f=57;
	map<uint64,double> mui64_d=58;
	map<uint64,TestEnum> mui64_e=59;
	map<uint64,test_data> mui64_m=60;

	map<string,int32> mss_i32=61[(pbex.map_key_string_reg_match)="key*"];
	map<string,uint32> mss_ui32=62;
	map<string,int64> mss_i64=63;
	map<string,uint64> mss_ui64=64;
	map<string,bytes> mss_bs=65;
	map<string,string> mss_ss=66;
	map<string,float> mss_f=67;
	map<string,double> mss_d=68;
	map<string,TestEnum> mss_e=69;
	map<string,test_data> mss_m=70;
}
message helloresp{

}
message worldreq{

}
message worldresp{

}
