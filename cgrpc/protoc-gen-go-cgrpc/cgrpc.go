package main

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/chenjie199234/Corelib/internal/version"
	"github.com/chenjie199234/Corelib/pbex"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	slogPackage    = protogen.GoImportPath("log/slog")
	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
	cgrpcPackage   = protogen.GoImportPath("github.com/chenjie199234/Corelib/cgrpc")
	cerrorPackage  = protogen.GoImportPath("github.com/chenjie199234/Corelib/cerror")
)

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_cgrpc.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		count := 0
		for _, method := range service.Methods {
			mop := method.Desc.Options().(*descriptorpb.MethodOptions)
			if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
				continue
			}
			emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
			need := false
			for _, em := range emethod {
				if strings.ToUpper(em) == "GRPC" {
					need = true
					break
				}
			}
			if !need {
				continue
			}
			count++
		}
		if count > 0 {
			genService(file, service, g)
		}
	}
	return g
}
func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-go-cgrpc. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-go-cgrpc ", version.String(), "<br />")
	g.P("// \tprotoc              ", protocVersion, "<br />")
	g.P("// source: ", file.Desc.Path(), "<br />")
	g.P()
}

func genService(file *protogen.File, s *protogen.Service, g *protogen.GeneratedFile) {
	genPath(file, s, g)
	genClient(file, s, g)
	genServer(file, s, g)
}

func genPath(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		pathname := "_CGrpcPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		g.P("var ", pathname, "=", strconv.Quote(pathurl))
	}
	g.P()
}
func genServer(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Server interface.
	serverName := service.GoName + "CGrpcServer"

	g.P("type ", serverName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Context is *cgrpc.NoStreamServerContext\n",
				method.GoName,
				"(",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",*",
				g.QualifiedGoIdent(method.Input.GoIdent),
				")(*",
				g.QualifiedGoIdent(method.Output.GoIdent),
				",error)",
				method.Comments.Trailing)
		}
		if !method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Context is *cgrpc.ServerStreamServerContext["+method.Output.GoIdent.GoName+"]\n//Warning!Context will keep working when the server is graceful stopping and it will block the graceful stop until all Handler return\n",
				method.GoName,
				"(",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",*",
				g.QualifiedGoIdent(method.Input.GoIdent),
				")error",
				method.Comments.Trailing)
		}
		if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Context is *cgrpc.ClientStreamServerContext["+method.Input.GoIdent.GoName+"]\n//Warning!Context will keep working when the server is graceful stopping and it will block the graceful stop until all Handler return\n",
				method.GoName,
				"(",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				")(*",
				g.QualifiedGoIdent(method.Output.GoIdent),
				",error)",
				method.Comments.Trailing)
		}
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Context is *cgrpc.AllStreamServerContext["+method.Input.GoIdent.GoName+","+method.Output.GoIdent.GoName+"]\n//Warning!Context will keep working when the server is graceful stopping and it will block the graceful stop until all Handler return\n",
				method.GoName,
				"(",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				")error",
				method.Comments.Trailing)
		}
	}
	g.P("}")
	g.P()
	// Server handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		fname := "func _" + service.GoName + "_" + method.GoName + "_" + "CGrpcHandler"
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
			freturn := g.QualifiedGoIdent(cgrpcPackage.Ident("OutsideHandler"))
			g.P(fname, "(", p1, ")", freturn, "{")
			g.P("return func(ctx *", g.QualifiedGoIdent(cgrpcPackage.Ident("ServerContext")), "){")
			g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
			g.P("if e := ctx.Read(req); e != nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] decode failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")

			if pbex.NeedValidate(method.Input) {
				g.P("if errstr := req.Validate(); errstr != \"\" {")
				g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] validate failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",errstr))")
				g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
				g.P("return")
				g.P("}")
			}

			g.P("resp,e:=handler(", g.QualifiedGoIdent(cgrpcPackage.Ident("NewNoStreamServerContext")), "(ctx),req)")
			g.P("if e!=nil{")
			g.P("ctx.Abort(e)")
			g.P("return")
			g.P("}")
			g.P("if resp == nil{")
			g.P("resp = new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
			g.P("}")
			g.P("ctx.Write(resp)")
			g.P("}")
			g.P("}")
		}
		if !method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")error"
			freturn := g.QualifiedGoIdent(cgrpcPackage.Ident("OutsideHandler"))
			g.P(fname, "(", p1, ")", freturn, "{")
			g.P("return func(ctx *", g.QualifiedGoIdent(cgrpcPackage.Ident("ServerContext")), "){")
			g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
			g.P("if e:=ctx.Read(req);e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] decode failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")
			if pbex.NeedValidate(method.Input) {
				g.P("if errstr := req.Validate(); errstr != \"\" {")
				g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] validate failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",errstr))")
				g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
				g.P("return")
				g.P("}")
			}
			g.P("if e:=handler(", g.QualifiedGoIdent(cgrpcPackage.Ident("NewServerStreamServerContext")), "[", g.QualifiedGoIdent(method.Output.GoIdent), "](ctx),req);e!=nil{")
			g.P("ctx.Abort(e)")
			g.P("}")
			g.P("}")
			g.P("}")
		}
		if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
			freturn := g.QualifiedGoIdent(cgrpcPackage.Ident("OutsideHandler"))
			g.P(fname, "(", p1, ")", freturn, "{")
			g.P("return func(ctx *", g.QualifiedGoIdent(cgrpcPackage.Ident("ServerContext")), "){")
			g.P("resp,e:=handler(", g.QualifiedGoIdent(cgrpcPackage.Ident("NewClientStreamServerContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), "](ctx,", pbex.NeedValidate(method.Input), "))")
			g.P("if e!=nil {")
			g.P("ctx.Abort(e)")
			g.P("return")
			g.P("}")
			g.P("if resp == nil{")
			g.P("resp = new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
			g.P("}")
			g.P("ctx.Write(resp)")
			g.P("}")
			g.P("}")
		}
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ")error"
			freturn := g.QualifiedGoIdent(cgrpcPackage.Ident("OutsideHandler"))
			g.P(fname, "(", p1, ")", freturn, "{")
			g.P("return func(ctx *", g.QualifiedGoIdent(cgrpcPackage.Ident("ServerContext")), "){")
			g.P("if e:=handler(", g.QualifiedGoIdent(cgrpcPackage.Ident("NewAllStreamServerContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), ",", g.QualifiedGoIdent(method.Output.GoIdent), "](ctx,", pbex.NeedValidate(method.Input), "));e!=nil{")
			g.P("ctx.Abort(e)")
			g.P("}")
			g.P("}")
			g.P("}")
		}
	}

	//Server Register
	g.P("func Register", serverName, "(engine *", g.QualifiedGoIdent(cgrpcPackage.Ident("CGrpcServer")), ",svc ", serverName, ",allmids map[string]", g.QualifiedGoIdent(cgrpcPackage.Ident("OutsideHandler")), "){")
	g.P("//avoid lint")
	g.P("_=allmids")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		var mids []string
		if proto.HasExtension(mop, pbex.E_CgrpcMidwares) {
			mids = proto.GetExtension(mop, pbex.E_CgrpcMidwares).([]string)
		}
		fname := "_" + service.GoName + "_" + method.GoName + "_" + "CGrpcHandler(svc." + method.GoName + ")"
		if len(mids) > 0 {
			g.P("{")
			str := ""
			for _, mid := range mids {
				str += ","
				str += strconv.Quote(mid)
			}
			str = str[1:]
			g.P("requiredMids:=[]string{", str, "}")
			g.P("mids:=make([]", g.QualifiedGoIdent(cgrpcPackage.Ident("OutsideHandler")), ",0,", len(mids)+1, ")")
			g.P("for _,v:=range requiredMids{")
			g.P("if mid,ok:=allmids[v];ok{")
			g.P("mids = append(mids,mid)")
			g.P("}else{")
			g.P("panic(\"missing midware:\"+v)")
			g.P("}")
			g.P("}")
			g.P("mids = append(mids,", fname, ")")
			g.P("engine.RegisterHandler(", strconv.Quote(*file.Proto.Package+"."+string(service.Desc.Name())), ",", strconv.Quote(string(method.Desc.Name())), ",", method.Desc.IsStreamingClient(), ",", method.Desc.IsStreamingServer(), ",mids...)")
			g.P("}")
		} else {
			g.P("engine.RegisterHandler(", strconv.Quote(*file.Proto.Package+"."+string(service.Desc.Name())), ",", strconv.Quote(string(method.Desc.Name())), ",", method.Desc.IsStreamingClient(), ",", method.Desc.IsStreamingServer(), ",", fname, ")")
		}
	}
	g.P("}")
}
func genClient(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Client interface.
	clientName := service.GoName + "CGrpcClient"
	lowclientName := strings.ToLower(clientName[:1]) + clientName[1:]

	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading,
				method.GoName,
				"(",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",*",
				g.QualifiedGoIdent(method.Input.GoIdent),
				")(*",
				g.QualifiedGoIdent(method.Output.GoIdent),
				",error)",
				method.Comments.Trailing)
		}
		if !method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Warning!handler and Context param in handler will keep working when the client is graceful stopping and it will block the graceful stop until all Handler return\n",
				method.GoName,
				"(ctx ",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",req *",
				g.QualifiedGoIdent(method.Input.GoIdent),
				",handler func(*", g.QualifiedGoIdent(cgrpcPackage.Ident("ServerStreamClientContext")), "[", g.QualifiedGoIdent(method.Output.GoIdent), "])error)error",
				method.Comments.Trailing)
		}
		if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Warning!handler and Context param in handler will keep working when the client is graceful stopping and it will block the graceful stop until all Handler return\n",
				method.GoName,
				"(ctx ",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",handler func(*", g.QualifiedGoIdent(cgrpcPackage.Ident("ClientStreamClientContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), "])error)(resp *",
				g.QualifiedGoIdent(method.Output.GoIdent),
				",e error)",
				method.Comments.Trailing)
		}
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Warning!handler and Context param in handler will keep working when the client is graceful stopping and it will block the graceful stop until all Handler return\n",
				method.GoName,
				"(ctx ",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",handler func(*", g.QualifiedGoIdent(cgrpcPackage.Ident("AllStreamClientContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), ",", g.QualifiedGoIdent(method.Output.GoIdent), "])error)error",
				method.Comments.Trailing)
		}
	}
	g.P("}")
	g.P()
	g.P("type ", lowclientName, " struct{")
	g.P("cc ", g.QualifiedGoIdent(grpcPackage.Ident("ClientConnInterface")))
	g.P("}")
	g.P("func New", clientName, "(cc ", g.QualifiedGoIdent(grpcPackage.Ident("ClientConnInterface")), ")(", clientName, "){")
	g.P("return &", lowclientName, "{cc:cc}")
	g.P("}")
	g.P()
	// Client handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		pathname := "_CGrpcPath" + service.GoName + method.GoName
		p1 := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
			freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
			g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")", freturn, "{")
			g.P("if req == nil {")
			g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
			g.P("}")

			if pbex.NeedValidate(method.Input) {
				g.P("if errstr := req.Validate(); errstr != \"\" {")
				g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] validate failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",errstr))")
				g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
				g.P("}")
			}

			g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
			g.P("if e:=c.cc.Invoke(ctx,", pathname, ",req,resp);e!=nil{")
			g.P("return nil,e")
			g.P("}")
			g.P("return resp, nil")
			g.P("}")
		}
		if !method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
			p3 := "handler func(*" + g.QualifiedGoIdent(cgrpcPackage.Ident("ServerStreamClientContext")) + "[" + g.QualifiedGoIdent(method.Output.GoIdent) + "])error"
			freturn := "error"
			g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ",", p3, ")", freturn, "{")
			g.P("if req == nil {")
			g.P("return ", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
			g.P("}")
			if pbex.NeedValidate(method.Input) {
				g.P("if errstr := req.Validate(); errstr != \"\" {")
				g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] validate failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",errstr))")
				g.P("return ", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
				g.P("}")
			}
			g.P("desc := &", g.QualifiedGoIdent(grpcPackage.Ident("StreamDesc")), "{")
			g.P("ServerStreams:true,")
			g.P("StreamName:\"", method.Desc.Name(), "\",")
			g.P("}")
			g.P("stream,e:=c.cc.NewStream(ctx,desc,", pathname, ")")
			g.P("if e!=nil{")
			g.P("return e")
			g.P("}")
			g.P("if e:= stream.SendMsg(req);e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] send request failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("return e")
			g.P("}")
			g.P("if e:=stream.CloseSend();e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] send request failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("return e")
			g.P("}")
			g.P("return handler(", g.QualifiedGoIdent(cgrpcPackage.Ident("NewServerStreamClientContext")), "[", g.QualifiedGoIdent(method.Output.GoIdent), "](", pathname, ",", "stream))")
			g.P("}")
		}
		if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			p2 := "handler func(*" + g.QualifiedGoIdent(cgrpcPackage.Ident("ClientStreamClientContext")) + "[" + g.QualifiedGoIdent(method.Input.GoIdent) + "])error"
			freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
			g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")", freturn, "{")
			g.P("desc := &", g.QualifiedGoIdent(grpcPackage.Ident("StreamDesc")), "{")
			g.P("ClientStreams:true,")
			g.P("StreamName:\"", method.Desc.Name(), "\",")
			g.P("}")
			g.P("stream,e:=c.cc.NewStream(ctx,desc,", pathname, ")")
			g.P("if e!=nil{")
			g.P("return nil,e")
			g.P("}")
			g.P("if e=handler(", g.QualifiedGoIdent(cgrpcPackage.Ident("NewClientStreamClientContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), "](", pathname, ",", "stream,", pbex.NeedValidate(method.Input), "));e!=nil{")
			g.P("stream.CloseSend()")
			g.P("return nil,e")
			g.P("}")
			g.P("if e=stream.CloseSend();e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] read response failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("return nil,e")
			g.P("}")
			g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
			g.P("if e=stream.RecvMsg(resp);e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] read response failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("return nil,e")
			g.P("}")
			g.P("return resp,nil")
			g.P("}")
		}
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			p2 := "handler func(*" + g.QualifiedGoIdent(cgrpcPackage.Ident("AllStreamClientContext")) + "[" + g.QualifiedGoIdent(method.Input.GoIdent) + "," + g.QualifiedGoIdent(method.Output.GoIdent) + "])error"
			g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")error{")
			g.P("desc := &", g.QualifiedGoIdent(grpcPackage.Ident("StreamDesc")), "{")
			g.P("ClientStreams:true,")
			g.P("ServerStreams:true,")
			g.P("StreamName:\"", method.Desc.Name(), "\",")
			g.P("}")
			g.P("stream,e:=c.cc.NewStream(ctx,desc,", pathname, ")")
			g.P("if e!=nil{")
			g.P("return e")
			g.P("}")
			g.P("e = handler(", g.QualifiedGoIdent(cgrpcPackage.Ident("NewAllStreamClientContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), ",", g.QualifiedGoIdent(method.Output.GoIdent), "](", pathname, ",stream,", pbex.NeedValidate(method.Input), "))")
			g.P("stream.CloseSend()")
			g.P("return e")
			g.P("}")
		}
	}
}
