package main

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/chenjie199234/Corelib/internal/version"
	"github.com/chenjie199234/Corelib/pbex"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
	cgrpcPackage   = protogen.GoImportPath("github.com/chenjie199234/Corelib/cgrpc")
	logPackage     = protogen.GoImportPath("github.com/chenjie199234/Corelib/log")
	cerrorPackage  = protogen.GoImportPath("github.com/chenjie199234/Corelib/cerror")
)

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_cgrpc.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		count := 0
		for _, method := range service.Methods {
			mop := method.Desc.Options().(*descriptorpb.MethodOptions)
			if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
				continue
			}
			emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
			need := false
			for _, em := range emethod {
				if strings.ToUpper(em) == "GRPC" {
					need = true
					break
				}
			}
			if !need {
				continue
			}
			count++
		}
		if count > 0 {
			genService(file, service, g)
		}
	}
	return g
}
func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-go-cgrpc. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-go-cgrpc ", version.String(), "<br />")
	g.P("// \tprotoc              ", protocVersion, "<br />")
	g.P("// source: ", file.Desc.Path(), "<br />")
	g.P()
}

func genService(file *protogen.File, s *protogen.Service, g *protogen.GeneratedFile) {
	genPath(file, s, g)
	genClient(file, s, g)
	genServer(file, s, g)
}

func genPath(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		pathname := "_CGrpcPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		g.P("var ", pathname, "=", strconv.Quote(pathurl))
	}
	g.P()
}
func genServer(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Server interface.
	serverName := service.GoName + "CGrpcServer"

	g.P("type ", serverName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")), ",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*", g.QualifiedGoIdent(method.Output.GoIdent), ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	// Server handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		fname := "func _" + service.GoName + "_" + method.GoName + "_" + "CGrpcHandler"
		p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		freturn := g.QualifiedGoIdent(cgrpcPackage.Ident("OutsideHandler"))
		g.P(fname, "(", p1, ")", freturn, "{")
		g.P("return func(ctx *", g.QualifiedGoIdent(cgrpcPackage.Ident("Context")), "){")
		g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
		g.P("if e := ctx.DecodeReq(req); e != nil{")
		g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] decode failed\")")
		g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
		g.P("return")
		g.P("}")

		if pbex.NeedValidate(method.Input) {
			g.P("if errstr := req.Validate(); errstr != \"\" {")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] validate failed\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(\"validate\",errstr))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")
		}

		g.P("resp,e:=handler(ctx,req)")
		g.P("if e!=nil{")
		g.P("ctx.Abort(e)")
		g.P("return")
		g.P("}")
		g.P("if resp == nil{")
		g.P("resp = new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("}")
		g.P("ctx.Write(resp)")
		g.P("}")
		g.P("}")
	}

	//Server Register
	g.P("func Register", serverName, "(engine *", g.QualifiedGoIdent(cgrpcPackage.Ident("CGrpcServer")), ",svc ", serverName, ",allmids map[string]", g.QualifiedGoIdent(cgrpcPackage.Ident("OutsideHandler")), "){")
	g.P("//avoid lint")
	g.P("_=allmids")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		var mids []string
		if proto.HasExtension(mop, pbex.E_CgrpcMidwares) {
			mids = proto.GetExtension(mop, pbex.E_CgrpcMidwares).([]string)
		}
		fname := "_" + service.GoName + "_" + method.GoName + "_" + "CGrpcHandler(svc." + method.GoName + ")"
		if len(mids) > 0 {
			g.P("{")
			str := ""
			for _, mid := range mids {
				str += ","
				str += strconv.Quote(mid)
			}
			str = str[1:]
			g.P("requiredMids:=[]string{", str, "}")
			g.P("mids:=make([]", g.QualifiedGoIdent(cgrpcPackage.Ident("OutsideHandler")), ",0,", len(mids)+1, ")")
			g.P("for _,v:=range requiredMids{")
			g.P("if mid,ok:=allmids[v];ok{")
			g.P("mids = append(mids,mid)")
			g.P("}else{")
			g.P("panic(\"missing midware:\"+v)")
			g.P("}")
			g.P("}")
			g.P("mids = append(mids,", fname, ")")
			g.P("engine.RegisterHandler(", strconv.Quote(*file.Proto.Package+"."+string(service.Desc.Name())), ",", strconv.Quote(string(method.Desc.Name())), ",mids...)")
			g.P("}")
		} else {
			g.P("engine.RegisterHandler(", strconv.Quote(*file.Proto.Package+"."+string(service.Desc.Name())), ",", strconv.Quote(string(method.Desc.Name())), ",", fname, ")")
		}
	}
	g.P("}")
}
func genClient(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Client interface.
	clientName := service.GoName + "CGrpcClient"
	lowclientName := strings.ToLower(clientName[:1]) + clientName[1:]

	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")), ",*", g.QualifiedGoIdent(method.Input.GoIdent), ",...", g.QualifiedGoIdent(grpcPackage.Ident("CallOption")), ")(*", g.QualifiedGoIdent(method.Output.GoIdent), ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	g.P("type ", lowclientName, " struct{")
	g.P("cc ", g.QualifiedGoIdent(grpcPackage.Ident("ClientConnInterface")))
	g.P("}")
	g.P("func New", clientName, "(cc ", g.QualifiedGoIdent(grpcPackage.Ident("ClientConnInterface")), ")(", clientName, "){")
	g.P("return &", lowclientName, "{cc:cc}")
	g.P("}")
	g.P()
	// Client handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "GRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		pathname := "_CGrpcPath" + service.GoName + method.GoName
		p1 := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		p3 := "opts ..." + g.QualifiedGoIdent(grpcPackage.Ident("CallOption"))
		freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ",", p3, ")", freturn, "{")
		g.P("if req == nil {")
		g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
		g.P("}")

		g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("if e:=c.cc.Invoke(ctx,", pathname, ",req,resp,opts...);e!=nil{")
		g.P("return nil,e")
		g.P("}")
		g.P("return resp, nil")
		g.P("}")
	}
}
