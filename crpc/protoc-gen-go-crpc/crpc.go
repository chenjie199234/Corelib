package main

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/chenjie199234/Corelib/internal/version"
	"github.com/chenjie199234/Corelib/pbex"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage   = protogen.GoImportPath("context")
	slogPackage      = protogen.GoImportPath("log/slog")
	protoPackage     = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protojsonPackage = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	crpcPackage      = protogen.GoImportPath("github.com/chenjie199234/Corelib/crpc")
	cerrorPackage    = protogen.GoImportPath("github.com/chenjie199234/Corelib/cerror")
)

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_crpc.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		count := 0
		for _, method := range service.Methods {
			mop := method.Desc.Options().(*descriptorpb.MethodOptions)
			if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
				continue
			}
			emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
			need := false
			for _, em := range emethod {
				if strings.ToUpper(em) == "CRPC" {
					need = true
					break
				}
			}
			if !need {
				continue
			}
			count++
		}
		if count > 0 {
			genService(file, service, g)
		}
	}
	return g
}
func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-go-crpc. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-go-crpc ", version.String(), "<br />")
	g.P("// \tprotoc             ", protocVersion, "<br />")
	g.P("// source: ", file.Desc.Path(), "<br />")
	g.P()
}

func genService(file *protogen.File, s *protogen.Service, g *protogen.GeneratedFile) {
	genPath(file, s, g)
	genClient(file, s, g)
	genServer(file, s, g)
}
func genPath(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "CRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		pathname := "_CrpcPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		g.P("var ", pathname, "=", strconv.Quote(pathurl))
	}
	g.P()
}
func genServer(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Server interface.
	serverName := service.GoName + "CrpcServer"

	g.P("type ", serverName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "CRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Context is *crpc.NoStreamServerContext\n",
				method.GoName,
				"(",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",*",
				g.QualifiedGoIdent(method.Input.GoIdent),
				")(*",
				g.QualifiedGoIdent(method.Output.GoIdent),
				",error)",
				method.Comments.Trailing)
		}
		if !method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Context is *crpc.ServerStreamServerContext["+method.Output.GoIdent.GoName+"]\n",
				method.GoName,
				"(",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",*",
				g.QualifiedGoIdent(method.Input.GoIdent),
				")error",
				method.Comments.Trailing)
		}
		if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Context is *crpc.ClientStreamServerContext["+method.Input.GoIdent.GoName+"]\n",
				method.GoName,
				"(",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				")(*",
				g.QualifiedGoIdent(method.Output.GoIdent),
				",error)",
				method.Comments.Trailing)
		}
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading, "//Context is *crpc.AllStreamServerContext["+method.Input.GoIdent.GoName+","+method.Output.GoIdent.GoName+"]\n",
				method.GoName,
				"(",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				")error",
				method.Comments.Trailing)
		}
	}
	g.P("}")
	g.P()
	// Server handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "CRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		pathname := "_CrpcPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		fname := "func _" + service.GoName + "_" + method.GoName + "_" + "CrpcHandler"
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
			freturn := g.QualifiedGoIdent(crpcPackage.Ident("OutsideHandler"))
			g.P(fname, "(", p1, ")", freturn, "{")
			g.P("return func(ctx *", g.QualifiedGoIdent(crpcPackage.Ident("ServerContext")), "){")
			g.P("reqbody,e:=ctx.Recv()")
			g.P("if e!=nil {")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] read request failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("ctx.Abort(e)")
			g.P("return")
			g.P("}")
			g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
			g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(reqbody,req);e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] request decode failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")

			if pbex.NeedValidate(method.Input) {
				g.P("if errstr := req.Validate(); errstr != \"\" {")
				g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] request validate failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",errstr))")
				g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
				g.P("return")
				g.P("}")
			}

			g.P("resp,e:=handler(", g.QualifiedGoIdent(crpcPackage.Ident("NewNoStreamServerContext")), "(", pathname, ",ctx),req)")
			g.P("if e!=nil{")
			g.P("ctx.Abort(e)")
			g.P("return")
			g.P("}")
			g.P("if resp == nil{")
			g.P("resp = new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
			g.P("}")
			g.P("respd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(resp)")
			g.P("if e:=ctx.Send(respd);e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] send response failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("}")
			g.P("}")
			g.P("}")
		}
		if !method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")error"
			freturn := g.QualifiedGoIdent(crpcPackage.Ident("OutsideHandler"))
			g.P(fname, "(", p1, ")", freturn, "{")
			g.P("return func(ctx *", g.QualifiedGoIdent(crpcPackage.Ident("ServerContext")), "){")
			g.P("reqbody,e:=ctx.Recv()")
			g.P("if e!=nil {")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] read request failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("ctx.Abort(e)")
			g.P("return")
			g.P("}")
			g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
			g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(reqbody,req);e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] request decode failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")

			if pbex.NeedValidate(method.Input) {
				g.P("if errstr := req.Validate(); errstr != \"\" {")
				g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] request validate failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",errstr))")
				g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
				g.P("return")
				g.P("}")
			}
			g.P("if e:=handler(", g.QualifiedGoIdent(crpcPackage.Ident("NewServerStreamServerContext")), "[", g.QualifiedGoIdent(method.Output.GoIdent), "](", pathname, ",ctx),req);e!=nil{")
			g.P("ctx.Abort(e)")
			g.P("return")
			g.P("}")
			g.P("}")
			g.P("}")
		}
		if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
			freturn := g.QualifiedGoIdent(crpcPackage.Ident("OutsideHandler"))
			g.P(fname, "(", p1, ")", freturn, "{")
			g.P("return func(ctx *", g.QualifiedGoIdent(crpcPackage.Ident("ServerContext")), "){")
			g.P("resp,e:=handler(", g.QualifiedGoIdent(crpcPackage.Ident("NewClientStreamServerContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), "](", pathname, ",ctx,", pbex.NeedValidate(method.Input), "))")
			g.P("if e!=nil {")
			g.P("ctx.Abort(e)")
			g.P("return")
			g.P("}")
			g.P("if resp == nil {")
			g.P("resp = new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
			g.P("}")
			g.P("respd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(resp)")
			g.P("if e:=ctx.Send(respd);e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] send response failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("}")
			g.P("}")
			g.P("}")
		}
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ")error"
			freturn := g.QualifiedGoIdent(crpcPackage.Ident("OutsideHandler"))
			g.P(fname, "(", p1, ")", freturn, "{")
			g.P("return func(ctx *", g.QualifiedGoIdent(crpcPackage.Ident("ServerContext")), "){")
			g.P("e:=handler(", g.QualifiedGoIdent(crpcPackage.Ident("NewAllStreamServerContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), ",", g.QualifiedGoIdent(method.Output.GoIdent), "](", pathname, ",ctx,", pbex.NeedValidate(method.Input), "))")
			g.P("if e!=nil {")
			g.P("ctx.Abort(e)")
			g.P("}")
			g.P("}")
			g.P("}")
		}
	}

	//Server Register
	g.P("func Register", serverName, "(engine *", g.QualifiedGoIdent(crpcPackage.Ident("CrpcServer")), ",svc ", serverName, ",allmids map[string]", g.QualifiedGoIdent(crpcPackage.Ident("OutsideHandler")), "){")
	g.P("//avoid lint")
	g.P("_=allmids")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "CRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		var mids []string
		if proto.HasExtension(mop, pbex.E_CrpcMidwares) {
			mids = proto.GetExtension(mop, pbex.E_CrpcMidwares).([]string)
		}
		fname := "_" + service.GoName + "_" + method.GoName + "_" + "CrpcHandler(svc." + method.GoName + ")"
		if len(mids) > 0 {
			g.P("{")
			str := ""
			for _, mid := range mids {
				str += ","
				str += strconv.Quote(mid)
			}
			str = str[1:]
			g.P("requiredMids:=[]string{", str, "}")
			g.P("mids:=make([]", g.QualifiedGoIdent(crpcPackage.Ident("OutsideHandler")), ",0,", len(mids)+1, ")")
			g.P("for _,v:=range requiredMids{")
			g.P("if mid,ok:=allmids[v];ok{")
			g.P("mids = append(mids,mid)")
			g.P("}else{")
			g.P("panic(\"missing midware:\"+v)")
			g.P("}")
			g.P("}")
			g.P("mids = append(mids,", fname, ")")
			g.P("engine.RegisterHandler(", strconv.Quote(*file.Proto.Package+"."+string(service.Desc.Name())), ",", strconv.Quote(string(method.Desc.Name())), ",mids...)")
			g.P("}")
		} else {
			g.P("engine.RegisterHandler(", strconv.Quote(*file.Proto.Package+"."+string(service.Desc.Name())), ",", strconv.Quote(string(method.Desc.Name())), ",", fname, ")")
		}
	}
	g.P("}")
}
func genClient(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Client interface.
	clientName := service.GoName + "CrpcClient"
	lowclientName := strings.ToLower(clientName[:1]) + clientName[1:]

	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "CRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading,
				method.GoName,
				"(ctx ",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",req *",
				g.QualifiedGoIdent(method.Input.GoIdent),
				")(resp *",
				g.QualifiedGoIdent(method.Output.GoIdent),
				",e error)",
				method.Comments.Trailing)
		}
		if !method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading,
				method.GoName,
				"(ctx ",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",req *",
				g.QualifiedGoIdent(method.Input.GoIdent),
				",handler func(*", g.QualifiedGoIdent(crpcPackage.Ident("ServerStreamClientContext")), "[", g.QualifiedGoIdent(method.Output.GoIdent), "])error)error",
				method.Comments.Trailing)
		}
		if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading,
				method.GoName,
				"(ctx ",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",handler func(*", g.QualifiedGoIdent(crpcPackage.Ident("ClientStreamClientContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), "])error)(resp *",
				g.QualifiedGoIdent(method.Output.GoIdent),
				",e error)",
				method.Comments.Trailing)
		}
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P(method.Comments.Leading,
				method.GoName,
				"(ctx ",
				g.QualifiedGoIdent(contextPackage.Ident("Context")),
				",handler func(*", g.QualifiedGoIdent(crpcPackage.Ident("AllStreamClientContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), ",", g.QualifiedGoIdent(method.Output.GoIdent), "])error)error",
				method.Comments.Trailing)
		}
	}
	g.P("}")
	g.P()
	g.P("type ", lowclientName, " struct{")
	g.P("cc *", g.QualifiedGoIdent(crpcPackage.Ident("CrpcClient")))
	g.P("}")
	g.P("func New", clientName, "(c *", g.QualifiedGoIdent(crpcPackage.Ident("CrpcClient")), ")(", clientName, "){")
	g.P("return &", lowclientName, "{cc:c}")
	g.P("}")
	g.P()
	// Client handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			if strings.ToUpper(em) == "CRPC" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		pathname := "_CrpcPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		p1 := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
			freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
			g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")", freturn, "{")
			g.P("if req == nil {")
			g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
			g.P("}")
			if pbex.NeedValidate(method.Input) {
				g.P("if errstr:=req.Validate();errstr!=\"\"{")
				g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] request validate failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",errstr))")
				g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
				g.P("}")
			}
			g.P("reqd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(req)")
			g.P("var respbody []byte")
			g.P("if e:=c.cc.Call(ctx,", pathname, ",reqd,func(ctx *", g.QualifiedGoIdent(crpcPackage.Ident("CallContext")), ")error{")
			g.P("var e error")
			g.P("if respbody,e = ctx.Recv();e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] read response failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("}")
			g.P("return e")
			g.P("});e!=nil{")
			g.P("return nil,e")
			g.P("}")
			g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
			g.P("if len(respbody)==0{")
			g.P("return resp,nil")
			g.P("}")
			g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(respbody,resp);e!=nil{")
			g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrResp")))
			g.P("}")
			g.P("return resp, nil")
			g.P("}")
		}
		if !method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
			p3 := "handler func(*" + g.QualifiedGoIdent(crpcPackage.Ident("ServerStreamClientContext")) + "[" + g.QualifiedGoIdent(method.Output.GoIdent) + "])error"
			g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ",", p3, ")error{")
			g.P("if req == nil {")
			g.P("return ", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
			g.P("}")
			if pbex.NeedValidate(method.Input) {
				g.P("if errstr:=req.Validate();errstr!=\"\"{")
				g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] request validate failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",errstr))")
				g.P("return ", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
				g.P("}")
			}
			g.P("reqd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(req)")
			g.P("return c.cc.Call(ctx,", pathname, ",reqd,func(ctx *", g.QualifiedGoIdent(crpcPackage.Ident("CallContext")), ")error{")
			g.P("return handler(", g.QualifiedGoIdent(crpcPackage.Ident("NewServerStreamClientContext")), "[", g.QualifiedGoIdent(method.Output.GoIdent), "](", pathname, ",ctx))")
			g.P("})")
			g.P("}")
		}
		if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			p2 := "handler func(*" + g.QualifiedGoIdent(crpcPackage.Ident("ClientStreamClientContext")) + "[" + g.QualifiedGoIdent(method.Input.GoIdent) + "])error"
			g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")(*", g.QualifiedGoIdent(method.Output.GoIdent), ",error){")
			g.P("var respbody []byte")
			g.P("if e:=c.cc.Stream(ctx,", pathname, ",func(ctx *", g.QualifiedGoIdent(crpcPackage.Ident("StreamContext")), ")error{")
			g.P("e:=handler(", g.QualifiedGoIdent(crpcPackage.Ident("NewClientStreamClientContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), "](", pathname, ",", "ctx,", pbex.NeedValidate(method.Input), "))")
			g.P("if e!=nil {")
			g.P("return e")
			g.P("}")
			g.P("if respbody,e = ctx.Recv();e!=nil{")
			g.P(g.QualifiedGoIdent(slogPackage.Ident("ErrorContext")), "(ctx,\"[", pathurl, "] read response failed\",", g.QualifiedGoIdent(slogPackage.Ident("String")), "(\"error\",e.Error()))")
			g.P("}")
			g.P("return e")
			g.P("});e!=nil{")
			g.P("return nil,e")
			g.P("}")
			g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
			g.P("if len(respbody)==0{")
			g.P("return resp,nil")
			g.P("}")
			g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(respbody,resp);e!=nil{")
			g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrResp")))
			g.P("}")
			g.P("return resp, nil")
			g.P("}")
		}
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			p2 := "handler func(*" + g.QualifiedGoIdent(crpcPackage.Ident("AllStreamClientContext")) + "[" + g.QualifiedGoIdent(method.Input.GoIdent) + "," + g.QualifiedGoIdent(method.Output.GoIdent) + "])error"
			g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")error{")
			g.P("return c.cc.Stream(ctx,", pathname, ",func(ctx *", g.QualifiedGoIdent(crpcPackage.Ident("StreamContext")), ")error{")
			g.P("return handler(", g.QualifiedGoIdent(crpcPackage.Ident("NewAllStreamClientContext")), "[", g.QualifiedGoIdent(method.Input.GoIdent), ",", g.QualifiedGoIdent(method.Output.GoIdent), "](", pathname, ",ctx,", pbex.NeedValidate(method.Input), "))")
			g.P("})")
			g.P("}")
		}
	}
}
