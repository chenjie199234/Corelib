package main

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/chenjie199234/Corelib/internal/version"
	"github.com/chenjie199234/Corelib/pbex"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	commonPackage = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/common")
	regexpPackage = protogen.GoImportPath("regexp")
)

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_pbex.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	for _, m := range file.Messages {
		if m.Desc.Options().(*descriptorpb.MessageOptions).GetDeprecated() {
			continue
		}
		genMessage(g, m)
	}
	return g
}
func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-go-pbex. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-pbex ", version.String())
	g.P("// \tprotoc         ", protocVersion)
	g.P("// source: ", file.Desc.Path())
	g.P()
}
func geninit(g *protogen.GeneratedFile, m *protogen.Message) {
	regexps := getallregs(m)
	if len(regexps) > 0 {
		for name := range regexps {
			g.P("var ", name, " *", regexpPackage.Ident("Regexp"))
		}
		g.P("func init(){")
		for name, regexpcontent := range regexps {
			_ = regexp.MustCompile(regexpcontent)
			g.P(name, " = ", regexpPackage.Ident("MustCompile"), "(", strconv.Quote(regexpcontent), ")")
		}
		g.P("}")
	}
}
func getallregs(m *protogen.Message) map[string]string {
	allregexps := make(map[string]string)
	for _, field := range m.Fields {
		fop := field.Desc.Options()
		if proto.HasExtension(fop, pbex.E_StringBytesRegMatch) {
			if regexps := proto.GetExtension(fop, pbex.E_StringBytesRegMatch).([]string); len(regexps) != 0 {
				for i, regexpcontent := range regexps {
					allregexps["_"+m.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)] = regexpcontent
				}
			}
		}
		if proto.HasExtension(fop, pbex.E_StringBytesRegNotMatch) {
			if regexps := proto.GetExtension(fop, pbex.E_StringBytesRegNotMatch).([]string); len(regexps) != 0 {
				for i, regexpcontent := range regexps {
					allregexps["_"+m.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)] = regexpcontent
				}
			}
		}
		if proto.HasExtension(fop, pbex.E_MapKeyStringRegMatch) {
			if regexps := proto.GetExtension(fop, pbex.E_MapKeyStringRegMatch).([]string); len(regexps) != 0 {
				for i, regexpcontent := range regexps {
					allregexps["_"+m.GoIdent.GoName+field.GoName+"MapKeyRegexp"+strconv.Itoa(i)] = regexpcontent
				}
			}
		}
		if proto.HasExtension(fop, pbex.E_MapKeyStringRegNotMatch) {
			if regexps := proto.GetExtension(fop, pbex.E_MapKeyStringRegNotMatch).([]string); len(regexps) != 0 {
				for i, regexpcontent := range regexps {
					allregexps["_"+m.GoIdent.GoName+field.GoName+"MapKeyRegexp"+strconv.Itoa(i)] = regexpcontent
				}
			}
		}
		if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegMatch) {
			if regexps := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegMatch).([]string); len(regexps) != 0 {
				for i, regexpcontent := range regexps {
					allregexps["_"+m.GoIdent.GoName+field.GoName+"MapValueRegexp"+strconv.Itoa(i)] = regexpcontent
				}
			}
		}
		if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegNotMatch) {
			if regexps := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegNotMatch).([]string); len(regexps) != 0 {
				for i, regexpcontent := range regexps {
					allregexps["_"+m.GoIdent.GoName+field.GoName+"MapValueRegexp"+strconv.Itoa(i)] = regexpcontent
				}
			}
		}
	}
	return allregexps
}
func genMessage(g *protogen.GeneratedFile, m *protogen.Message) {
	if pbex.NeedValidate(m) {
		geninit(g, m)
		g.P("//return empty means pass")
		g.P("func (m*", m.GoIdent.GoName, ")Validate() (errstr string){")
		for _, field := range m.Fields {
			fop := field.Desc.Options().(*descriptorpb.FieldOptions)
			if field.Desc.IsMap() || field.Desc.IsList() {
				elementnumcheck(field, fop, g)
			}
			switch field.Desc.Kind() {
			case protoreflect.BoolKind:
				//bool or []bool
				boolcheck(field, fop, g)
			case protoreflect.EnumKind:
				//enum or []enum
				enumcheck(field, fop, g)
			case protoreflect.Int32Kind:
				fallthrough
			case protoreflect.Sint32Kind:
				fallthrough
			case protoreflect.Sfixed32Kind:
				fallthrough
				//int32 or []int32
			case protoreflect.Int64Kind:
				fallthrough
			case protoreflect.Sint64Kind:
				fallthrough
			case protoreflect.Sfixed64Kind:
				//int64 or []int64
				intcheck(field, fop, g)
			case protoreflect.Uint32Kind:
				fallthrough
			case protoreflect.Fixed32Kind:
				fallthrough
				//uint32 or []uint32
			case protoreflect.Uint64Kind:
				fallthrough
			case protoreflect.Fixed64Kind:
				//uint64 or []uint64
				uintcheck(field, fop, g)
			case protoreflect.FloatKind:
				//float32 or []float32
				fallthrough
			case protoreflect.DoubleKind:
				//float64 or []float64
				floatcheck(field, fop, g)
			case protoreflect.BytesKind:
				//[]bytes or [][]bytes
				fallthrough
			case protoreflect.StringKind:
				//string or []string
				strcheck(field, fop, g)
			case protoreflect.MessageKind:
				//message or []message or map
				if field.Desc.IsMap() {
					//map
					mapcheck(field, fop, g)
				} else {
					//message or []message
					messagecheck(field, fop, g)
				}
			}
		}
		g.P("return \"\"")
		g.P("}")
	}
	for _, mm := range m.Messages {
		if !mm.Desc.IsMapEntry() {
			genMessage(g, mm)
		}
	}
}
func elementnumcheck(field *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenEq) {
		leneq := proto.GetExtension(fop, pbex.E_MapRepeatedLenEq).(uint64)
		g.P("if len(m.Get", field.GoName, "())!=", leneq, "{")
		g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check len eq failed\"")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenNotEq) {
		lennoteq := proto.GetExtension(fop, pbex.E_MapRepeatedLenNotEq).(uint64)
		g.P("if len(m.Get", field.GoName, "())==", lennoteq, "{")
		g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check len not eq failed\"")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenGt) {
		lengt := proto.GetExtension(fop, pbex.E_MapRepeatedLenGt).(uint64)
		g.P("if len(m.Get", field.GoName, "())<=", lengt, "{")
		g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check len gt failed\"")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenGte) {
		lengte := proto.GetExtension(fop, pbex.E_MapRepeatedLenGte).(uint64)
		g.P("if len(m.Get", field.GoName, "())<", lengte, "{")
		g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check len gte failed\"")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenLt) {
		lenlt := proto.GetExtension(fop, pbex.E_MapRepeatedLenLt).(uint64)
		g.P("if len(m.Get", field.GoName, "())>=", lenlt, "{")
		g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check len lt failed\"")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenLte) {
		lenlte := proto.GetExtension(fop, pbex.E_MapRepeatedLenLte).(uint64)
		g.P("if len(m.Get", field.GoName, "())>", lenlte, "{")
		g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check len lte failed\"")
		g.P("}")
	}
}
func boolcheck(field *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_BoolEq) {
		booleq := proto.GetExtension(fop, pbex.E_BoolEq).(bool)
		if field.Desc.IsList() {
			g.P("for _,v:= range m.Get", field.GoName, "(){")
			g.P("if v!=", booleq, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value bool eq failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()!=", booleq, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value bool eq failed\"")
			g.P("}")
		}
	}
}
func enumcheck(field *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if field.Desc.IsList() {
		g.P("for _,v:=range m.Get", field.GoName, "(){")
		g.P("if _,ok:=", g.QualifiedGoIdent(field.Enum.GoIdent), "_name[int32(v)];!ok{")
		g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum exist failed\"")
		g.P("}")
		g.P("}")
	} else {
		g.P("if _,ok:=", g.QualifiedGoIdent(field.Enum.GoIdent), "_name[int32(m.Get", field.GoName, "())];!ok{")
		g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum exist failed\"")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_EnumIn) {
		in := proto.GetExtension(fop, pbex.E_EnumIn).([]int64)
		if field.Desc.IsList() {
			g.P("for _,v:= range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range in {
				all = append(all, "int64(v)!="+strconv.FormatInt(v, 10))
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range in {
				all = append(all, "int64(m.Get"+field.GoName+"())!="+strconv.FormatInt(v, 10))
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_EnumNotIn) {
		notin := proto.GetExtension(fop, pbex.E_EnumNotIn).([]int64)
		if field.Desc.IsList() {
			g.P("for _,v:= range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range notin {
				all = append(all, "int64(v)=="+strconv.FormatInt(v, 10))
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum not in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range notin {
				all = append(all, "int64(m.Get"+field.GoName+"())=="+strconv.FormatInt(v, 10))
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum not in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_EnumGt) {
		gt := proto.GetExtension(fop, pbex.E_EnumGt).(int64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if int64(v)<=", gt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum gt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if int64(m.Get", field.GoName, "())<=", gt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum gt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_EnumGte) {
		gte := proto.GetExtension(fop, pbex.E_EnumGte).(int64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if int64(v)<", gte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum gte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if int64(m.Get", field.GoName, "())<", gte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum gte failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_EnumLt) {
		lt := proto.GetExtension(fop, pbex.E_EnumLt).(int64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if int64(v)>=", lt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum lt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if int64(m.Get", field.GoName, "())>=", lt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum lt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_EnumLte) {
		lte := proto.GetExtension(fop, pbex.E_EnumLte).(int64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if int64(v)>", lte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum lte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if int64(m.Get", field.GoName, "())>", lte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value enum lte failed\"")
			g.P("}")
		}
	}
}
func intcheck(field *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_IntIn) {
		in := proto.GetExtension(fop, pbex.E_IntIn).([]int64)
		if field.Desc.IsList() {
			g.P("for _,v:= range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range in {
				all = append(all, "v!="+strconv.FormatInt(v, 10))
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range in {
				all = append(all, "m.Get"+field.GoName+"()!="+strconv.FormatInt(v, 10))
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntNotIn) {
		notin := proto.GetExtension(fop, pbex.E_IntNotIn).([]int64)
		if field.Desc.IsList() {
			g.P("for _,v:= range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range notin {
				all = append(all, "v=="+strconv.FormatInt(v, 10))
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int not in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range notin {
				all = append(all, "m.Get"+field.GoName+"()=="+strconv.FormatInt(v, 10))
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int not in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntGt) {
		gt := proto.GetExtension(fop, pbex.E_IntGt).(int64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v<=", gt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int gt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()<=", gt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int gt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntGte) {
		gte := proto.GetExtension(fop, pbex.E_IntGte).(int64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v<", gte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int gte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()<", gte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int gte failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntLt) {
		lt := proto.GetExtension(fop, pbex.E_IntLt).(int64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v>=", lt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int lt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()>=", lt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int lt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntLte) {
		lte := proto.GetExtension(fop, pbex.E_IntLte).(int64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v>", lte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int lte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()>", lte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value int lte failed\"")
			g.P("}")
		}
	}
}
func uintcheck(field *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_UintIn) {
		in := proto.GetExtension(fop, pbex.E_UintIn).([]uint64)
		if field.Desc.IsList() {
			g.P("for _,v:= range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range in {
				all = append(all, "v!="+strconv.FormatUint(v, 10))
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range in {
				all = append(all, "m.Get"+field.GoName+"()!="+strconv.FormatUint(v, 10))
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintNotIn) {
		notin := proto.GetExtension(fop, pbex.E_UintNotIn).([]uint64)
		if field.Desc.IsList() {
			g.P("for _,v:= range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range notin {
				all = append(all, "v=="+strconv.FormatUint(v, 10))
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint not in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range notin {
				all = append(all, "m.Get"+field.GoName+"()=="+strconv.FormatUint(v, 10))
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint not in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintGt) {
		gt := proto.GetExtension(fop, pbex.E_UintGt).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v<=", gt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint gt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()<=", gt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint gt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintGte) {
		gte := proto.GetExtension(fop, pbex.E_UintGte).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v<", gte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint gte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()<", gte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint gte failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintLt) {
		lt := proto.GetExtension(fop, pbex.E_UintLt).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v>=", lt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint lt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()>=", lt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint lt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintLte) {
		lte := proto.GetExtension(fop, pbex.E_UintLte).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v>", lte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint lte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()>", lte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value uint lte failed\"")
			g.P("}")
		}
	}
}
func floatcheck(field *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_FloatIn) {
		in := proto.GetExtension(fop, pbex.E_FloatIn).([]float64)
		if field.Desc.IsList() {
			g.P("for _,v:= range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range in {
				all = append(all, "v!="+strconv.FormatFloat(v, 'f', -1, 64))
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range in {
				all = append(all, "m.Get"+field.GoName+"()!="+strconv.FormatFloat(v, 'f', -1, 64))
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatNotIn) {
		notin := proto.GetExtension(fop, pbex.E_FloatNotIn).([]float64)
		if field.Desc.IsList() {
			g.P("for _,v:= range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range notin {
				all = append(all, "v=="+strconv.FormatFloat(v, 'f', -1, 64))
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float not in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range notin {
				all = append(all, "m.Get"+field.GoName+"()=="+strconv.FormatFloat(v, 'f', -1, 64))
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float not in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatGt) {
		gt := proto.GetExtension(fop, pbex.E_FloatGt).(float64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v<=", gt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float gt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()<=", gt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float gt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatGte) {
		gte := proto.GetExtension(fop, pbex.E_FloatGte).(float64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v<", gte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float gte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()<", gte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float gte failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatLt) {
		lt := proto.GetExtension(fop, pbex.E_FloatLt).(float64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v>=", lt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float lt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()>=", lt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float lt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatLte) {
		lte := proto.GetExtension(fop, pbex.E_FloatLte).(float64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if v>", lte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float lte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()>", lte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value float lte failed\"")
			g.P("}")
		}
	}
}
func strcheck(field *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_StringBytesLenEq) {
		leneq := proto.GetExtension(fop, pbex.E_StringBytesLenEq).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if len(v)!=", leneq, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len eq failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(m.Get", field.GoName, "())!=", leneq, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len eq failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenNotEq) {
		lennoteq := proto.GetExtension(fop, pbex.E_StringBytesLenNotEq).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if len(v)==", lennoteq, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len not eq failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(m.Get", field.GoName, "())==", lennoteq, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len not eq failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenGt) {
		lengt := proto.GetExtension(fop, pbex.E_StringBytesLenGt).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if len(v)<=", lengt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len gt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(m.Get", field.GoName, "())<=", lengt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len gt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenGte) {
		lengte := proto.GetExtension(fop, pbex.E_StringBytesLenGte).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if len(v)<", lengte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len gte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(m.Get", field.GoName, "())<", lengte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len gte failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenLt) {
		lenlt := proto.GetExtension(fop, pbex.E_StringBytesLenLt).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if len(v)>=", lenlt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len lt failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(m.Get", field.GoName, "())>=", lenlt, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len lt failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenLte) {
		lenlte := proto.GetExtension(fop, pbex.E_StringBytesLenLte).(uint64)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			g.P("if len(v)>", lenlte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len lte failed\"")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(m.Get", field.GoName, "())>", lenlte, "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str len lte failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesIn) {
		in := proto.GetExtension(fop, pbex.E_StringBytesIn).([]string)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range in {
				if field.Desc.Kind() == protoreflect.BytesKind {
					all = append(all, g.QualifiedGoIdent(commonPackage.Ident("Byte2str"))+"(v)!=", strconv.Quote(v))
				} else {
					all = append(all, "v!="+strconv.Quote(v))
				}
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range in {
				if field.Desc.Kind() == protoreflect.BytesKind {
					all = append(all, g.QualifiedGoIdent(commonPackage.Ident("Byte2str"))+"(m.Get"+field.GoName+"())!="+strconv.Quote(v))
				} else {
					all = append(all, "m.Get"+field.GoName+"()!="+strconv.Quote(v))
				}
			}
			g.P("if ", strings.Join(all, "&&"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesNotIn) {
		notin := proto.GetExtension(fop, pbex.E_StringBytesNotIn).([]string)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for _, v := range notin {
				if field.Desc.Kind() == protoreflect.BytesKind {
					all = append(all, g.QualifiedGoIdent(commonPackage.Ident("Byte2str"))+"(v)==", strconv.Quote(v))
				} else {
					all = append(all, "v=="+strconv.Quote(v))
				}
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str not in failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for _, v := range notin {
				if field.Desc.Kind() == protoreflect.BytesKind {
					all = append(all, g.QualifiedGoIdent(commonPackage.Ident("Byte2str"))+"(m.Get"+field.GoName+"())=="+strconv.Quote(v))
				} else {
					all = append(all, "m.Get"+field.GoName+"()=="+strconv.Quote(v))
				}
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str not in failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesRegMatch) {
		match := proto.GetExtension(fop, pbex.E_StringBytesRegMatch).([]string)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for i := range match {
				if field.Desc.Kind() == protoreflect.BytesKind {
					all = append(all, "!_"+field.Parent.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)+".Match(v)")
				} else {
					all = append(all, "!_"+field.Parent.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)+".MatchString(v)")
				}
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str match failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for i := range match {
				if field.Desc.Kind() == protoreflect.BytesKind {
					all = append(all, "!_"+field.Parent.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)+".Match(m.Get"+field.GoName+"())")
				} else {
					all = append(all, "!_"+field.Parent.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)+".MatchString(m.Get"+field.GoName+"())")
				}
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str match failed\"")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesRegNotMatch) {
		notmatch := proto.GetExtension(fop, pbex.E_StringBytesRegNotMatch).([]string)
		if field.Desc.IsList() {
			g.P("for _,v:=range m.Get", field.GoName, "(){")
			all := make([]string, 0, 10)
			for i := range notmatch {
				if field.Desc.Kind() == protoreflect.BytesKind {
					all = append(all, "_"+field.Parent.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)+".Match(v)")
				} else {
					all = append(all, "_"+field.Parent.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)+".MatchString(v)")
				}
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str not match failed\"")
			g.P("}")
			g.P("}")
		} else {
			all := make([]string, 0, 10)
			for i := range notmatch {
				if field.Desc.Kind() == protoreflect.BytesKind {
					all = append(all, "_"+field.Parent.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)+".Match(m.Get"+field.GoName+"())")
				} else {
					all = append(all, "_"+field.Parent.GoIdent.GoName+field.GoName+"Regexp"+strconv.Itoa(i)+".MatchString(m.Get"+field.GoName+"())")
				}
			}
			g.P("if ", strings.Join(all, "||"), "{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value str not match failed\"")
			g.P("}")
		}
	}
}
func messagecheck(field *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	var notnil bool
	var needcheck bool
	if proto.HasExtension(fop, pbex.E_MessageNotNil) {
		notnil = proto.GetExtension(fop, pbex.E_MessageNotNil).(bool)
	}
	needcheck = pbex.NeedValidate(field.Message)
	if !notnil && !needcheck {
		return
	}
	if field.Desc.IsList() {
		g.P("for _,v:=range m.Get", field.GoName, "(){")
		g.P("if v==nil{")
		if notnil {
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value object not nil failed\"")
		} else {
			g.P("continue")
		}
		g.P("}")
		if needcheck {
			g.P("if errstr = v.Validate(); errstr !=\"\"{")
			g.P("return")
			g.P("}")
		}
		g.P("}")
	} else {
		if needcheck && notnil {
			g.P("if m.Get", field.GoName, "() == nil {")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value object not nil failed\"")
			g.P("}else if errstr = m.Get", field.GoName, "().Validate();errstr!=\"\"{")
			g.P("return")
			g.P("}")
		} else if needcheck {
			g.P("if m.Get", field.GoName, "()!=nil{")
			g.P("if errstr = m.Get", field.GoName, "().Validate();errstr!=\"\"{")
			g.P("return")
			g.P("}")
			g.P("}")
		} else {
			g.P("if m.Get", field.GoName, "()==nil{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check value object not nil failed\"")
			g.P("}")
		}
	}
}
func mapcheck(field *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	key := field.Message.Fields[0]
	val := field.Message.Fields[1]
	keycheck := false
	valuecheck := false
	isbyteslice := false
	switch key.Desc.Kind() {
	case protoreflect.Int32Kind:
		fallthrough
	case protoreflect.Sint32Kind:
		fallthrough
	case protoreflect.Sfixed32Kind:
		fallthrough
	case protoreflect.Int64Kind:
		fallthrough
	case protoreflect.Sint64Kind:
		fallthrough
	case protoreflect.Sfixed64Kind:
		if proto.HasExtension(fop, pbex.E_MapKeyIntIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntNotIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntGt) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntGte) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntLt) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntLte) {
			keycheck = true
		}
	case protoreflect.Uint32Kind:
		fallthrough
	case protoreflect.Fixed32Kind:
		fallthrough
	case protoreflect.Uint64Kind:
		fallthrough
	case protoreflect.Fixed64Kind:
		if proto.HasExtension(fop, pbex.E_MapKeyUintIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintNotIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintGt) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintGte) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintLt) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintLte) {
			keycheck = true
		}
	case protoreflect.StringKind:
		if proto.HasExtension(fop, pbex.E_MapKeyStringIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringNotIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringRegMatch) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringRegNotMatch) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenEq) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenNotEq) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenGt) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenGte) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenLt) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenLte) {
			keycheck = true
		}
	}
	switch val.Desc.Kind() {
	case protoreflect.EnumKind:
		valuecheck = true
	case protoreflect.BoolKind:
		if proto.HasExtension(fop, pbex.E_MapValueBoolEq) {
			valuecheck = true
		}
	case protoreflect.Int32Kind:
		fallthrough
	case protoreflect.Sint32Kind:
		fallthrough
	case protoreflect.Sfixed32Kind:
		fallthrough
	case protoreflect.Int64Kind:
		fallthrough
	case protoreflect.Sint64Kind:
		fallthrough
	case protoreflect.Sfixed64Kind:
		if proto.HasExtension(fop, pbex.E_MapValueIntIn) ||
			proto.HasExtension(fop, pbex.E_MapValueIntNotIn) ||
			proto.HasExtension(fop, pbex.E_MapValueIntGt) ||
			proto.HasExtension(fop, pbex.E_MapValueIntGte) ||
			proto.HasExtension(fop, pbex.E_MapValueIntLt) ||
			proto.HasExtension(fop, pbex.E_MapValueIntLte) {
			valuecheck = true
		}
	case protoreflect.Uint32Kind:
		fallthrough
	case protoreflect.Fixed32Kind:
		fallthrough
	case protoreflect.Uint64Kind:
		fallthrough
	case protoreflect.Fixed64Kind:
		if proto.HasExtension(fop, pbex.E_MapValueUintIn) ||
			proto.HasExtension(fop, pbex.E_MapValueUintNotIn) ||
			proto.HasExtension(fop, pbex.E_MapValueUintGt) ||
			proto.HasExtension(fop, pbex.E_MapValueUintGte) ||
			proto.HasExtension(fop, pbex.E_MapValueUintLt) ||
			proto.HasExtension(fop, pbex.E_MapValueUintLte) {
			valuecheck = true
		}
	case protoreflect.FloatKind:
		fallthrough
	case protoreflect.DoubleKind:
		if proto.HasExtension(fop, pbex.E_MapValueFloatIn) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatNotIn) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatGt) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatGte) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatLt) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatLte) {
			valuecheck = true
		}
	case protoreflect.BytesKind:
		fallthrough
	case protoreflect.StringKind:
		if proto.HasExtension(fop, pbex.E_MapValueStringBytesIn) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesNotIn) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesRegMatch) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesRegNotMatch) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenEq) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenNotEq) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGt) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGte) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLt) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLte) {
			valuecheck = true
		}
	case protoreflect.MessageKind:
		if proto.HasExtension(fop, pbex.E_MapValueMessageNotNil) || pbex.NeedValidate(val.Message) {
			valuecheck = true
		}
	}
	if keycheck && valuecheck {
		g.P("for k,v :=range m.Get", field.GoName, "(){")
	} else if keycheck {
		g.P("for k :=range m.Get", field.GoName, "(){")
	} else if valuecheck {
		g.P("for _,v :=range m.Get", field.GoName, "(){")
	} else {
		return
	}
	if keycheck {
		switch key.Desc.Kind() {
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Sfixed32Kind:
			fallthrough
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Sfixed64Kind:
			if proto.HasExtension(fop, pbex.E_MapKeyIntIn) {
				keyin := proto.GetExtension(fop, pbex.E_MapKeyIntIn).([]int64)
				all := make([]string, 0, 10)
				for _, v := range keyin {
					all = append(all, "k!="+strconv.FormatInt(v, 10))
				}
				g.P("if ", strings.Join(all, "&&"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key int in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntNotIn) {
				keynotin := proto.GetExtension(fop, pbex.E_MapKeyIntNotIn).([]int64)
				all := make([]string, 0, 10)
				for _, v := range keynotin {
					all = append(all, "k=="+strconv.FormatInt(v, 10))
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key int not in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntGt) {
				keygt := proto.GetExtension(fop, pbex.E_MapKeyIntGt).(int64)
				g.P("if k<=", keygt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key int gt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntGte) {
				keygte := proto.GetExtension(fop, pbex.E_MapKeyIntGte).(int64)
				g.P("if k<", keygte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key int gte failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntLt) {
				keylt := proto.GetExtension(fop, pbex.E_MapKeyIntLt).(int64)
				g.P("if k>=", keylt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key int lt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntLte) {
				keylte := proto.GetExtension(fop, pbex.E_MapKeyIntLte).(int64)
				g.P("if k>", keylte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key int lte failed\"")
				g.P("}")
			}
		case protoreflect.Uint32Kind:
			fallthrough
		case protoreflect.Fixed32Kind:
			fallthrough
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Fixed64Kind:
			if proto.HasExtension(fop, pbex.E_MapKeyUintIn) {
				keyin := proto.GetExtension(fop, pbex.E_MapKeyUintIn).([]uint64)
				all := make([]string, 0, 10)
				for _, v := range keyin {
					all = append(all, "k!="+strconv.FormatUint(v, 10))
				}
				g.P("if ", strings.Join(all, "&&"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key uint in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintNotIn) {
				keynotin := proto.GetExtension(fop, pbex.E_MapKeyUintNotIn).([]uint64)
				all := make([]string, 0, 10)
				for _, v := range keynotin {
					all = append(all, "k=="+strconv.FormatUint(v, 10))
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key uint not in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintGt) {
				keygt := proto.GetExtension(fop, pbex.E_MapKeyUintGt).(uint64)
				g.P("if k<=", keygt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key uint gt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintGte) {
				keygte := proto.GetExtension(fop, pbex.E_MapKeyUintGte).(uint64)
				g.P("if k<", keygte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key uint gte failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintLt) {
				keylt := proto.GetExtension(fop, pbex.E_MapKeyUintLt).(uint64)
				g.P("if k>=", keylt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key uint lt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintLte) {
				keylte := proto.GetExtension(fop, pbex.E_MapKeyUintLte).(uint64)
				g.P("if k>", keylte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key uint lte failed\"")
				g.P("}")
			}
		case protoreflect.StringKind:
			if proto.HasExtension(fop, pbex.E_MapKeyStringIn) {
				keyin := proto.GetExtension(fop, pbex.E_MapKeyStringIn).([]string)
				all := make([]string, 0, 10)
				for _, v := range keyin {
					all = append(all, "k!="+strconv.Quote(v))
				}
				g.P("if ", strings.Join(all, "&&"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringNotIn) {
				keynotin := proto.GetExtension(fop, pbex.E_MapKeyStringNotIn).([]string)
				all := make([]string, 0, 10)
				for _, v := range keynotin {
					all = append(all, "k=="+strconv.Quote(v))
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str not in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringRegMatch) {
				keymatch := proto.GetExtension(fop, pbex.E_MapKeyStringRegMatch).([]string)
				all := make([]string, 0, 10)
				for i := range keymatch {
					all = append(all, "!_"+field.Parent.GoIdent.GoName+field.GoName+"MapKeyRegexp"+strconv.Itoa(i)+".MatchString(k)")
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str match failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringRegNotMatch) {
				keynotmatch := proto.GetExtension(fop, pbex.E_MapKeyStringRegNotMatch).([]string)
				all := make([]string, 0, 10)
				for i := range keynotmatch {
					all = append(all, "_"+field.Parent.GoIdent.GoName+field.GoName+"MapKeyRegexp"+strconv.Itoa(i)+".MatchString(k)")
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str not match failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenEq) {
				keyleneq := proto.GetExtension(fop, pbex.E_MapKeyStringLenEq).(uint64)
				g.P("if len(k)!=", keyleneq, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str len eq failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenNotEq) {
				keylennoteq := proto.GetExtension(fop, pbex.E_MapKeyStringLenNotEq).(uint64)
				g.P("if len(k)==", keylennoteq, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str len not eq failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenGt) {
				keylengt := proto.GetExtension(fop, pbex.E_MapKeyStringLenGt).(uint64)
				g.P("if len(k)<=", keylengt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str len gt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenGte) {
				keylengte := proto.GetExtension(fop, pbex.E_MapKeyStringLenGte).(uint64)
				g.P("if len(k)<", keylengte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str len gte failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenLt) {
				keylenlt := proto.GetExtension(fop, pbex.E_MapKeyStringLenLt).(uint64)
				g.P("if len(k)>=", keylenlt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str len lt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenLte) {
				keylenlte := proto.GetExtension(fop, pbex.E_MapKeyStringLenLte).(uint64)
				g.P("if len(k)>", keylenlte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map key str len lte failed\"")
				g.P("}")
			}
		}
	}
	if valuecheck {
		switch val.Desc.Kind() {
		case protoreflect.EnumKind:
			g.P("if _,ok:=", g.QualifiedGoIdent(val.Enum.GoIdent), "_name[int32(v)];!ok{")
			g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value enum exist failed\"")
			g.P("}")
			if proto.HasExtension(fop, pbex.E_MapValueEnumIn) {
				valin := proto.GetExtension(fop, pbex.E_MapValueEnumIn).([]int64)
				all := make([]string, 0, 10)
				for _, v := range valin {
					all = append(all, "int64(v)!="+strconv.FormatInt(v, 10))
				}
				g.P("if ", strings.Join(all, "&&"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value enum in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueEnumNotIn) {
				valnotin := proto.GetExtension(fop, pbex.E_MapValueEnumNotIn).([]int64)
				all := make([]string, 0, 10)
				for _, v := range valnotin {
					all = append(all, "int64(v)=="+strconv.FormatInt(v, 10))
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value enum not in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueEnumGt) {
				valgt := proto.GetExtension(fop, pbex.E_MapValueEnumGt).(int64)
				g.P("if int64(v)<=", valgt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value enum gt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueEnumGte) {
				valgte := proto.GetExtension(fop, pbex.E_MapValueEnumGte).(int64)
				g.P("if int64(v)<", valgte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value enum gte failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueEnumLt) {
				vallt := proto.GetExtension(fop, pbex.E_MapValueEnumLt).(int64)
				g.P("if int64(v)>=", vallt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value enum lt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueEnumLte) {
				vallte := proto.GetExtension(fop, pbex.E_MapValueEnumLte).(int64)
				g.P("if int64(v)>", vallte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value enum lte failed\"")
				g.P("}")
			}
		case protoreflect.BoolKind:
			if proto.HasExtension(fop, pbex.E_MapValueBoolEq) {
				valeq := proto.GetExtension(fop, pbex.E_MapValueBoolEq).(bool)
				g.P("if v!=", valeq, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value bool eq failed\"")
				g.P("}")
			}
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Sfixed32Kind:
			fallthrough
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Sfixed64Kind:
			if proto.HasExtension(fop, pbex.E_MapValueIntIn) {
				valin := proto.GetExtension(fop, pbex.E_MapValueIntIn).([]int64)
				all := make([]string, 0, 10)
				for _, v := range valin {
					all = append(all, "v!="+strconv.FormatInt(v, 10))
				}
				g.P("if ", strings.Join(all, "&&"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value int in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntNotIn) {
				valnotin := proto.GetExtension(fop, pbex.E_MapValueIntNotIn).([]int64)
				all := make([]string, 0, 10)
				for _, v := range valnotin {
					all = append(all, "v=="+strconv.FormatInt(v, 10))
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value int not in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntGt) {
				valgt := proto.GetExtension(fop, pbex.E_MapValueIntGt).(int64)
				g.P("if v<=", valgt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value int gt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntGte) {
				valgte := proto.GetExtension(fop, pbex.E_MapValueIntGte).(int64)
				g.P("if v<", valgte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value int gte failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntLt) {
				vallt := proto.GetExtension(fop, pbex.E_MapValueIntLt).(int64)
				g.P("if v>=", vallt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value int lt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntLte) {
				vallte := proto.GetExtension(fop, pbex.E_MapValueIntLte).(int64)
				g.P("if v>", vallte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value int lte failed\"")
				g.P("}")
			}
		case protoreflect.Uint32Kind:
			fallthrough
		case protoreflect.Fixed32Kind:
			fallthrough
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Fixed64Kind:
			if proto.HasExtension(fop, pbex.E_MapValueUintIn) {
				valin := proto.GetExtension(fop, pbex.E_MapValueUintIn).([]uint64)
				all := make([]string, 0, 10)
				for _, v := range valin {
					all = append(all, "v!="+strconv.FormatUint(v, 10))
				}
				g.P("if ", strings.Join(all, "&&"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value uint in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintNotIn) {
				valnotin := proto.GetExtension(fop, pbex.E_MapValueUintNotIn).([]uint64)
				all := make([]string, 0, 10)
				for _, v := range valnotin {
					all = append(all, "v=="+strconv.FormatUint(v, 10))
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value uint not in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintGt) {
				valgt := proto.GetExtension(fop, pbex.E_MapValueUintGt).(uint64)
				g.P("if v<=", valgt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value uint gt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintGte) {
				valgte := proto.GetExtension(fop, pbex.E_MapValueUintGte).(uint64)
				g.P("if v<", valgte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value uint gte failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintLt) {
				vallt := proto.GetExtension(fop, pbex.E_MapValueUintLt).(uint64)
				g.P("if v>=", vallt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value uint lt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintLte) {
				vallte := proto.GetExtension(fop, pbex.E_MapValueUintLte).(uint64)
				g.P("if v>", vallte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value uint lte failed\"")
				g.P("}")
			}
		case protoreflect.FloatKind:
			fallthrough
		case protoreflect.DoubleKind:
			if proto.HasExtension(fop, pbex.E_MapValueFloatIn) {
				valin := proto.GetExtension(fop, pbex.E_MapValueFloatIn).([]float64)
				all := make([]string, 0, 10)
				for _, v := range valin {
					all = append(all, "v!="+strconv.FormatFloat(v, 'f', -1, 64))
				}
				g.P("if ", strings.Join(all, "&&"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value float in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatNotIn) {
				valnotin := proto.GetExtension(fop, pbex.E_MapValueFloatNotIn).([]float64)
				all := make([]string, 0, 10)
				for _, v := range valnotin {
					all = append(all, "v=="+strconv.FormatFloat(v, 'f', -1, 64))
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value float not in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatGt) {
				valgt := proto.GetExtension(fop, pbex.E_MapValueFloatGt).(float64)
				g.P("if v<=", valgt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value float gt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatGte) {
				valgte := proto.GetExtension(fop, pbex.E_MapValueFloatGte).(float64)
				g.P("if v<", valgte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value float gte failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatLt) {
				vallt := proto.GetExtension(fop, pbex.E_MapValueFloatLt).(float64)
				g.P("if v>=", vallt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value float lt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatLte) {
				vallte := proto.GetExtension(fop, pbex.E_MapValueFloatLte).(float64)
				g.P("if v>", vallte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value float lte failed\"")
				g.P("}")
			}
		case protoreflect.BytesKind:
			isbyteslice = true
			fallthrough
		case protoreflect.StringKind:
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesIn) {
				valin := proto.GetExtension(fop, pbex.E_MapValueStringBytesIn).([]string)
				all := make([]string, 0, 10)
				for _, v := range valin {
					if isbyteslice {
						all = append(all, g.QualifiedGoIdent(commonPackage.Ident("Byte2str"))+"(v)!="+strconv.Quote(v))
					} else {
						all = append(all, "v!="+strconv.Quote(v))
					}
				}
				g.P("if ", strings.Join(all, "&&"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesNotIn) {
				valnotin := proto.GetExtension(fop, pbex.E_MapValueStringBytesNotIn).([]string)
				all := make([]string, 0, 10)
				for _, v := range valnotin {
					if isbyteslice {
						all = append(all, g.QualifiedGoIdent(commonPackage.Ident("Byte2str"))+"(v)=="+strconv.Quote(v))
					} else {
						all = append(all, "v=="+strconv.Quote(v))
					}
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str not in failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegMatch) {
				valmatch := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegMatch).([]string)
				all := make([]string, 0, 10)
				for i := range valmatch {
					if isbyteslice {
						all = append(all, "!_"+field.Parent.GoIdent.GoName+field.GoName+"MapValueRegexp"+strconv.Itoa(i)+".Match(v)")
					} else {
						all = append(all, "!_"+field.Parent.GoIdent.GoName+field.GoName+"MapValueRegexp"+strconv.Itoa(i)+".MatchString(v)")
					}
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str match failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegNotMatch) {
				valnotmatch := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegNotMatch).([]string)
				all := make([]string, 0, 10)
				for i := range valnotmatch {
					if isbyteslice {
						all = append(all, "_"+field.Parent.GoIdent.GoName+field.GoName+"MapValueRegexp"+strconv.Itoa(i)+".Match(v)")
					} else {
						all = append(all, "_"+field.Parent.GoIdent.GoName+field.GoName+"MapValueRegexp"+strconv.Itoa(i)+".MatchString(v)")
					}
				}
				g.P("if ", strings.Join(all, "||"), "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str not match failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenEq) {
				valleneq := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenEq).(uint64)
				g.P("if len(v)!=", valleneq, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str len eq failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenNotEq) {
				vallennoteq := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenNotEq).(uint64)
				g.P("if len(v)==", vallennoteq, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str len not eq failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGt) {
				vallengt := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenGt).(uint64)
				g.P("if len(v)<=", vallengt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str len gt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGte) {
				vallengte := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenGte).(uint64)
				g.P("if len(v)<", vallengte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str len gte failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLt) {
				vallenlt := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenLt).(uint64)
				g.P("if len(v)>=", vallenlt, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str len lt failed\"")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLte) {
				vallenlte := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenLte).(uint64)
				g.P("if len(v)>", vallenlte, "{")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value str len lte failed\"")
				g.P("}")
			}
		case protoreflect.MessageKind:
			var notnil bool
			var needcheck bool
			if proto.HasExtension(fop, pbex.E_MapValueMessageNotNil) {
				notnil = proto.GetExtension(fop, pbex.E_MapValueMessageNotNil).(bool)
			}
			needcheck = pbex.NeedValidate(val.Message)
			if !notnil && !needcheck {
				break
			}
			if needcheck && notnil {
				g.P("if v == nil {")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value object not nil failed\"")
				g.P("}else if errstr=v.Validate();errstr!=\"\"{")
				g.P("return")
				g.P("}")
			} else if needcheck {
				g.P("if v !=nil{")
				g.P("if errstr = v.Validate();errstr!=\"\"{")
				g.P("return")
				g.P("}")
				g.P("}")
			} else {
				g.P("if v == nil {")
				g.P("return \"field: ", string(field.Desc.Name()), " in object: ", string(field.Parent.Desc.Name()), " check map value object not nil failed\"")
				g.P("}")
			}
		}
	}
	g.P("}")
}
