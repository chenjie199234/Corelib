package main

import (
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/chenjie199234/Corelib/internal/version"
	"github.com/chenjie199234/Corelib/pbex"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	stringsPackage   = protogen.GoImportPath("strings")
	urlPackage       = protogen.GoImportPath("net/url")
	httpPackage      = protogen.GoImportPath("net/http")
	ioPackage        = protogen.GoImportPath("io")
	contextPackage   = protogen.GoImportPath("context")
	base64Package    = protogen.GoImportPath("encoding/base64")
	stdjsonPackage   = protogen.GoImportPath("encoding/json")
	strconvPackage   = protogen.GoImportPath("strconv")
	protoPackage     = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protojsonPackage = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	webPackage       = protogen.GoImportPath("github.com/chenjie199234/Corelib/web")
	commonPackage    = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/common")
	metadataPackage  = protogen.GoImportPath("github.com/chenjie199234/Corelib/metadata")
	poolPackage      = protogen.GoImportPath("github.com/chenjie199234/Corelib/pool")
	cerrorPackage    = protogen.GoImportPath("github.com/chenjie199234/Corelib/cerror")
	logPackage       = protogen.GoImportPath("github.com/chenjie199234/Corelib/log")
)

// generateFile generates a _web.pb.go file containing web service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_web.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		genService(file, service, g)
	}
	return g
}
func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-go-web. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-go-web ", version.String(), "<br />")
	g.P("// \tprotoc            ", protocVersion, "<br />")
	g.P("// source: ", file.Desc.Path(), "<br />")
	g.P()
}

func genService(file *protogen.File, s *protogen.Service, g *protogen.GeneratedFile) {
	genPath(file, s, g)
	genClient(file, s, g)
	genServer(file, s, g)
}

func genPath(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		pathname := "_WebPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		g.P("var ", pathname, "=", strconv.Quote(pathurl))
	}
	g.P()
}

func genServer(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Server interface.
	serverName := service.GoName + "WebServer"

	g.P("type ", serverName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")), ",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*", g.QualifiedGoIdent(method.Output.GoIdent), ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	// Server handler
	for _, method := range service.Methods {
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())

		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		fname := "func _" + service.GoName + "_" + method.GoName + "_" + "WebHandler"
		p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		freturn := g.QualifiedGoIdent(webPackage.Ident("OutsideHandler"))
		g.P(fname, "(", p1, ")", freturn, "{")
		g.P("return func(ctx *", g.QualifiedGoIdent(webPackage.Ident("Context")), "){")
		g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
		if httpmetohd == http.MethodPost || httpmetohd == http.MethodPut || httpmetohd == http.MethodPatch {
			g.P("if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(ctx.GetContentType(),", strconv.Quote("application/json"), "){")
			g.P("data, e := ctx.GetBody()")
			g.P("if e!=nil{")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] get body failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
			g.P("ctx.Abort(e)")
			g.P("return")
			g.P("}")
			g.P("if len(data)>0{")
			g.P("if e := (", g.QualifiedGoIdent(protojsonPackage.Ident("UnmarshalOptions")), "{AllowPartial: true,DiscardUnknown: true}).Unmarshal(data,req);e!=nil{")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] unmarshal json body failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")
			g.P("}")
			g.P("}else if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(ctx.GetContentType(),", strconv.Quote("application/x-protobuf"), "){")
			g.P("data, e := ctx.GetBody()")
			g.P("if e!=nil{")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] get body failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
			g.P("ctx.Abort(e)")
			g.P("return")
			g.P("}")
			g.P("if len(data)>0{")
			g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(data,req);e!=nil{")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] unmarshal proto body failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")
			g.P("}")
			g.P("}else{")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] Content-Type unknown,must be application/json or application/x-protobuf\")")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")
		} else if len(method.Input.Fields) > 0 {
			g.P("if e:=ctx.ParseForm();e!=nil{")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] parse form failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")
			g.P("data:=", g.QualifiedGoIdent(poolPackage.Ident("GetPool")), "().Get(0)")
			g.P("defer ", g.QualifiedGoIdent(poolPackage.Ident("GetPool")), "().Put(&data)")
			g.P("data = append(data,'{')")
			for _, field := range method.Input.Fields {
				fname := string(field.Desc.Name())
				switch field.Desc.Kind() {
				case protoreflect.BoolKind:
					fallthrough
				case protoreflect.EnumKind:
					fallthrough
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					fallthrough
				case protoreflect.FloatKind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					fallthrough
				case protoreflect.DoubleKind:
					if field.Desc.IsList() {
						g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)!=0{")
						g.P("data = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&data,len(data)+", len(fname), "+4)")
						g.P("data = append(data,", strconv.Quote(strconv.Quote(fname)+":["), "...)")
						g.P("for _,form:=range forms{")
						g.P("data = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&data,len(data)+len(form)+1+1)//first +1 for ',' after element,second +1 for ',' after array")
						g.P("data = append(data,form...)")
						g.P("data = append(data,',')")
						g.P("}")
						g.P("data[len(data)-1] = ']'")
						g.P("data = append(data,',')")
						g.P("}")
					} else {
						g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
						g.P("data=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&data,len(data)+", len(fname), "+len(form)+4)")
						g.P("data=append(data,", strconv.Quote(strconv.Quote(fname)+":"), "...)")
						g.P("data=append(data,form...)")
						g.P("data=append(data,',')")
						g.P("}")
					}
				case protoreflect.BytesKind:
					g.P("//req.", field.GoName, "'s type in protobuf is bytes,value should be base64 encoded")
					g.P("//https://developers.google.com/protocol-buffers/docs/proto3#json")
					fallthrough
				case protoreflect.StringKind:
					if field.Desc.IsList() {
						g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)!=0{")
						g.P("data = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&data,len(data)+", len(fname), "+4)")
						g.P("data = append(data,", strconv.Quote(strconv.Quote(fname)+":["), "...)")
						g.P("for _,form:=range forms{")
						g.P("formb:=[]byte{'\"','\"'}")
						g.P("if len(form)!=0{")
						g.P("//transfer json escape")
						g.P("formb,_=", g.QualifiedGoIdent(stdjsonPackage.Ident("Marshal")), "(form)")
						g.P("}")
						g.P("data = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&data,len(data)+len(formb)+1+1)//first +1 for ',' after element,second +1 for ',' after array")
						g.P("data = append(data,formb...)")
						g.P("data = append(data,',')")
						g.P("}")
						g.P("data[len(data)-1] = ']'")
						g.P("data = append(data,',')")
						g.P("}")
					} else {
						g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
						g.P("//transfer json escape")
						g.P("formb,_:=", g.QualifiedGoIdent(stdjsonPackage.Ident("Marshal")), "(form)")
						g.P("data = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&data,len(data)+", len(fname), "+len(formb)+4)")
						g.P("data = append(data,", strconv.Quote(strconv.Quote(fname)+":"), "...)")
						g.P("data = append(data,formb...)")
						g.P("data = append(data,',')")
						g.P("}")
					}
				case protoreflect.MessageKind:
					if field.Desc.IsList() {
						g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)!=0{")
						g.P("data = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&data,len(data)+", len(fname), "+4)")
						g.P("data = append(data,", strconv.Quote(strconv.Quote(fname)+":["), "...)")
						g.P("for _,form:=range forms{")
						g.P("if len(form)==0{")
						g.P("form = \"null\"")
						g.P("}")
						g.P("data = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&data,len(data)+len(form)+1+1)//first +1 for ',' after element,second +1 for ',' after array")
						g.P("data = append(data,form...)")
						g.P("data = append(data,',')")
						g.P("}")
						g.P("data[len(data)-1] = ']'")
						g.P("data = append(data,',')")
						g.P("}")
					} else {
						g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
						g.P("data = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&data,len(data)+", len(fname), "+len(form)+4)")
						g.P("data = append(data,", strconv.Quote(strconv.Quote(fname)+":"), "...)")
						g.P("data = append(data,form...)")
						g.P("data = append(data,',')")
						g.P("}")
					}
				}
			}
			g.P("if len(data) > 1{")
			g.P("data[len(data)-1] = '}'")
			g.P("if e:=(", g.QualifiedGoIdent(protojsonPackage.Ident("UnmarshalOptions")), "{AllowPartial: true,DiscardUnknown: true}).Unmarshal(data,req);e!=nil{")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] unmarshal from body failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")
			g.P("}")
		}

		//check
		if pbex.NeedValidate(method.Input) {
			g.P("if errstr := req.Validate(); errstr != \"\"{")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] validate failed\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(\"validate\",errstr))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")
		}

		g.P("resp,e:=handler(ctx,req)")
		g.P("ee := ", g.QualifiedGoIdent(cerrorPackage.Ident("ConvertStdError")), "(e)")
		g.P("if ee!=nil{")
		g.P("ctx.Abort(ee)")
		g.P("return")
		g.P("}")
		g.P("if resp == nil{")
		g.P("resp = new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("}")
		g.P("if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(ctx.GetAcceptType(),", strconv.Quote("application/x-protobuf"), "){")
		g.P("respd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(resp)")
		g.P("ctx.Write(\"application/x-protobuf\",respd)")
		g.P("}else{")
		g.P("respd,_:=", g.QualifiedGoIdent(protojsonPackage.Ident("MarshalOptions")), "{AllowPartial: true,UseProtoNames: true, UseEnumNumbers: true, EmitUnpopulated: true}.Marshal(resp)")
		g.P("ctx.Write(\"application/json\",respd)")
		g.P("}")
		g.P("}")
		g.P("}")
	}

	//Server Register
	g.P("func Register", serverName, "(router *", g.QualifiedGoIdent(webPackage.Ident("Router")), ",svc ", serverName, ",allmids map[string]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), "){")
	g.P("//avoid lint")
	g.P("_=allmids")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		var mids []string
		if proto.HasExtension(mop, pbex.E_WebMidwares) {
			mids = proto.GetExtension(mop, pbex.E_WebMidwares).([]string)
		}
		fname := "_" + service.GoName + "_" + method.GoName + "_" + "WebHandler(svc." + method.GoName + ")"
		pathname := "_WebPath" + service.GoName + method.GoName
		if len(mids) > 0 {
			g.P("{")
			str := ""
			for _, mid := range mids {
				str += ","
				str += strconv.Quote(mid)
			}
			str = str[1:]
			g.P("requiredMids:=[]string{", str, "}")
			g.P("mids:=make([]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), ",0,", len(mids)+1, ")")
			g.P("for _,v:=range requiredMids{")
			g.P("if mid,ok:=allmids[v];ok{")
			g.P("mids = append(mids,mid)")
			g.P("}else{")
			g.P("panic(\"missing midware:\"+v)")
			g.P("}")
			g.P("}")
			g.P("mids = append(mids,", fname, ")")
			switch httpmetohd {
			case http.MethodGet:
				g.P("router.Get(", pathname, ",mids...)")
			case http.MethodDelete:
				g.P("router.Delete(", pathname, ",mids...)")
			case http.MethodPost:
				g.P("router.Post(", pathname, ",mids...)")
			case http.MethodPut:
				g.P("router.Put(", pathname, ",mids...)")
			case http.MethodPatch:
				g.P("router.Patch(", pathname, ",mids...)")
			}
			g.P("}")
		} else {
			switch httpmetohd {
			case http.MethodGet:
				g.P("router.Get(", pathname, ",", fname, ")")
			case http.MethodDelete:
				g.P("router.Delete(", pathname, ",", fname, ")")
			case http.MethodPost:
				g.P("router.Post(", pathname, ",", fname, ")")
			case http.MethodPut:
				g.P("router.Put(", pathname, ",", fname, ")")
			case http.MethodPatch:
				g.P("router.Patch(", pathname, ",", fname, ")")
			}
		}
	}
	g.P("}")
}

func genClient(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Client interface.
	clientName := service.GoName + "WebClient"
	lowclientName := strings.ToLower(clientName[:1]) + clientName[1:]

	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		p1 := g.QualifiedGoIdent(contextPackage.Ident("Context"))
		p2 := g.QualifiedGoIdent(method.Input.GoIdent)
		p3 := g.QualifiedGoIdent(httpPackage.Ident("Header"))
		r := g.QualifiedGoIdent(method.Output.GoIdent)
		g.P(method.Comments.Leading,
			method.GoName, "(", p1, ",*", p2, ",", p3, ")(*", r, ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	g.P("type ", lowclientName, " struct{")
	g.P("cc *", g.QualifiedGoIdent(webPackage.Ident("WebClient")))
	g.P("}")
	g.P("func New", clientName, "(c *", g.QualifiedGoIdent(webPackage.Ident("WebClient")), ")(", clientName, "){")
	g.P("return &", lowclientName, "{cc:c}")
	g.P("}")
	g.P()
	// Client handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		pathname := "_WebPath" + service.GoName + method.GoName
		p1 := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		p3 := "header " + g.QualifiedGoIdent(httpPackage.Ident("Header"))
		freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ",", p3, ")", freturn, "{")
		g.P("if req == nil {")
		g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
		g.P("}")

		g.P("if header == nil {")
		g.P("header = make(", g.QualifiedGoIdent(httpPackage.Ident("Header")), ")")
		g.P("}")

		if httpmetohd == http.MethodGet || httpmetohd == http.MethodDelete {
			g.P("header.Set(", strconv.Quote("Content-Type"), ",", strconv.Quote("application/x-www-form-urlencoded"), ")")
			g.P("header.Set(", strconv.Quote("Accept"), ",", strconv.Quote("application/x-protobuf"), ")")
			g.P("query :=", g.QualifiedGoIdent(poolPackage.Ident("GetPool")), "().Get(0)")
			g.P("defer ", g.QualifiedGoIdent(poolPackage.Ident("GetPool")), "().Put(&query)")
			for _, field := range method.Input.Fields {
				fname := string(field.Desc.Name())
				switch field.Desc.Kind() {
				case protoreflect.BoolKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+7)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendBool")), "(query,v)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+7)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendBool")), "(query,req.Get", field.GoName, "())")
						g.P("query=append(query,'&')")
					}
				case protoreflect.EnumKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(v),10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(req.Get", field.GoName, "()),10)")
						g.P("query=append(query,'&')")
					}
				case protoreflect.Sfixed32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Int32Kind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+12)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(v),10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+12)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(req.Get", field.GoName, "()),10)")
						g.P("query=append(query,'&')")
					}
				case protoreflect.Sfixed64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Int64Kind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,v,10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,req.Get", field.GoName, "(),10)")
						g.P("query=append(query,'&')")
					}
				case protoreflect.Fixed32Kind:
					fallthrough
				case protoreflect.Uint32Kind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,uint64(v),10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,uint64(req.Get", field.GoName, "()),10)")
						g.P("query=append(query,'&')")
					}
				case protoreflect.Fixed64Kind:
					fallthrough
				case protoreflect.Uint64Kind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,v,10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,req.Get", field.GoName, "(),10)")
						g.P("query=append(query,'&')")
					}
				case protoreflect.FloatKind:
					fallthrough
				case protoreflect.DoubleKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("//for precision match")
						g.P("tmp,_:=", g.QualifiedGoIdent(stdjsonPackage.Ident("Marshal")), "(v)")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(tmp))")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("{")
						g.P("//for precision match")
						g.P("tmp,_:=", g.QualifiedGoIdent(stdjsonPackage.Ident("Marshal")), "(req.Get", field.GoName, "())")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(tmp))")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					}
				case protoreflect.StringKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("ev := ", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(v)")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("{")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(req.Get", field.GoName, "())")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					}
				case protoreflect.BytesKind:
					g.P("//[]byte should be base64 encoded")
					g.P("//https://developers.google.com/protocol-buffers/docs/proto3#json")
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(base64Package.Ident("StdEncoding.EncodeToString")), "(v))")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("{")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(base64Package.Ident("StdEncoding.EncodeToString")), "(req.Get", field.GoName, "()))")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					}
				case protoreflect.MessageKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("ev:=\"null\"")
						g.P("if v!=nil {")
						g.P("tmp,_:=", g.QualifiedGoIdent(protojsonPackage.Ident("MarshalOptions")), "{AllowPartial: true,UseProtoNames: true, UseEnumNumbers: true}.Marshal(v)")
						g.P("ev=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(tmp))")
						g.P("}")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Desc.IsMap() {
						g.P("if len(req.Get", field.GoName, "())!=0{")
						g.P("//treat the map field in json format,protojson can't marshal map,stdjson can't encode int64/uint64 to string number")
						g.P("tmpbuf :=", g.QualifiedGoIdent(poolPackage.Ident("GetPool")), "().Get(0)")
						g.P("defer ", g.QualifiedGoIdent(poolPackage.Ident("GetPool")), "().Put(&tmpbuf)")
						g.P("tmpbuf = append(tmpbuf,'{')")
						g.P("first:=true")
						g.P("for k,v:=range req.Get", field.GoName, "(){")
						g.P("if first{")
						g.P("first=false")
						g.P("}else{")
						g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+1)")
						g.P("tmpbuf = append(tmpbuf,',')")
						g.P("}")
						switch field.Message.Fields[0].Desc.Kind() {
						case protoreflect.Int32Kind:
							fallthrough
						case protoreflect.Sint32Kind:
							fallthrough
						case protoreflect.Sfixed32Kind:
							//int32
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+12+1)//+1 for ':'")
							g.P("tmpbuf = append(tmpbuf,'\"')")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(tmpbuf,int64(k),10)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
						case protoreflect.Int64Kind:
							fallthrough
						case protoreflect.Sint64Kind:
							fallthrough
						case protoreflect.Sfixed64Kind:
							//int64
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+22+1)//+1 for ':'")
							g.P("tmpbuf = append(tmpbuf,'\"')")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(tmpbuf,k,10)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
						case protoreflect.Uint32Kind:
							fallthrough
						case protoreflect.Fixed32Kind:
							//uint32
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+11+1)//+1 for ':'")
							g.P("tmpbuf = append(tmpbuf,'\"')")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(tmpbuf,uint64(k),10)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
						case protoreflect.Uint64Kind:
							fallthrough
						case protoreflect.Fixed64Kind:
							//uint64
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+22+1)//+1 for ':'")
							g.P("tmpbuf = append(tmpbuf,'\"')")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(tmpbuf,k,10)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
						case protoreflect.StringKind:
							g.P("//transfer the json escape")
							g.P("kk,_:=", g.QualifiedGoIdent(stdjsonPackage.Ident("Marshal")), "(k)")
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+len(kk)+1)//+1 for ':'")
							g.P("tmpbuf = append(tmpbuf,kk...)")
						}
						g.P("tmpbuf = append(tmpbuf,':')")
						switch field.Message.Fields[1].Desc.Kind() {
						case protoreflect.BoolKind:
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+5)")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendBool")), "(tmpbuf,v)")
						case protoreflect.EnumKind:
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+9)")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(tmpbuf,int64(v),10)")
						case protoreflect.Int32Kind:
							fallthrough
						case protoreflect.Sint32Kind:
							fallthrough
						case protoreflect.Sfixed32Kind:
							//int32
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+10)")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(tmpbuf,int64(v),10)")
						case protoreflect.Int64Kind:
							fallthrough
						case protoreflect.Sint64Kind:
							fallthrough
						case protoreflect.Sfixed64Kind:
							//int64
							g.P("//int64 should be encode to string number to prevent overflow")
							g.P("//https://developers.google.com/protocol-buffers/docs/proto3#json")
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+22)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(tmpbuf,v,10)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
						case protoreflect.Uint32Kind:
							fallthrough
						case protoreflect.Fixed32Kind:
							//uint32
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+10)")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(tmpbuf,uint64(v),10)")
						case protoreflect.Uint64Kind:
							fallthrough
						case protoreflect.Fixed64Kind:
							//uint64
							g.P("//uint64 should be encode to string number to prevent overflow")
							g.P("//https://developers.google.com/protocol-buffers/docs/proto3#json")
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+22)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
							g.P("tmpbuf = ", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(tmpbuf,v,10)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
						case protoreflect.FloatKind:
							fallthrough
						case protoreflect.DoubleKind:
							g.P("//for precision match")
							g.P("vv,_:=", g.QualifiedGoIdent(stdjsonPackage.Ident("Marshal")), "(v)")
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+len(vv))")
							g.P("tmpbuf = append(tmpbuf,vv...)")
						case protoreflect.StringKind:
							g.P("//transfer the json escape")
							g.P("vv,_:=", g.QualifiedGoIdent(stdjsonPackage.Ident("Marshal")), "(v)")
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+len(vv))")
							g.P("tmpbuf = append(tmpbuf,vv...)")
						case protoreflect.BytesKind:
							g.P("//[]byte should be base64 encoded")
							g.P("//https://developers.google.com/protocol-buffers/docs/proto3#json")
							g.P("vv:=", g.QualifiedGoIdent(base64Package.Ident("StdEncoding.EncodeToString")), "(v)")
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+len(vv)+2)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
							g.P("tmpbuf = append(tmpbuf,vv...)")
							g.P("tmpbuf = append(tmpbuf,'\"')")
						case protoreflect.MessageKind:
							g.P("vv:=[]byte{'n','u','l','l'}")
							g.P("if v!=nil{")
							g.P("vv,_=", g.QualifiedGoIdent(protojsonPackage.Ident("MarshalOptions")), "{AllowPartial: true,UseProtoNames: true,UseEnumNumbers: true}.Marshal(v)")
							g.P("}")
							g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+len(vv))")
							g.P("tmpbuf = append(tmpbuf,vv...)")
						}
						g.P("}")
						g.P("tmpbuf = ", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&tmpbuf,len(tmpbuf)+1)")
						g.P("tmpbuf = append(tmpbuf,'}')")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(tmpbuf))")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						g.P("if req.Get", field.GoName, "()!=nil{")
						g.P("tmp,_:=", g.QualifiedGoIdent(protojsonPackage.Ident("MarshalOptions")), "{AllowPartial: true,UseProtoNames: true,UseEnumNumbers: true}.Marshal(req.Get", field.GoName, "())")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(tmp))")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					}
				}
			}
			g.P("if len(query)>0{")
			g.P("//drop last &")
			g.P("query=query[:len(query)-1]")
			g.P("}")
			g.P("querystr:=", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(query)")
			switch httpmetohd {
			case http.MethodGet:
				g.P("r,e:=c.cc.Get(ctx,", pathname, ",querystr,header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx))")
			case http.MethodDelete:
				g.P("r,e:=c.cc.Delete(ctx,", pathname, ",querystr,header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx))")
			}
		} else {
			g.P("header.Set(", strconv.Quote("Content-Type"), ",", strconv.Quote("application/x-protobuf"), ")")
			g.P("header.Set(", strconv.Quote("Accept"), ",", strconv.Quote("application/x-protobuf"), ")")
			g.P("reqd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(req)")
			switch httpmetohd {
			case http.MethodPost:
				g.P("r,e:=c.cc.Post(ctx,", pathname, ",\"\",header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx),reqd)")
			case http.MethodPut:
				g.P("r,e:=c.cc.Put(ctx,", pathname, ",\"\",header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx),reqd)")
			case http.MethodPatch:
				g.P("r,e:=c.cc.Patch(ctx,", pathname, ",\"\",header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx),reqd)")
			}
		}
		g.P("if e != nil {")
		g.P("return nil,e")
		g.P("}")
		g.P("data,e:=", g.QualifiedGoIdent(ioPackage.Ident("ReadAll")), "(r.Body)")
		g.P("r.Body.Close()")
		g.P("if e!=nil {")
		g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ConvertStdError")), "(e)")
		g.P("}")
		g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("if len(data)==0{")
		g.P("return resp,nil")
		g.P("}")
		g.P("if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(r.Header.Get(\"Content-Type\"), \"application/x-protobuf\"){")
		g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(data,resp);e!=nil{")
		g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrResp")))
		g.P("}")
		g.P("} else if e:=(", g.QualifiedGoIdent(protojsonPackage.Ident("UnmarshalOptions")), "{AllowPartial: true,DiscardUnknown: true}).Unmarshal(data,resp);e!=nil{")
		g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrResp")))
		g.P("}")
		g.P("return resp, nil")
		g.P("}")
	}
}
