package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	timePackage    = protogen.GoImportPath("time")
	stringsPackage = protogen.GoImportPath("strings")
	bytesPackage   = protogen.GoImportPath("bytes")
	strconvPackage = protogen.GoImportPath("strconv")
	httpPackage    = protogen.GoImportPath("net/http")
	fmtPackage     = protogen.GoImportPath("fmt")
	ioPackage      = protogen.GoImportPath("io")
	jsonPackage    = protogen.GoImportPath("encoding/json")
	contextPackage = protogen.GoImportPath("context")
	webPackage     = protogen.GoImportPath("github.com/chenjie199234/Corelib/web")
	commonPackage  = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/common")
	bufpoolPackage = protogen.GoImportPath("github.com/chenjie199234/Corelib/bufpool")
)

// generateFile generates a _web.pb.go file containing web service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_web.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-web. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

// generateFileContent generates the web service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}
	for _, service := range file.Services {
		genService(gen, file, g, service)
	}
}
func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		return
	}
	countUndeprecatedMethod := 0
	for _, method := range service.Methods {
		if !method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			countUndeprecatedMethod++
		}
	}
	if countUndeprecatedMethod == 0 {
		return
	}
	//Router path
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		pathname := "WebPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + service.GoName + "/" + method.GoName
		g.P("var ", pathname, "=", strconv.Quote(pathurl))
	}

	// Client interface.
	clientName := service.GoName + "WebClient"
	lowclientName := strings.ToLower(clientName[:1]) + clientName[1:]

	g.P("// ", clientName, " is the client API for ", service.GoName, " service.")

	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")),
			",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*",
			g.QualifiedGoIdent(method.Output.GoIdent), ",error)")
	}
	g.P("}")
	g.P()
	g.P("type ", lowclientName, " struct{")
	g.P("cc *", g.QualifiedGoIdent(webPackage.Ident("WebClient")))
	g.P("}")
	p1 := "globaltimeout " + g.QualifiedGoIdent(timePackage.Ident("Duration"))
	p2 := "picker " + g.QualifiedGoIdent(webPackage.Ident("PickHandler"))
	p3 := "discover " + g.QualifiedGoIdent(webPackage.Ident("DiscoveryHandler"))
	g.P("//has race,will only return the first's call's client,the config will use the first call's config")
	g.P("func New", clientName, "(", p1, ",selfgroup,selfname string,", p2, ",", p3, ")(", clientName, ",error){")
	g.P("cc,e:=", g.QualifiedGoIdent(webPackage.Ident("NewWebClient")), "(globaltimeout,selfgroup,selfname,Group,Name,picker,discover)")
	g.P("if e != nil{")
	g.P("return nil,e")
	g.P("}")
	g.P("return &", lowclientName, "{cc:cc},nil")
	g.P("}")
	g.P()
	// Client handler
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		pathname := "WebPath" + service.GoName + method.GoName
		p1 := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")", freturn, "{")
		g.P("if req == nil {")
		g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:nil\")")
		g.P("}")
		r, e := parseMethodComment(string(method.Comments.Trailing))
		if e != nil {
			panic(e)
		}
		if len(method.Input.Fields) > 0 && haschecker(method.Input) {
			checkerandheader("req.", method.Input, g, 1)
		}
		if r.method == http.MethodGet || r.method == http.MethodDelete {
			g.P("header:=make(", g.QualifiedGoIdent(httpPackage.Ident("Header")), ")")
			g.P("header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")")
			g.P("buf:=", g.QualifiedGoIdent(bufpoolPackage.Ident("GetBuffer")), "()")
			if len(method.Input.Fields) != 0 {
				for _, field := range method.Input.Fields {
					switch field.Desc.Kind() {
					case protoreflect.BoolKind:
						//bool
						fallthrough
					case protoreflect.Int32Kind:
						fallthrough
					case protoreflect.Sint32Kind:
						fallthrough
					case protoreflect.Sfixed32Kind:
						fallthrough
					case protoreflect.EnumKind:
						//int32
						fallthrough
					case protoreflect.Uint32Kind:
						fallthrough
					case protoreflect.Fixed32Kind:
						//uint32
						fallthrough
					case protoreflect.Int64Kind:
						fallthrough
					case protoreflect.Sint64Kind:
						fallthrough
					case protoreflect.Sfixed64Kind:
						//int64
						fallthrough
					case protoreflect.Uint64Kind:
						fallthrough
					case protoreflect.Fixed64Kind:
						//uint64
						fallthrough
					case protoreflect.FloatKind:
						fallthrough
					case protoreflect.DoubleKind:
						if field.Desc.IsList() {
							g.P("if len(req.", field.GoName, ")!=0{")
							g.P("buf.Append(\"&\")")
							g.P("buf.Append(\"", field.Desc.Name(), "\")")
							g.P("buf.Append(\"=\")")
							g.P("buf.Append(req.", field.GoName, ")")
							g.P("}")
						} else {
							g.P("if req.", field.GoName, "!=0{")
							g.P("buf.Append(\"&\")")
							g.P("buf.Append(\"", field.Desc.Name(), "\")")
							g.P("buf.Append(\"=\")")
							g.P("buf.Append(req.", field.GoName, ")")
							g.P("}")
						}
					case protoreflect.BytesKind:
						if field.Desc.IsList() {
							g.P("if len(req.", field.GoName, ")!=0{")
							g.P("buf.Append(\"&\")")
							g.P("buf.Append(\"", field.Desc.Name(), "\")")
							g.P("buf.Append(\"=[\")")
							g.P("for _,v:=range req.", field.GoName, "{")
							g.P("buf.Append(\"\\\"\")")
							g.P("buf.Append(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(v))")
							g.P("buf.Append(\"\\\",\")")
							g.P("}")
							g.P("buf.Bytes()[buf.Len()-1]=']'")
							g.P("}")
						} else {
							g.P("if len(req.", field.GoName, ")!=0{")
							g.P("buf.Append(\"&\")")
							g.P("buf.Append(\"", field.Desc.Name(), "\")")
							g.P("buf.Append(\"=\\\"\")")
							g.P("buf.Append(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(req.", field.GoName, "))")
							g.P("buf.Append(\"\\\"\")")
							g.P("}")
						}
					case protoreflect.StringKind:
						if field.Desc.IsList() {
							g.P("if len(req.", field.GoName, ")!=0{")
							g.P("buf.Append(\"&\")")
							g.P("buf.Append(\"", field.Desc.Name(), "\")")
							g.P("buf.Append(\"=[\")")
							g.P("for _,v:=range req.", field.GoName, "{")
							g.P("buf.Append(\"\\\"\")")
							g.P("buf.Append(v)")
							g.P("buf.Append(\"\\\",\")")
							g.P("}")
							g.P("buf.Bytes()[buf.Len()-1]=']'")
							g.P("}")
						} else {
							g.P("if len(req.", field.GoName, ")!=0{")
							g.P("buf.Append(\"&\")")
							g.P("buf.Append(\"", field.Desc.Name(), "\")")
							g.P("buf.Append(\"=\\\"\")")
							g.P("buf.Append(req.", field.GoName, ")")
							g.P("buf.Append(\"\\\"\")")
							g.P("}")
						}
					case protoreflect.MessageKind:
						if field.Desc.IsList() || field.Desc.IsMap() {
							//message list or map
							g.P("if len(req.", field.GoName, ")!=0{")
							g.P("buf.Append(\"&\")")
							g.P("buf.Append(\"", field.Desc.Name(), "\")")
							g.P("buf.Append(\"=\")")
							g.P("d,_:=", g.QualifiedGoIdent(jsonPackage.Ident("Marshal")), "(req.", field.GoName, ")")
							g.P("buf.Append(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(d))")
							g.P("}")
						} else {
							//message
							g.P("if req.", field.GoName, "!=nil{")
							g.P("buf.Append(\"&\")")
							g.P("buf.Append(\"", field.Desc.Name(), "\")")
							g.P("buf.Append(\"=\")")
							g.P("d,_:=", g.QualifiedGoIdent(jsonPackage.Ident("Marshal")), "(req.", field.GoName, ")")
							g.P("buf.Append(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(d))")
							g.P("}")
						}
					default:
						panic("unknown field type")
					}
				}
			}
			g.P("if buf.Len()>0{")
			g.P("buf.Bytes()[0]='?'")
			g.P("}")
			switch r.method {
			case http.MethodGet:
				g.P("callback,e:=c.cc.Get(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, "+buf.String(),header)")
			case http.MethodDelete:
				g.P("callback,e:=c.cc.Delete(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, "+buf.String(),header)")
			}
			g.P(g.QualifiedGoIdent(bufpoolPackage.Ident("PutBuffer")), "(buf)")
		} else {
			g.P("reqdata,_:=", g.QualifiedGoIdent(jsonPackage.Ident("Marshal")), "(req)")
			g.P("header:=make(", g.QualifiedGoIdent(httpPackage.Ident("Header")), ")")
			g.P("header.Set(\"Content-Type\", \"application/json\")")
			switch r.method {
			case http.MethodPost:
				g.P("callback,e:=c.cc.Post(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, ",header,reqdata)")
			case http.MethodPut:
				g.P("callback,e:=c.cc.Put(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, "header,reqdata)")
			case http.MethodPatch:
				g.P("callback,e:=c.cc.Patch(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, "header,reqdata)")
			}
		}
		g.P("if e != nil {")
		g.P("return nil, ", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"call error:\"+e.Error())")
		g.P("}")
		g.P("defer callback.Body.Close()")
		g.P("data, e := ", g.QualifiedGoIdent(ioPackage.Ident("ReadAll")), "(callback.Body)")
		g.P("if e != nil {")
		g.P("return nil, ", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"read response error:\"+e.Error())")
		g.P("}")
		g.P("if callback.StatusCode/100 == 5 || callback.StatusCode/100 == 4{")
		g.P("return nil, ", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(data))")
		g.P("}")
		g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("if len(data) > 0 {")
		g.P("if e = ", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "(data, resp); e != nil {")
		g.P("return nil, ", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"response data format errors\"+e.Error())")
		g.P("}")
		g.P("}")
		g.P("return resp, nil")
		g.P("}")
	}

	// Server interface.
	serverName := service.GoName + "WebServer"

	g.P("// ", serverName, " is the server API for ", service.GoName, " service.")
	g.P("type ", serverName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")),
			",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*",
			g.QualifiedGoIdent(method.Output.GoIdent), ",error)")
	}
	g.P("}")
	g.P()

	// Server handler
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		fname := "func _" + service.GoName + "_" + method.GoName + "_WebHandler"
		p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		freturn := g.QualifiedGoIdent(webPackage.Ident("OutsideHandler"))
		g.P(fname, "(", p1, ")", freturn, "{")
		g.P("return func(ctx *" + g.QualifiedGoIdent(webPackage.Ident("Context")) + "){")
		g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
		g.P("if ctx.GetMethod()!=", g.QualifiedGoIdent(httpPackage.Ident("MethodGet")), " && ctx.GetContentType() == \"application/json\" {")
		g.P("data, e := ctx.GetBody()")
		g.P("if e != nil {")
		g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusInternalServerError")), ",\"server error:read request body error:\"+e.Error())")
		g.P("return")
		g.P("}")
		g.P("if len(data) != 0 {")
		g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "(data,req);e!=nil{")
		g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:json format error:\"+e.Error())")
		g.P("return")
		g.P("}")
		g.P("}")
		g.P("} else {")
		g.P("if e := ctx.ParseForm(); e != nil {")
		g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:form format error:\"+e.Error())")
		g.P("return")
		g.P("}")
		g.P("buf:=", g.QualifiedGoIdent(bufpoolPackage.Ident("GetBuffer()")))
		g.P("buf.Append(\"{\")")
		g.P("hasfields:=false")
		for _, field := range method.Input.Fields {
			g.P("if temp:=ctx.GetForm(\"", field.Desc.Name(), "\");len(temp)!=0 {")
			g.P("buf.Append(\"\\\"", field.Desc.Name(), "\\\":\")")
			g.P("buf.Append(temp)")
			g.P("buf.Append(\",\")")
			g.P("hasfields=true")
			g.P("}")
		}
		g.P("if hasfields{")
		g.P("buf.Bytes()[buf.Len()-1]='}'")
		g.P("}else{")
		g.P("buf.Append(\"}\")")
		g.P("}")
		g.P("if buf.Len()>2{")
		g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "(buf.Bytes(),req);e!=nil{")
		g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:form format error:\"+e.Error())")
		g.P("return")
		g.P("}")
		g.P("}")
		g.P(g.QualifiedGoIdent(bufpoolPackage.Ident("PutBuffer(buf)")))
		g.P("}")
		if hasheader(method.Input) || haschecker(method.Input) {
			checkerandheader("req.", method.Input, g, 2)
		}
		g.P("resp,e:=handler(ctx,req)")
		g.P("if e!=nil{")
		g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusInternalServerError")), ",e.Error())")
		g.P("}else if resp == nil{")
		g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusOK")), ",\"{}\")")
		g.P("}else{")
		g.P("respd,_:=", g.QualifiedGoIdent(jsonPackage.Ident("Marshal")), "(resp)")
		g.P("ctx.Write(", g.QualifiedGoIdent(httpPackage.Ident("StatusOK")), ",respd)")
		g.P("}")
		g.P("}")
		g.P("}")
	}

	//Server Register
	g.P("func Register", serverName, "(engine *", g.QualifiedGoIdent(webPackage.Ident("WebServer")), ",svc ", serverName, ",allmids map[string]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), ")error{")
	g.P("//avoid lint")
	g.P("_=allmids")
	for _, method := range service.Methods {
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			continue
		}
		r, e := parseMethodComment(string(method.Comments.Trailing))
		if e != nil {
			panic(e)
		}
		fname := "_" + service.GoName + "_" + method.GoName + "_WebHandler(svc." + method.GoName + ")"
		pathname := "WebPath" + service.GoName + method.GoName
		if len(r.mids) > 0 {
			g.P("{")
			str := ""
			for _, mid := range r.mids {
				str += ","
				str += strconv.Quote(mid)
			}
			str = str[1:]
			g.P("requiredMids:=[]string{", str, "}")
			g.P("mids:=make([]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), ",0)")
			g.P("for _,v:=range requiredMids{")
			g.P("if mid,ok:=allmids[v];ok{")
			g.P("mids = append(mids,mid)")
			g.P("}")
			g.P("}")
			g.P("mids = append(mids,", fname, ")")
			switch r.method {
			case http.MethodGet:
				g.P("if e:=engine.Get(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
				g.P("return e")
				g.P("}")
			case http.MethodPost:
				g.P("if e:=engine.Post(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
				g.P("return e")
				g.P("}")
			case http.MethodPut:
				g.P("if e:=engine.Put(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
				g.P("return e")
				g.P("}")
			case http.MethodPatch:
				g.P("if e:=engine.Patch(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
				g.P("return e")
				g.P("}")
			case http.MethodDelete:
				g.P("if e:=engine.Delete(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
				g.P("return e")
				g.P("}")
			}
			g.P("}")
		} else {
			switch r.method {
			case http.MethodGet:
				g.P("if e:=engine.Get(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
				g.P("return e")
				g.P("}")
			case http.MethodPost:
				g.P("if e:=engine.Post(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
				g.P("return e")
				g.P("}")
			case http.MethodPut:
				g.P("if e:=engine.Put(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
				g.P("return e")
				g.P("}")
			case http.MethodPatch:
				g.P("if e:=engine.Patch(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
				g.P("return e")
				g.P("}")
			case http.MethodDelete:
				g.P("if e:=engine.Delete(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
				g.P("return e")
				g.P("}")
			}
		}
	}
	g.P("return nil")
	g.P("}")
}

func checkerandheader(prefix string, message *protogen.Message, g *protogen.GeneratedFile, clientorserver int) {
	for _, field := range message.Fields {
		if field.Oneof != nil {
			panic("don't use oneof in proto,protoc plugin can't support!")
		}
		r, e := parseFieldComment(string(field.Comments.Trailing))
		if e != nil {
			panic(e)
		}
		switch field.Desc.Kind() {
		case protoreflect.BoolKind:
			//bool or []bool
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp) != 0{")
					g.P(prefix, field.GoName, "=make([]bool,0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp) != 0{")
					g.P("if temp!=\"true\" && temp!=\"false\"{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("if temp == \"true\"{")
					g.P(prefix, field.GoName, "=true")
					g.P("}")
					g.P("}")
				}
			}
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Sfixed32Kind:
			//int32 or []int32
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P(prefix, field.GoName, "=make([]int32,0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(int64(v),10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(int64(v),10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P("tempnum,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseInt")), "(temp,10,32)")
					g.P("if e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P(prefix, field.GoName, "=int32(tempnum)")
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("if float64(", prefix, field.GoName, ")<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("if float64(", prefix, field.GoName, ")<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("if float64(", prefix, field.GoName, ")>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("if float64(", prefix, field.GoName, ")>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(int64(", prefix, field.GoName, "),10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(int64(", prefix, field.GoName, "),10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			}
		case protoreflect.Uint32Kind:
			fallthrough
		case protoreflect.Fixed32Kind:
			//uint32 or []uint32
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P(prefix, field.GoName, "=make([]uint32,0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatUint")), "(uint64(v),10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatUint")), "(uint64(v),10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P("tempnum,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseUint")), "(temp,10,32)")
					g.P("if e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P(prefix, field.GoName, "=uint32(tempnum)")
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("if float64(", prefix, field.GoName, ")<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("if float64(", prefix, field.GoName, ")<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("if float64(", prefix, field.GoName, ")>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("if float64(", prefix, field.GoName, ")>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatUint")), "(uint64(", prefix, field.GoName, "),10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatUint")), "(uint64(", prefix, field.GoName, "),10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			}
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Sfixed64Kind:
			//int64 or []int64
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P(prefix, field.GoName, "=make([]int64,0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(v,10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(v,10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P("tempnum,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseInt")), "(temp,10,64)")
					g.P("if e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P(prefix, field.GoName, "=tempnum")
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("if float64(", prefix, field.GoName, ")<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("if float64(", prefix, field.GoName, ")<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("if float64(", prefix, field.GoName, ")>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("if float64(", prefix, field.GoName, ")>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(", prefix, field.GoName, ",10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(", prefix, field.GoName, ",10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			}
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Fixed64Kind:
			//uint64 or []uint64
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P(prefix, field.GoName, "=make([]uint64,0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatUint")), "(v,10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatUint")), "(v,10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P("tempnum,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseUint")), "(temp,10,64)")
					g.P("if e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P(prefix, field.GoName, "=tempnum")
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("if float64(", prefix, field.GoName, ")<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("if float64(", prefix, field.GoName, ")<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("if float64(", prefix, field.GoName, ")>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("if float64(", prefix, field.GoName, ")>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatUint")), "(", prefix, field.GoName, ",10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatUint")), "(", prefix, field.GoName, ",10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			}
		case protoreflect.FloatKind:
			//float32 or []float32
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P(prefix, field.GoName, "=make([]float32,0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(float64(v),'f',-1,32);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(float64(v),'f',-1,32);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P("tempnum,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseFloat")), "(temp,32)")
					g.P("if e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P(prefix, field.GoName, "=float32(tempnum)")
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("if float64(", prefix, field.GoName, ")<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("if float64(", prefix, field.GoName, ")<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("if float64(", prefix, field.GoName, ")>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("if float64(", prefix, field.GoName, ")>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(", prefix, field.GoName, ",'f',-1,32);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(", prefix, field.GoName, ",'f',-1,32);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			}
		case protoreflect.DoubleKind:
			//float64
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P(prefix, field.GoName, "=make([]float64,0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if v<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if v<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if v>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if v>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(v,'f',-1,64);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(v,'f',-1,64);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P("tempnum,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseFloat")), "(temp,64)")
					g.P("if e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P(prefix, field.GoName, "=float64(tempnum)")
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("if ", prefix, field.GoName, "<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("if ", prefix, field.GoName, "<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("if ", prefix, field.GoName, ">=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("if ", prefix, field.GoName, ">", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(", prefix, field.GoName, ",'f',-1,64);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(", prefix, field.GoName, ",'f',-1,64);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			}
		case protoreflect.StringKind:
			//string or []string
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0{")
					g.P(prefix, field.GoName, "=make([]string,0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("v!=", strconv.Quote(v), "||")
						} else {
							g.P("v!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("v==", strconv.Quote(v), "||")
						} else {
							g.P("v==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0{")
					g.P(prefix, field.GoName, "=temp")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P(prefix, field.GoName, "!=", strconv.Quote(v), "||")
						} else {
							g.P(prefix, field.GoName, "!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P(prefix, field.GoName, "==", strconv.Quote(v), "||")
						} else {
							g.P(prefix, field.GoName, "==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			}
		case protoreflect.BytesKind:
			//[]byte or [][]byte
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0{")
					g.P(prefix, field.GoName, "=make([][]byte,0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("string(v)!=", strconv.Quote(v), "||")
						} else {
							g.P("string(v)!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("string(v)==", strconv.Quote(v), "||")
						} else {
							g.P("string(v)==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0{")
					g.P(prefix, field.GoName, "=[]byte(temp)")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("string(", prefix, field.GoName, ")!=", strconv.Quote(v), "||")
						} else {
							g.P("string(", prefix, field.GoName, ")!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("string(", prefix, field.GoName, ")==", strconv.Quote(v), "||")
						} else {
							g.P("string(", prefix, field.GoName, ")==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			}
		case protoreflect.EnumKind:
			//enum or []enum
			if field.Desc.IsList() {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P(prefix, field.GoName, "=make([]", g.QualifiedGoIdent(field.Enum.GoIdent), ",0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				g.P("//enum check")
				g.P("for _, v := range ", prefix, field.GoName, "{")
				g.P("if _, ok := ", g.QualifiedGoIdent(field.Enum.GoIdent), "_name[int32(v)]; !ok {")
				if clientorserver == 2 {
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:enum check failed: ", field.Desc.Name(), "\")")
					g.P("return")
				} else if clientorserver == 1 {
					g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:enum check failed: ", field.Desc.Name(), "\")")
				}
				g.P("}")
				g.P("}")
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gt != nil {
					g.P("//gt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if float64(v)>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(int64(v),10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("for _,v:=range ", prefix, field.GoName, "{")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(int64(v),10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
			} else {
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0 {")
					g.P("tempn,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseInt")), "(temp,10,32)")
					g.P("if e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P(prefix, field.GoName, "=", g.QualifiedGoIdent(field.Enum.GoIdent), "(tempn)")
					g.P("}")
				}
				g.P("//enum check")
				g.P("if _,ok:=", g.QualifiedGoIdent(field.Enum.GoIdent), "_name[int32(", prefix, field.GoName, ")];!ok{")
				if clientorserver == 2 {
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:enum check failed: ", field.Desc.Name(), "\")")
					g.P("return")
				} else if clientorserver == 1 {
					g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:enum check failed: ", field.Desc.Name(), "\")")
				}
				g.P("}")
				if r.gt != nil {
					g.P("//gt check")
					g.P("if float64(", prefix, field.GoName, ")<=", *r.gt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.gte != nil {
					g.P("//gte check")
					g.P("if float64(", prefix, field.GoName, ")<", *r.gte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:gte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:gte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lt != nil {
					g.P("//lt check")
					g.P("if float64(", prefix, field.GoName, ")>=", *r.lt, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lt check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lt check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.lte != nil {
					g.P("//lte check")
					g.P("if float64(", prefix, field.GoName, ")>", *r.lte, "{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:lte check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:lte check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.in != nil {
					g.P("//in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(int64(", prefix, field.GoName, "),10);")
					//g.P("if ")
					for i, v := range r.in {
						if i != len(r.in)-1 {
							g.P("vv!=", strconv.Quote(v), "||")
						} else {
							g.P("vv!=", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:in check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:in check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if r.notin != nil {
					g.P("//not in check")
					g.P("if vv:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatInt")), "(int64(", prefix, field.GoName, "),10);")
					//g.P("if ")
					for i, v := range r.notin {
						if i != len(r.notin)-1 {
							g.P("vv==", strconv.Quote(v), "||")
						} else {
							g.P("vv==", strconv.Quote(v), "{")
						}
					}
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:notin check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:notin check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
			}
		case protoreflect.MessageKind:
			//message or []message or map
			if field.Desc.IsMap() {
				//map
				keytype := ""
				switch field.Desc.MapKey().Kind() {
				case protoreflect.BoolKind:
					//bool
					keytype = "bool"
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					//int32
					keytype = "int32"
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					//uint32
					keytype = "uint32"
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					//int64
					keytype = "int64"
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					//uint64
					keytype = "uint64"
				case protoreflect.StringKind:
					//string
					keytype = "string"
				}
				valuetype := ""
				switch field.Desc.MapValue().Kind() {
				case protoreflect.BoolKind:
					valuetype = "bool"
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					valuetype = "int32"
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					valuetype = "uint32"
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					valuetype = "int64"
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					valuetype = "uint64"
				case protoreflect.FloatKind:
					valuetype = "float32"
				case protoreflect.DoubleKind:
					valuetype = "float64"
				case protoreflect.StringKind:
					valuetype = "string"
				case protoreflect.BytesKind:
					valuetype = "[]byte"
				case protoreflect.EnumKind:
					valuetype = g.QualifiedGoIdent(field.Message.Fields[1].Enum.GoIdent)
				case protoreflect.MessageKind:
					valuetype = "*" + g.QualifiedGoIdent(field.Message.Fields[1].Message.GoIdent)
				}
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0{")
					g.P(prefix, field.GoName, "=make(map[", keytype, "]", valuetype, ")")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if field.Desc.MapValue().Kind() == protoreflect.EnumKind {
					g.P("//enum check")
					g.P("for _, v := range ", prefix, field.GoName, "{")
					g.P("if _, ok := ", valuetype, "_name[int32(v)]; !ok {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:enum check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:enum check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if field.Desc.MapValue().Kind() == protoreflect.MessageKind {
					if haschecker(field.Message.Fields[1].Message) || hasheader(field.Message.Fields[1].Message) {
						g.P("for k:=range ", prefix, field.GoName, "{")
						g.P("if ", prefix, field.GoName, "[k]!=nil{")
						checkerandheader(prefix+field.GoName+"[k].", field.Message.Fields[1].Message, g, clientorserver)
						g.P("}")
						g.P("}")
					}
				}
			} else if field.Desc.IsList() {
				//[]message
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0{")
					g.P(prefix, field.GoName, "=make([]*", g.QualifiedGoIdent(field.Message.GoIdent), ",0)")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),&", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if len(", prefix, field.GoName, ") == 0 {")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if haschecker(field.Message) || hasheader(field.Message) {
					g.P("for i:=range ", prefix, field.GoName, "{")
					g.P("if ", prefix, field.GoName, "[i]!=nil{")
					checkerandheader(prefix+field.GoName+"[i].", field.Message, g, clientorserver)
					g.P("}")
					g.P("}")
				}
			} else {
				//message
				if r.header && clientorserver == 2 {
					g.P("//header")
					g.P("if temp:=ctx.GetHeader(\"", field.Desc.Name(), "\");len(temp)!=0{")
					g.P(prefix, field.GoName, "=new(", g.QualifiedGoIdent(field.Message.GoIdent), ")")
					g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "([]byte(temp),", prefix, field.GoName, ");e!=nil{")
					g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:header: ", field.Desc.Name(), " format error\")")
					g.P("return")
					g.P("}")
					g.P("}")
				}
				if r.notempty {
					g.P("//empty check")
					g.P("if ", prefix, field.GoName, "==nil{")
					if clientorserver == 2 {
						g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:empty check failed: ", field.Desc.Name(), "\")")
						g.P("return")
					} else if clientorserver == 1 {
						g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:empty check failed: ", field.Desc.Name(), "\")")
					}
					g.P("}")
				}
				if haschecker(field.Message) || hasheader(field.Message) {
					g.P("if ", prefix, field.GoName, "!=nil{")
					checkerandheader(prefix+field.GoName+".", field.Message, g, clientorserver)
					g.P("}")
				}
			}
		default:
			panic("unknown field type")
		}
	}
}
func haschecker(message *protogen.Message) bool {
	for _, field := range message.Fields {
		if field.Oneof != nil {
			panic("don't use oneof in proto,protoc plugin can't support!")
		}
		r, e := parseFieldComment(string(field.Comments.Trailing))
		if e != nil {
			panic(e)
		}
		kind := field.Desc.Kind()
		if kind == protoreflect.EnumKind || (field.Desc.IsMap() && field.Desc.MapValue().Kind() == protoreflect.EnumKind) {
			return true
		}
		//empty will only check on bytes,string,list,map,struct
		if r.notempty && (field.Desc.Kind() == protoreflect.MessageKind || field.Desc.Kind() == protoreflect.StringKind || field.Desc.Kind() == protoreflect.BytesKind || field.Desc.IsList() || field.Desc.IsMap()) {
			return true
		}
		//in and not in will not check on struct,map,bool kind fields
		if (r.in != nil || r.notin != nil) && kind != protoreflect.BoolKind && kind != protoreflect.MessageKind && kind != protoreflect.GroupKind {
			return true
		}
		//gt,gte,lt,lte will only check on number kind fields
		if (r.gt != nil || r.lt != nil || r.gte != nil || r.lte != nil) && kind != protoreflect.MessageKind && kind != protoreflect.BytesKind && kind != protoreflect.StringKind && kind != protoreflect.BoolKind && kind != protoreflect.GroupKind {
			return true
		}
		if kind == protoreflect.MessageKind {
			if field.Desc.IsList() || !field.Desc.IsMap() {
				if haschecker(field.Message) {
					return true
				}
			} else if field.Desc.MapValue().Kind() == protoreflect.MessageKind {
				if haschecker(field.Message.Fields[1].Message) {
					return true
				}
			}
		}
	}
	return false
}
func hasheader(message *protogen.Message) bool {
	for _, field := range message.Fields {
		if field.Oneof != nil {
			panic("don't use oneof in proto,protoc plugin can't support!")
		}
		r, e := parseFieldComment(string(field.Comments.Trailing))
		if e != nil {
			panic(e)
		}
		if r.header {
			return true
		}
		if field.Desc.Kind() == protoreflect.MessageKind {
			if field.Desc.IsList() || !field.Desc.IsMap() {
				if hasheader(field.Message) {
					return true
				}
			} else if field.Desc.MapValue().Kind() == protoreflect.MessageKind {
				if hasheader(field.Message.Fields[1].Message) {
					return true
				}
			}
		}
	}
	return false
}

type methodComment struct {
	method  string
	timeout time.Duration
	mids    []string
}

func parseMethodComment(data string) (*methodComment, error) {
	var e error
	r := &methodComment{
		method:  http.MethodGet,
		timeout: 0,
		mids:    make([]string, 0),
	}
	if len(strings.TrimSpace(data)) == 0 {
		return r, nil
	}
	strs := strings.Split(strings.TrimSpace(data), "|")
	for _, str := range strs {
		substrs := strings.Split(str, ":")
		if len(substrs) != 2 {
			return nil, fmt.Errorf("rpc comment format error")
		}
		if len(strings.TrimSpace(substrs[1])) == 0 {
			continue
		}
		switch strings.ToLower(strings.TrimSpace(substrs[0])) {
		case "method":
			r.method = strings.ToUpper(strings.TrimSpace(substrs[1]))
			switch r.method {
			case http.MethodGet:
			case http.MethodDelete:
			case http.MethodPost:
			case http.MethodPut:
			case http.MethodPatch:
			default:
				return nil, fmt.Errorf("rpc unsupported http method comment,supported:get,post")
			}
		case "timeout":
			if r.timeout, e = time.ParseDuration(strings.TrimSpace(substrs[1])); e != nil {
				return nil, fmt.Errorf("rpc timeout comment format error,example:100ms,1s,1m,1h")
			}
		case "mids":
			r.mids = make([]string, 0)
			if e = json.Unmarshal([]byte(strings.TrimSpace(substrs[1])), &r.mids); e != nil {
				return nil, fmt.Errorf("rpc mids comment format error,example:[\"firstmid\",\"secondmid\"]")
			}
		default:
			return nil, fmt.Errorf("rpc unknown comment")
		}
	}
	return r, nil
}

type fieldComment struct {
	header   bool
	notempty bool
	gt       *float64
	lt       *float64
	gte      *float64
	lte      *float64
	in       []string
	notin    []string
}

func parseFieldComment(data string) (*fieldComment, error) {
	r := &fieldComment{}
	if len(strings.TrimSpace(data)) == 0 {
		return r, nil
	}
	strs := strings.Split(strings.TrimSpace(data), "|")
	for _, str := range strs {
		substrs := strings.Split(str, ":")
		if len(substrs) != 2 {
			return nil, fmt.Errorf("field comment format error")
		}
		if len(strings.TrimSpace(substrs[1])) == 0 {
			continue
		}
		switch strings.ToLower(substrs[0]) {
		case "header":
			tmp := strings.ToLower(strings.TrimSpace(substrs[1]))
			if tmp != "true" {
				return nil, fmt.Errorf("field header comment format error,support:true")
			}
			r.header = true
		case "empty":
			tmp := strings.ToLower(strings.TrimSpace(substrs[1]))
			if tmp != "false" {
				return nil, fmt.Errorf("field empty comment format error,suppoer:false")
			}
			r.notempty = true
		case "gt":
			temp, e := strconv.ParseFloat(substrs[1], 64)
			if e != nil {
				return nil, fmt.Errorf("field gt comment format error,example:123.1,9999")
			}
			r.gt = &temp
		case "gte":
			temp, e := strconv.ParseFloat(substrs[1], 64)
			if e != nil {
				return nil, fmt.Errorf("field gte comment format error,example:123.1,9999")
			}
			r.gte = &temp
		case "lt":
			temp, e := strconv.ParseFloat(substrs[1], 64)
			if e != nil {
				return nil, fmt.Errorf("field lt comment format error,example:123.1,9999")
			}
			r.lt = &temp
		case "lte":
			temp, e := strconv.ParseFloat(substrs[1], 64)
			if e != nil {
				return nil, fmt.Errorf("field lte comment format error,example:123.1,9999")
			}
			r.lte = &temp
		case "in":
			in := make([]string, 0)
			if e := json.Unmarshal([]byte(strings.TrimSpace(substrs[1])), &in); e != nil {
				return nil, fmt.Errorf("field in comment format error,example:[\"1\",\"abc\",\"3.14\"]")
			}
			r.in = in
		case "notin":
			notin := make([]string, 0)
			if e := json.Unmarshal([]byte(strings.TrimSpace(substrs[1])), &notin); e != nil {
				return nil, fmt.Errorf("field notin comment format error,example:[\"1\",\"abc\",\"3.14\"]")
			}
			r.notin = notin
		default:
			return nil, fmt.Errorf("field unknown comment")
		}
	}
	if r.gte != nil && r.gt != nil {
		if *r.gt >= *r.gte {
			r.gte = nil
		} else {
			r.gt = nil
		}
	}
	if r.lte != nil && r.lt != nil {
		if *r.lt <= *r.lte {
			r.lte = nil
		} else {
			r.lt = nil
		}
	}
	if r.gte != nil {
		if r.lte != nil && *r.gte > *r.lte {
			return nil, fmt.Errorf("field comment format error,gte > lte")
		}
		if r.lt != nil && *r.gte >= *r.lt {
			return nil, fmt.Errorf("field comment format error,gte >= lt")
		}
	}
	if r.gt != nil {
		if r.lte != nil && *r.gt >= *r.lte {
			return nil, fmt.Errorf("field comment format error,gt >= lte")
		}
		if r.lt != nil && *r.gt >= *r.lt {
			return nil, fmt.Errorf("field comment format error,gt >= lt")
		}
	}
	if r.in != nil && r.notin != nil {
		return nil, fmt.Errorf("field comment form error,in,notin can only set one")
	}
	if len(r.in) == 0 {
		r.in = nil
	}
	if len(r.notin) == 0 {
		r.notin = nil
	}
	return r, nil
}
