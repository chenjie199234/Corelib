package main

import (
	"fmt"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/chenjie199234/Corelib/pbex"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	stringsPackage  = protogen.GoImportPath("strings")
	bytesPackage    = protogen.GoImportPath("bytes")
	strconvPackage  = protogen.GoImportPath("strconv")
	httpPackage     = protogen.GoImportPath("net/http")
	regexpPackage   = protogen.GoImportPath("regexp")
	fmtPackage      = protogen.GoImportPath("fmt")
	ioPackage       = protogen.GoImportPath("io")
	contextPackage  = protogen.GoImportPath("context")
	protoPackage    = protogen.GoImportPath("google.golang.org/protobuf/proto")
	jsonPackage     = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	webPackage      = protogen.GoImportPath("github.com/chenjie199234/Corelib/web")
	logPackage      = protogen.GoImportPath("github.com/chenjie199234/Corelib/log")
	commonPackage   = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/common")
	metadataPackage = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/metadata")
	bufpoolPackage  = protogen.GoImportPath("github.com/chenjie199234/Corelib/bufpool")
	errorPackage    = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/error")
)

// generateFile generates a _web.pb.go file containing web service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_web.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		genService(file, g, service)
	}
	return g
}
func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-go-web. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-web ", version)
	g.P("// \tprotoc         ", protocVersion)
	g.P("// source: ", file.Desc.Path())
	g.P()
}

var service *protogen.Service             //cur dealing service
var allcheck map[string]*protogen.Message //key message's full import path
var allreg map[string]struct{}            //key regexp

func genService(file *protogen.File, g *protogen.GeneratedFile, s *protogen.Service) {
	service = s
	geninit(file, g)
	genPath(file, g)
	genClient(file, g)
	genServer(file, g)
}
func geninit(file *protogen.File, g *protogen.GeneratedFile) {
	allreg = make(map[string]struct{}, 10)
	allcheck = make(map[string]*protogen.Message, 10)
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		stack := make(map[string]struct{})
		getallreg(method.Input, stack, allreg)
		stack = make(map[string]struct{})
		getallcheck(method.Input, stack, allcheck)
	}
	if len(allcheck) > 0 {
		g.P("var _", service.GoName, "WebCheckers map[string]func(req interface{})bool")
	}
	if len(allreg) > 0 {
		for reg := range allreg {
			if _, e := regexp.Compile(reg); e != nil {
				panic("reg: '" + reg + "' syntax wrong")
			}
		}
		g.P("var _", service.GoName, "WebRegs map[string]*", g.QualifiedGoIdent(regexpPackage.Ident("Regexp")))
	}
	if len(allcheck) > 0 || len(allreg) > 0 {
		g.P("func init(){")
		if len(allreg) > 0 {
			g.P("_", service.GoName, "WebRegs=make(map[string]*", g.QualifiedGoIdent(regexpPackage.Ident("Regexp")), ",", len(allreg), ")")
			g.P("var e error")
			for reg := range allreg {
				g.P("if _", service.GoName, "WebRegs[", strconv.Quote(reg), "] ,e = ", g.QualifiedGoIdent(regexpPackage.Ident("Compile")), "(", strconv.Quote(reg), ");e!=nil{")
				g.P("panic(\"protoc-gen-go-rpc will check all regexp before generate this code,this may happen when the golang version build protoc-gen-go-rpc and golang version run this code isn't same and the two version's regexp package is different\")")
				g.P("}")
			}
			g.P()
		}
		if len(allcheck) > 0 {
			g.P("_", service.GoName, "WebCheckers = make(map[string]func(req interface{})bool,", len(allcheck), ")")
			for k, m := range allcheck {
				g.P("_", service.GoName, "WebCheckers[", strconv.Quote(k), "]=func(r interface{})bool{")
				g.P("req:=r.(*", g.QualifiedGoIdent(m.GoIdent), ")")
				check("req.", m, g)
				g.P("}")
			}
		}
		g.P("}")
	}
}
func getallreg(m *protogen.Message, stack map[string]struct{}, allreg map[string]struct{}) {
	if _, ok := stack[m.GoIdent.String()]; ok {
		return
	}
	stack[m.GoIdent.String()] = struct{}{}
	defer delete(stack, m.GoIdent.String())
	for _, field := range m.Fields {
		fop := field.Desc.Options().(*descriptorpb.FieldOptions)
		if field.Desc.Kind() == protoreflect.BytesKind || field.Desc.Kind() == protoreflect.StringKind {
			if proto.HasExtension(fop, pbex.E_StringBytesRegMatch) {
				match := proto.GetExtension(fop, pbex.E_StringBytesRegMatch).([]string)
				for _, v := range match {
					allreg[v] = struct{}{}
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesRegNotMatch) {
				notmatch := proto.GetExtension(fop, pbex.E_StringBytesRegNotMatch).([]string)
				for _, v := range notmatch {
					allreg[v] = struct{}{}
				}
			}
		} else if field.Desc.Kind() == protoreflect.MessageKind {
			if field.Desc.IsMap() {
				//map
				if field.Message.Fields[0].Desc.Kind() == protoreflect.StringKind {
					if proto.HasExtension(fop, pbex.E_MapKeyStringRegMatch) {
						match := proto.GetExtension(fop, pbex.E_MapKeyStringRegMatch).([]string)
						for _, v := range match {
							allreg[v] = struct{}{}
						}
					}
					if proto.HasExtension(fop, pbex.E_MapKeyStringRegNotMatch) {
						notmatch := proto.GetExtension(fop, pbex.E_MapKeyStringRegNotMatch).([]string)
						for _, v := range notmatch {
							allreg[v] = struct{}{}
						}
					}
				}
				if field.Message.Fields[1].Desc.Kind() == protoreflect.BytesKind || field.Message.Fields[1].Desc.Kind() == protoreflect.StringKind {
					if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegMatch) {
						match := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegMatch).([]string)
						for _, v := range match {
							allreg[v] = struct{}{}
						}
					}
					if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegNotMatch) {
						notmatch := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegNotMatch).([]string)
						for _, v := range notmatch {
							allreg[v] = struct{}{}
						}
					}
				} else if field.Message.Fields[1].Desc.Kind() == protoreflect.MessageKind {
					getallreg(field.Message.Fields[1].Message, stack, allreg)
				}
			} else {
				//[]message or message
				getallreg(field.Message, stack, allreg)
			}
		}
	}
}
func getallcheck(m *protogen.Message, stack map[string]struct{}, allcheck map[string]*protogen.Message) (check bool) {
	if _, ok := stack[m.GoIdent.String()]; ok {
		return false
	}
	stack[m.GoIdent.String()] = struct{}{}
	defer func() {
		delete(stack, m.GoIdent.String())
	}()
	if _, ok := allcheck[m.GoIdent.String()]; ok {
		return true
	}
	allcheck[m.GoIdent.String()] = m
	defer func() {
		if !check {
			delete(allcheck, m.GoIdent.String())
		}
	}()
	for _, field := range m.Fields {
		fop := field.Desc.Options().(*descriptorpb.FieldOptions)
		if field.Desc.IsList() || field.Desc.IsMap() {
			if proto.HasExtension(fop, pbex.E_MapRepeatedLenEq) ||
				proto.HasExtension(fop, pbex.E_MapRepeatedLenNotEq) ||
				proto.HasExtension(fop, pbex.E_MapRepeatedLenGt) ||
				proto.HasExtension(fop, pbex.E_MapRepeatedLenGte) ||
				proto.HasExtension(fop, pbex.E_MapRepeatedLenLt) ||
				proto.HasExtension(fop, pbex.E_MapRepeatedLenLte) {
				check = true
			}
		}
		switch field.Desc.Kind() {
		case protoreflect.BoolKind:
			//bool
			if proto.HasExtension(fop, pbex.E_BoolEq) {
				check = true
			}
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Sfixed32Kind:
			fallthrough
			//int32 or []int32
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Sfixed64Kind:
			//int64 or []int64
			if proto.HasExtension(fop, pbex.E_IntIn) ||
				proto.HasExtension(fop, pbex.E_IntNotIn) ||
				proto.HasExtension(fop, pbex.E_IntGt) ||
				proto.HasExtension(fop, pbex.E_IntGte) ||
				proto.HasExtension(fop, pbex.E_IntLt) ||
				proto.HasExtension(fop, pbex.E_IntLte) {
				check = true
			}
		case protoreflect.Uint32Kind:
			fallthrough
		case protoreflect.Fixed32Kind:
			fallthrough
			//uint32 or []uint32
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Fixed64Kind:
			//uint64 or []uint64
			if proto.HasExtension(fop, pbex.E_UintIn) ||
				proto.HasExtension(fop, pbex.E_UintNotIn) ||
				proto.HasExtension(fop, pbex.E_UintGt) ||
				proto.HasExtension(fop, pbex.E_UintGte) ||
				proto.HasExtension(fop, pbex.E_UintLt) ||
				proto.HasExtension(fop, pbex.E_UintLte) {
				check = true
			}
		case protoreflect.FloatKind:
			//float32 or []float32
			fallthrough
		case protoreflect.DoubleKind:
			//float64 or []float64
			if proto.HasExtension(fop, pbex.E_FloatIn) ||
				proto.HasExtension(fop, pbex.E_FloatNotIn) ||
				proto.HasExtension(fop, pbex.E_FloatGt) ||
				proto.HasExtension(fop, pbex.E_FloatGte) ||
				proto.HasExtension(fop, pbex.E_FloatLt) ||
				proto.HasExtension(fop, pbex.E_FloatLte) {
				check = true
			}
		case protoreflect.EnumKind:
			//enum or []enum
			check = true
		case protoreflect.BytesKind:
			//[]bytes or [][]bytes
			fallthrough
		case protoreflect.StringKind:
			//string or []string
			if proto.HasExtension(fop, pbex.E_StringBytesIn) ||
				proto.HasExtension(fop, pbex.E_StringBytesNotIn) ||
				proto.HasExtension(fop, pbex.E_StringBytesRegMatch) ||
				proto.HasExtension(fop, pbex.E_StringBytesRegNotMatch) ||
				proto.HasExtension(fop, pbex.E_StringBytesLenEq) ||
				proto.HasExtension(fop, pbex.E_StringBytesLenNotEq) ||
				proto.HasExtension(fop, pbex.E_StringBytesLenGt) ||
				proto.HasExtension(fop, pbex.E_StringBytesLenGte) ||
				proto.HasExtension(fop, pbex.E_StringBytesLenLt) ||
				proto.HasExtension(fop, pbex.E_StringBytesLenLte) {
				check = true
			}
		case protoreflect.MessageKind:
			if field.Desc.IsMap() {
				key := field.Message.Fields[0]
				value := field.Message.Fields[1]
				switch key.Desc.Kind() {
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					fallthrough
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					if proto.HasExtension(fop, pbex.E_MapKeyIntIn) ||
						proto.HasExtension(fop, pbex.E_MapKeyIntNotIn) ||
						proto.HasExtension(fop, pbex.E_MapKeyIntGt) ||
						proto.HasExtension(fop, pbex.E_MapKeyIntGte) ||
						proto.HasExtension(fop, pbex.E_MapKeyIntLt) ||
						proto.HasExtension(fop, pbex.E_MapKeyIntLte) {
						check = true
					}
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					fallthrough
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					if proto.HasExtension(fop, pbex.E_MapKeyUintIn) ||
						proto.HasExtension(fop, pbex.E_MapKeyUintNotIn) ||
						proto.HasExtension(fop, pbex.E_MapKeyUintGt) ||
						proto.HasExtension(fop, pbex.E_MapKeyUintGte) ||
						proto.HasExtension(fop, pbex.E_MapKeyUintLt) ||
						proto.HasExtension(fop, pbex.E_MapKeyUintLte) {
						check = true
					}
				case protoreflect.StringKind:
					if proto.HasExtension(fop, pbex.E_MapKeyStringIn) ||
						proto.HasExtension(fop, pbex.E_MapKeyStringNotIn) ||
						proto.HasExtension(fop, pbex.E_MapKeyStringRegMatch) ||
						proto.HasExtension(fop, pbex.E_MapKeyStringRegNotMatch) ||
						proto.HasExtension(fop, pbex.E_MapKeyStringLenEq) ||
						proto.HasExtension(fop, pbex.E_MapKeyStringLenNotEq) ||
						proto.HasExtension(fop, pbex.E_MapKeyStringLenGt) ||
						proto.HasExtension(fop, pbex.E_MapKeyStringLenGte) ||
						proto.HasExtension(fop, pbex.E_MapKeyStringLenLt) ||
						proto.HasExtension(fop, pbex.E_MapKeyStringLenLte) {
						check = true
					}
				}
				switch value.Desc.Kind() {
				case protoreflect.EnumKind:
					check = true
				case protoreflect.BoolKind:
					if proto.HasExtension(fop, pbex.E_MapValueBoolEq) {
						check = true
					}
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					fallthrough
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					if proto.HasExtension(fop, pbex.E_MapValueIntIn) ||
						proto.HasExtension(fop, pbex.E_MapValueIntNotIn) ||
						proto.HasExtension(fop, pbex.E_MapValueIntGt) ||
						proto.HasExtension(fop, pbex.E_MapValueIntGte) ||
						proto.HasExtension(fop, pbex.E_MapValueIntLt) ||
						proto.HasExtension(fop, pbex.E_MapValueIntLte) {
						check = true
					}
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					fallthrough
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					if proto.HasExtension(fop, pbex.E_MapValueUintIn) ||
						proto.HasExtension(fop, pbex.E_MapValueUintNotIn) ||
						proto.HasExtension(fop, pbex.E_MapValueUintGt) ||
						proto.HasExtension(fop, pbex.E_MapValueUintGte) ||
						proto.HasExtension(fop, pbex.E_MapValueUintLt) ||
						proto.HasExtension(fop, pbex.E_MapValueUintLte) {
						check = true
					}
				case protoreflect.FloatKind:
					fallthrough
				case protoreflect.DoubleKind:
					if proto.HasExtension(fop, pbex.E_MapValueFloatIn) ||
						proto.HasExtension(fop, pbex.E_MapValueFloatNotIn) ||
						proto.HasExtension(fop, pbex.E_MapValueFloatGt) ||
						proto.HasExtension(fop, pbex.E_MapValueFloatGte) ||
						proto.HasExtension(fop, pbex.E_MapValueFloatLt) ||
						proto.HasExtension(fop, pbex.E_MapValueFloatLte) {
						check = true
					}
				case protoreflect.BytesKind:
					fallthrough
				case protoreflect.StringKind:
					if proto.HasExtension(fop, pbex.E_MapValueStringBytesIn) ||
						proto.HasExtension(fop, pbex.E_MapValueStringBytesNotIn) ||
						proto.HasExtension(fop, pbex.E_MapValueStringBytesRegMatch) ||
						proto.HasExtension(fop, pbex.E_MapValueStringBytesRegNotMatch) ||
						proto.HasExtension(fop, pbex.E_MapValueStringBytesLenEq) ||
						proto.HasExtension(fop, pbex.E_MapValueStringBytesLenNotEq) ||
						proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGt) ||
						proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGte) ||
						proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLt) ||
						proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLte) {
						check = true
					}
				case protoreflect.MessageKind:
					if getallcheck(value.Message, stack, allcheck) {
						check = true
					}
				}
			} else {
				//message or []message
				if getallcheck(field.Message, stack, allcheck) {
					check = true
				}
			}
		}
	}
	return
}
func check(prefix string, message *protogen.Message, g *protogen.GeneratedFile) {
	for _, field := range message.Fields {
		fop := field.Desc.Options().(*descriptorpb.FieldOptions)
		isbyteslice := false
		switch field.Desc.Kind() {
		case protoreflect.BoolKind:
			//bool or []bool
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g)
			}
			boolcheck(prefix, field.GoName, field.Desc.IsList(), fop, g)
		case protoreflect.EnumKind:
			//enum or []enum
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g)
			}
			enumcheck(prefix, field.GoName, field.Enum.GoIdent, field.Desc.IsList(), fop, g)
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Sfixed32Kind:
			fallthrough
			//int32 or []int32
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Sfixed64Kind:
			//int64 or []int64
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g)
			}
			intcheck(prefix, field.GoName, field.Desc.IsList(), fop, g)
		case protoreflect.Uint32Kind:
			fallthrough
		case protoreflect.Fixed32Kind:
			fallthrough
			//uint32 or []uint32
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Fixed64Kind:
			//uint64 or []uint64
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g)
			}
			uintcheck(prefix, field.GoName, field.Desc.IsList(), fop, g)
		case protoreflect.FloatKind:
			//float32 or []float32
			fallthrough
		case protoreflect.DoubleKind:
			//float64 or []float64
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g)
			}
			floatcheck(prefix, field.GoName, field.Desc.IsList(), fop, g)
		case protoreflect.BytesKind:
			//[]bytes or [][]bytes
			isbyteslice = true
			fallthrough
		case protoreflect.StringKind:
			//string or []string
			if field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g)
			}
			strcheck(prefix, field.GoName, field.Desc.IsList(), isbyteslice, fop, g)
		case protoreflect.MessageKind:
			//message or []message or map
			if field.Desc.IsMap() || field.Desc.IsList() {
				elementnumcheck(prefix, field.GoName, fop, g)
			}
			if field.Desc.IsMap() {
				//map
				mapcheck(prefix, field.GoName, field.Message.Fields[0], field.Message.Fields[1], fop, g)
			} else {
				//message or []message
				if _, ok := allcheck[field.Message.GoIdent.String()]; ok {
					messagecheck(prefix, field.GoName, field.Desc.IsList(), field.Message, g)
				}
			}
		}
	}
	g.P("return true")
}
func elementnumcheck(prefix, fieldname string, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenEq) {
		leneq := proto.GetExtension(fop, pbex.E_MapRepeatedLenEq).(uint64)
		g.P("if len(", prefix+fieldname, ")!=", leneq, "{")
		g.P("return false")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenNotEq) {
		lennoteq := proto.GetExtension(fop, pbex.E_MapRepeatedLenNotEq).(uint64)
		g.P("if len(", prefix+fieldname, ")==", lennoteq, "{")
		g.P("return false")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenGt) {
		lengt := proto.GetExtension(fop, pbex.E_MapRepeatedLenGt).(uint64)
		g.P("if len(", prefix+fieldname, ")<=", lengt, "{")
		g.P("return false")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenGte) {
		lengte := proto.GetExtension(fop, pbex.E_MapRepeatedLenGte).(uint64)
		g.P("if len(", prefix+fieldname, ")<", lengte, "{")
		g.P("return false")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenLt) {
		lenlt := proto.GetExtension(fop, pbex.E_MapRepeatedLenLt).(uint64)
		g.P("if len(", prefix+fieldname, ")>=", lenlt, "{")
		g.P("return false")
		g.P("}")
	}
	if proto.HasExtension(fop, pbex.E_MapRepeatedLenLte) {
		lenlte := proto.GetExtension(fop, pbex.E_MapRepeatedLenLte).(uint64)
		g.P("if len(", prefix+fieldname, ")>", lenlte, "{")
		g.P("return false")
		g.P("}")
	}
}
func boolcheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_BoolEq) {
		booleq := proto.GetExtension(fop, pbex.E_BoolEq).(bool)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			g.P("if v!=", booleq, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "!=", booleq, "{")
			g.P("return false")
			g.P("}")
		}
	}
}
func enumcheck(prefix, fieldname string, ident protogen.GoIdent, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if islist {
		g.P("for _,v:=range ", prefix+fieldname, "{")
		g.P("if _,ok:=", g.QualifiedGoIdent(ident), "_name[int32(v)];!ok{")
		g.P("return false")
		g.P("}")
		g.P("}")
	} else {
		g.P("if _,ok:=", g.QualifiedGoIdent(ident), "_name[int32(", prefix+fieldname, ")];!ok{")
		g.P("return false")
		g.P("}")
	}
}
func intcheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_IntIn) {
		in := proto.GetExtension(fop, pbex.E_IntIn).([]int64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range in {
				g.P("if v!=", v, "{")
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range in {
				g.P("if ", prefix+fieldname, "!=", v, "{")
				g.P("return false")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_IntNotIn) {
		notin := proto.GetExtension(fop, pbex.E_IntNotIn).([]int64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range notin {
				g.P("if v==", v, "{")
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range notin {
				g.P("if ", prefix+fieldname, "==", v, "{")
				g.P("return false")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_IntGt) {
		gt := proto.GetExtension(fop, pbex.E_IntGt).(int64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<=", gt, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<=", gt, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntGte) {
		gte := proto.GetExtension(fop, pbex.E_IntGte).(int64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<", gte, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<", gte, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntLt) {
		lt := proto.GetExtension(fop, pbex.E_IntLt).(int64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>=", lt, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">=", lt, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_IntLte) {
		lte := proto.GetExtension(fop, pbex.E_IntLte).(int64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>", lte, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">", lte, "{")
			g.P("return false")
			g.P("}")
		}
	}
}
func uintcheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_UintIn) {
		in := proto.GetExtension(fop, pbex.E_UintIn).([]uint64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range in {
				g.P("if v!=", v, "{")
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range in {
				g.P("if ", prefix+fieldname, "!=", v, "{")
				g.P("return false")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_UintNotIn) {
		notin := proto.GetExtension(fop, pbex.E_UintNotIn).([]uint64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range notin {
				g.P("if v==", v, "{")
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range notin {
				g.P("if ", prefix+fieldname, "==", v, "{")
				g.P("return false")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_UintGt) {
		gt := proto.GetExtension(fop, pbex.E_UintGt).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<=", gt, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<=", gt, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintGte) {
		gte := proto.GetExtension(fop, pbex.E_UintGte).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<", gte, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<", gte, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintLt) {
		lt := proto.GetExtension(fop, pbex.E_UintLt).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>=", lt, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">=", lt, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_UintLte) {
		lte := proto.GetExtension(fop, pbex.E_UintLte).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>", lte, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">", lte, "{")
			g.P("return false")
			g.P("}")
		}
	}
}
func floatcheck(prefix, fieldname string, islist bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_FloatIn) {
		in := proto.GetExtension(fop, pbex.E_FloatIn).([]float64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range in {
				g.P("if v!=", v, "{")
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range in {
				g.P("if ", prefix+fieldname, "!=", v, "{")
				g.P("return false")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatNotIn) {
		notin := proto.GetExtension(fop, pbex.E_FloatNotIn).([]float64)
		if islist {
			g.P("for _,v:= range ", prefix+fieldname, "{")
			for _, v := range notin {
				g.P("if v==", v, "{")
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range notin {
				g.P("if ", prefix+fieldname, "==", v, "{")
				g.P("return false")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatGt) {
		gt := proto.GetExtension(fop, pbex.E_FloatGt).(float64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<=", gt, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<=", gt, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatGte) {
		gte := proto.GetExtension(fop, pbex.E_FloatGte).(float64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v<", gte, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, "<", gte, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatLt) {
		lt := proto.GetExtension(fop, pbex.E_FloatLt).(float64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>=", lt, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">=", lt, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_FloatLte) {
		lte := proto.GetExtension(fop, pbex.E_FloatLte).(float64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if v>", lte, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if ", prefix+fieldname, ">", lte, "{")
			g.P("return false")
			g.P("}")
		}
	}
}
func strcheck(prefix, fieldname string, islist bool, isslice bool, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	if proto.HasExtension(fop, pbex.E_StringBytesLenEq) {
		leneq := proto.GetExtension(fop, pbex.E_StringBytesLenEq).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)!=", leneq, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")!=", leneq, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenNotEq) {
		lennoteq := proto.GetExtension(fop, pbex.E_StringBytesLenNotEq).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)==", lennoteq, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")==", lennoteq, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenGt) {
		lengt := proto.GetExtension(fop, pbex.E_StringBytesLenGt).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)<=", lengt, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")<=", lengt, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenGte) {
		lengte := proto.GetExtension(fop, pbex.E_StringBytesLenGte).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)<", lengte, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")<", lengte, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenLt) {
		lenlt := proto.GetExtension(fop, pbex.E_StringBytesLenLt).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)>=", lenlt, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")>=", lenlt, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesLenLte) {
		lenlte := proto.GetExtension(fop, pbex.E_StringBytesLenLte).(uint64)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			g.P("if len(v)>", lenlte, "{")
			g.P("return false")
			g.P("}")
			g.P("}")
		} else {
			g.P("if len(", prefix+fieldname, ")>", lenlte, "{")
			g.P("return false")
			g.P("}")
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesIn) {
		in := proto.GetExtension(fop, pbex.E_StringBytesIn).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, v := range in {
				if isslice {
					g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)!=", strconv.Quote(v), "{")
				} else {
					g.P("if v!=", strconv.Quote(v), "{")
				}
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range in {
				if isslice {
					g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)!=", strconv.Quote(v), "{")
				} else {
					g.P("if v!=", strconv.Quote(v), "{")
				}
				g.P("return false")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesNotIn) {
		notin := proto.GetExtension(fop, pbex.E_StringBytesNotIn).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, v := range notin {
				if isslice {
					g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)==", strconv.Quote(v), "{")
				} else {
					g.P("if v==", strconv.Quote(v), "{")
				}
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, v := range notin {
				if isslice {
					g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)==", strconv.Quote(v), "{")
				} else {
					g.P("if v==", strconv.Quote(v), "{")
				}
				g.P("return false")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesRegMatch) {
		match := proto.GetExtension(fop, pbex.E_StringBytesRegMatch).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, m := range match {
				if isslice {
					g.P("if !_", service.GoName, "WebRegs[", strconv.Quote(m), "].Match(v){")
				} else {
					g.P("if !_", service.GoName, "WebRegs[", strconv.Quote(m), "].MatchString(v){")
				}
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, m := range match {
				if isslice {
					g.P("if !_", service.GoName, "WebRegs[", strconv.Quote(m), "].Match(", prefix+fieldname, "){")
				} else {
					g.P("if !_", service.GoName, "WebRegs[", strconv.Quote(m), "].MatchString(", prefix+fieldname, "){")
				}
				g.P("return false")
				g.P("}")
			}
		}
	}
	if proto.HasExtension(fop, pbex.E_StringBytesRegNotMatch) {
		notmatch := proto.GetExtension(fop, pbex.E_StringBytesRegNotMatch).([]string)
		if islist {
			g.P("for _,v:=range ", prefix+fieldname, "{")
			for _, m := range notmatch {
				if isslice {
					g.P("if _", service.GoName, "WebRegs[", strconv.Quote(m), "].Match(v){")
				} else {
					g.P("if _", service.GoName, "WebRegs[", strconv.Quote(m), "].MatchString(v){")
				}
				g.P("return false")
				g.P("}")
			}
			g.P("}")
		} else {
			for _, m := range notmatch {
				if isslice {
					g.P("if _", service.GoName, "WebRegs[", strconv.Quote(m), "].Match(", prefix+fieldname, "){")
				} else {
					g.P("if _", service.GoName, "WebRegs[", strconv.Quote(m), "].MatchString(", prefix+fieldname, "){")
				}
				g.P("return false")
				g.P("}")
			}
		}
	}
}
func messagecheck(prefix, fieldname string, islist bool, message *protogen.Message, g *protogen.GeneratedFile) {
	if islist {
		g.P("for _,v:=range ", prefix+fieldname, "{")
		g.P("if v==nil{")
		g.P("continue")
		g.P("}")
		g.P("if !_", service.GoName, "WebCheckers[", strconv.Quote(message.GoIdent.String()), "](v){")
		g.P("return false")
		g.P("}")
		g.P("}")
	} else {
		g.P("if ", prefix+fieldname, "!=nil{")
		g.P("if !_", service.GoName, "WebCheckers[", strconv.Quote(message.GoIdent.String()), "](", prefix+fieldname, "){")
		g.P("return false")
		g.P("}")
		g.P("}")
	}
}
func mapcheck(prefix, fieldname string, key, val *protogen.Field, fop *descriptorpb.FieldOptions, g *protogen.GeneratedFile) {
	keycheck := false
	valuecheck := false
	isbyteslice := false
	switch key.Desc.Kind() {
	case protoreflect.Int32Kind:
		fallthrough
	case protoreflect.Sint32Kind:
		fallthrough
	case protoreflect.Sfixed32Kind:
		fallthrough
	case protoreflect.Int64Kind:
		fallthrough
	case protoreflect.Sint64Kind:
		fallthrough
	case protoreflect.Sfixed64Kind:
		if proto.HasExtension(fop, pbex.E_MapKeyIntIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntNotIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntGt) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntGte) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntLt) ||
			proto.HasExtension(fop, pbex.E_MapKeyIntLte) {
			keycheck = true
		}
	case protoreflect.Uint32Kind:
		fallthrough
	case protoreflect.Fixed32Kind:
		fallthrough
	case protoreflect.Uint64Kind:
		fallthrough
	case protoreflect.Fixed64Kind:
		if proto.HasExtension(fop, pbex.E_MapKeyUintIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintNotIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintGt) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintGte) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintLt) ||
			proto.HasExtension(fop, pbex.E_MapKeyUintLte) {
			keycheck = true
		}
	case protoreflect.StringKind:
		if proto.HasExtension(fop, pbex.E_MapKeyStringIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringNotIn) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringRegMatch) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringRegNotMatch) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenEq) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenNotEq) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenGt) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenGte) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenLt) ||
			proto.HasExtension(fop, pbex.E_MapKeyStringLenLte) {
			keycheck = true
		}
	}
	switch val.Desc.Kind() {
	case protoreflect.EnumKind:
		valuecheck = true
	case protoreflect.BoolKind:
		if proto.HasExtension(fop, pbex.E_MapValueBoolEq) {
			valuecheck = true
		}
	case protoreflect.Int32Kind:
		fallthrough
	case protoreflect.Sint32Kind:
		fallthrough
	case protoreflect.Sfixed32Kind:
		fallthrough
	case protoreflect.Int64Kind:
		fallthrough
	case protoreflect.Sint64Kind:
		fallthrough
	case protoreflect.Sfixed64Kind:
		if proto.HasExtension(fop, pbex.E_MapValueIntIn) ||
			proto.HasExtension(fop, pbex.E_MapValueIntNotIn) ||
			proto.HasExtension(fop, pbex.E_MapValueIntGt) ||
			proto.HasExtension(fop, pbex.E_MapValueIntGte) ||
			proto.HasExtension(fop, pbex.E_MapValueIntLt) ||
			proto.HasExtension(fop, pbex.E_MapValueIntLte) {
			valuecheck = true
		}
	case protoreflect.Uint32Kind:
		fallthrough
	case protoreflect.Fixed32Kind:
		fallthrough
	case protoreflect.Uint64Kind:
		fallthrough
	case protoreflect.Fixed64Kind:
		if proto.HasExtension(fop, pbex.E_MapValueUintIn) ||
			proto.HasExtension(fop, pbex.E_MapValueUintNotIn) ||
			proto.HasExtension(fop, pbex.E_MapValueUintGt) ||
			proto.HasExtension(fop, pbex.E_MapValueUintGte) ||
			proto.HasExtension(fop, pbex.E_MapValueUintLt) ||
			proto.HasExtension(fop, pbex.E_MapValueUintLte) {
			valuecheck = true
		}
	case protoreflect.FloatKind:
		fallthrough
	case protoreflect.DoubleKind:
		if proto.HasExtension(fop, pbex.E_MapValueFloatIn) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatNotIn) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatGt) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatGte) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatLt) ||
			proto.HasExtension(fop, pbex.E_MapValueFloatLte) {
			valuecheck = true
		}
	case protoreflect.BytesKind:
		fallthrough
	case protoreflect.StringKind:
		if proto.HasExtension(fop, pbex.E_MapValueStringBytesIn) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesNotIn) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesRegMatch) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesRegNotMatch) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenEq) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenNotEq) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGt) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGte) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLt) ||
			proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLte) {
			valuecheck = true
		}
	case protoreflect.MessageKind:
		if _, ok := allcheck[val.Message.GoIdent.String()]; ok {
			valuecheck = true
		}
	}
	if keycheck && valuecheck {
		g.P("for k,v :=range ", prefix+fieldname, "{")
	} else if keycheck {
		g.P("for k :=range ", prefix+fieldname, "{")
	} else if valuecheck {
		g.P("for _,v :=range ", prefix+fieldname, "{")
	} else {
		return
	}
	if keycheck {
		switch key.Desc.Kind() {
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Sfixed32Kind:
			fallthrough
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Sfixed64Kind:
			if proto.HasExtension(fop, pbex.E_MapKeyIntIn) {
				keyin := proto.GetExtension(fop, pbex.E_MapKeyIntIn).([]int64)
				for _, v := range keyin {
					g.P("if k!=", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntNotIn) {
				keynotin := proto.GetExtension(fop, pbex.E_MapKeyIntNotIn).([]int64)
				for _, v := range keynotin {
					g.P("if k==", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntGt) {
				keygt := proto.GetExtension(fop, pbex.E_MapKeyIntGt).(int64)
				g.P("if k<=", keygt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntGte) {
				keygte := proto.GetExtension(fop, pbex.E_MapKeyIntGte).(int64)
				g.P("if k<", keygte, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntLt) {
				keylt := proto.GetExtension(fop, pbex.E_MapKeyIntLt).(int64)
				g.P("if k>=", keylt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyIntLte) {
				keylte := proto.GetExtension(fop, pbex.E_MapKeyIntLte).(int64)
				g.P("if k>", keylte, "{")
				g.P("return false")
				g.P("}")
			}
		case protoreflect.Uint32Kind:
			fallthrough
		case protoreflect.Fixed32Kind:
			fallthrough
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Fixed64Kind:
			if proto.HasExtension(fop, pbex.E_MapKeyUintIn) {
				keyin := proto.GetExtension(fop, pbex.E_MapKeyUintIn).([]uint64)
				for _, v := range keyin {
					g.P("if k!=", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintNotIn) {
				keynotin := proto.GetExtension(fop, pbex.E_MapKeyUintNotIn).([]uint64)
				for _, v := range keynotin {
					g.P("if k==", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintGt) {
				keygt := proto.GetExtension(fop, pbex.E_MapKeyUintGt).(uint64)
				g.P("if k<=", keygt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintGte) {
				keygte := proto.GetExtension(fop, pbex.E_MapKeyUintGte).(uint64)
				g.P("if k<", keygte, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintLt) {
				keylt := proto.GetExtension(fop, pbex.E_MapKeyUintLt).(uint64)
				g.P("if k>=", keylt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyUintLte) {
				keylte := proto.GetExtension(fop, pbex.E_MapKeyUintLte).(uint64)
				g.P("if k>", keylte, "{")
				g.P("return false")
				g.P("}")
			}
		case protoreflect.StringKind:
			if proto.HasExtension(fop, pbex.E_MapKeyStringIn) {
				keyin := proto.GetExtension(fop, pbex.E_MapKeyStringIn).([]string)
				for _, v := range keyin {
					g.P("if k!=", strconv.Quote(v), "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringNotIn) {
				keynotin := proto.GetExtension(fop, pbex.E_MapKeyStringNotIn).([]string)
				for _, v := range keynotin {
					g.P("if k==", strconv.Quote(v), "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringRegMatch) {
				keymatch := proto.GetExtension(fop, pbex.E_MapKeyStringRegMatch).([]string)
				for _, v := range keymatch {
					g.P("if !_", service.GoName, "WebRegs[", strconv.Quote(v), "].MatchString(k){")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringRegNotMatch) {
				keynotmatch := proto.GetExtension(fop, pbex.E_MapKeyStringRegNotMatch).([]string)
				for _, v := range keynotmatch {
					g.P("if _", service.GoName, "WebRegs[", strconv.Quote(v), "].MatchString(k){")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenEq) {
				keyleneq := proto.GetExtension(fop, pbex.E_MapKeyStringLenEq).(uint64)
				g.P("if len(k)!=", keyleneq, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenNotEq) {
				keylennoteq := proto.GetExtension(fop, pbex.E_MapKeyStringLenNotEq).(uint64)
				g.P("if len(k)==", keylennoteq, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenGt) {
				keylengt := proto.GetExtension(fop, pbex.E_MapKeyStringLenGt).(uint64)
				g.P("if len(k)<=", keylengt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenGte) {
				keylengte := proto.GetExtension(fop, pbex.E_MapKeyStringLenGte).(uint64)
				g.P("if len(k)<", keylengte, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenLt) {
				keylenlt := proto.GetExtension(fop, pbex.E_MapKeyStringLenLt).(uint64)
				g.P("if len(k)>=", keylenlt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapKeyStringLenLte) {
				keylenlte := proto.GetExtension(fop, pbex.E_MapKeyStringLenLte).(uint64)
				g.P("if len(k)>", keylenlte, "{")
				g.P("return false")
				g.P("}")
			}
		}
	}
	if valuecheck {
		switch val.Desc.Kind() {
		case protoreflect.EnumKind:
			g.P("if _,ok:=", g.QualifiedGoIdent(val.Enum.GoIdent), "_name[int32(v)];!ok{")
			g.P("return false")
			g.P("}")
		case protoreflect.BoolKind:
			if proto.HasExtension(fop, pbex.E_MapValueBoolEq) {
				valeq := proto.GetExtension(fop, pbex.E_MapValueBoolEq).(bool)
				g.P("if v!=", valeq, "{")
				g.P("return false")
				g.P("}")
			}
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Sfixed32Kind:
			fallthrough
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Sfixed64Kind:
			if proto.HasExtension(fop, pbex.E_MapValueIntIn) {
				valin := proto.GetExtension(fop, pbex.E_MapValueIntIn).([]int64)
				for _, v := range valin {
					g.P("if v!=", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntNotIn) {
				valnotin := proto.GetExtension(fop, pbex.E_MapValueIntNotIn).([]int64)
				for _, v := range valnotin {
					g.P("if v==", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntGt) {
				valgt := proto.GetExtension(fop, pbex.E_MapValueIntGt).(int64)
				g.P("if v<=", valgt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntGte) {
				valgte := proto.GetExtension(fop, pbex.E_MapValueIntGte).(int64)
				g.P("if v<", valgte, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntLt) {
				vallt := proto.GetExtension(fop, pbex.E_MapValueIntLt).(int64)
				g.P("if v>=", vallt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueIntLte) {
				vallte := proto.GetExtension(fop, pbex.E_MapValueIntLte).(int64)
				g.P("if v>", vallte, "{")
				g.P("return false")
				g.P("}")
			}
		case protoreflect.Uint32Kind:
			fallthrough
		case protoreflect.Fixed32Kind:
			fallthrough
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Fixed64Kind:
			if proto.HasExtension(fop, pbex.E_MapValueUintIn) {
				valin := proto.GetExtension(fop, pbex.E_MapValueUintIn).([]uint64)
				for _, v := range valin {
					g.P("if v!=", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintNotIn) {
				valnotin := proto.GetExtension(fop, pbex.E_MapValueUintNotIn).([]uint64)
				for _, v := range valnotin {
					g.P("if v==", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintGt) {
				valgt := proto.GetExtension(fop, pbex.E_MapValueUintGt).(uint64)
				g.P("if v<=", valgt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintGte) {
				valgte := proto.GetExtension(fop, pbex.E_MapValueUintGte).(uint64)
				g.P("if v<", valgte, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintLt) {
				vallt := proto.GetExtension(fop, pbex.E_MapValueUintLt).(uint64)
				g.P("if v>=", vallt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueUintLte) {
				vallte := proto.GetExtension(fop, pbex.E_MapValueUintLte).(uint64)
				g.P("if v>", vallte, "{")
				g.P("return false")
				g.P("}")
			}
		case protoreflect.FloatKind:
			fallthrough
		case protoreflect.DoubleKind:
			if proto.HasExtension(fop, pbex.E_MapValueFloatIn) {
				valin := proto.GetExtension(fop, pbex.E_MapValueFloatIn).([]float64)
				for _, v := range valin {
					g.P("if v!=", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatNotIn) {
				valnotin := proto.GetExtension(fop, pbex.E_MapValueFloatNotIn).([]float64)
				for _, v := range valnotin {
					g.P("if v==", v, "{")
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatGt) {
				valgt := proto.GetExtension(fop, pbex.E_MapValueFloatGt).(float64)
				g.P("if v<=", valgt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatGte) {
				valgte := proto.GetExtension(fop, pbex.E_MapValueFloatGte).(float64)
				g.P("if v<", valgte, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatLt) {
				vallt := proto.GetExtension(fop, pbex.E_MapValueFloatLt).(float64)
				g.P("if v>=", vallt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueFloatLte) {
				vallte := proto.GetExtension(fop, pbex.E_MapValueFloatLte).(float64)
				g.P("if v>", vallte, "{")
				g.P("return false")
				g.P("}")
			}
		case protoreflect.BytesKind:
			isbyteslice = true
			fallthrough
		case protoreflect.StringKind:
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesIn) {
				valin := proto.GetExtension(fop, pbex.E_MapValueStringBytesIn).([]string)
				for _, v := range valin {
					if isbyteslice {
						g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)!=", strconv.Quote(v), "{")
					} else {
						g.P("if v!=", strconv.Quote(v), "{")
					}
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesNotIn) {
				valnotin := proto.GetExtension(fop, pbex.E_MapValueStringBytesNotIn).([]string)
				for _, v := range valnotin {
					if isbyteslice {
						g.P("if ", g.QualifiedGoIdent(commonPackage.Ident("Byte2Str")), "(v)==", strconv.Quote(v), "{")
					} else {
						g.P("if v==", strconv.Quote(v), "{")
					}
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegMatch) {
				valmatch := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegMatch).([]string)
				for _, v := range valmatch {
					if isbyteslice {
						g.P("if !_", service.GoName, "WebRegs[", strconv.Quote(v), "].Match(v){")
					} else {
						g.P("if !_", service.GoName, "WebRegs[", strconv.Quote(v), "].MatchString(v){")
					}
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesRegNotMatch) {
				valnotmatch := proto.GetExtension(fop, pbex.E_MapValueStringBytesRegNotMatch).([]string)
				for _, v := range valnotmatch {
					if isbyteslice {
						g.P("if _", service.GoName, "WebRegs[", strconv.Quote(v), "].Match(v){")
					} else {
						g.P("if _", service.GoName, "WebRegs[", strconv.Quote(v), "].MatchString(v){")
					}
					g.P("return false")
					g.P("}")
				}
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenEq) {
				valleneq := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenEq).(uint64)
				g.P("if len(v)!=", valleneq, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenNotEq) {
				vallennoteq := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenNotEq).(uint64)
				g.P("if len(v)==", vallennoteq, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGt) {
				vallengt := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenGt).(uint64)
				g.P("if len(v)<=", vallengt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenGte) {
				vallengte := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenGte).(uint64)
				g.P("if len(v)<", vallengte, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLt) {
				vallenlt := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenLt).(uint64)
				g.P("if len(v)>=", vallenlt, "{")
				g.P("return false")
				g.P("}")
			}
			if proto.HasExtension(fop, pbex.E_MapValueStringBytesLenLte) {
				vallenlte := proto.GetExtension(fop, pbex.E_MapValueStringBytesLenLte).(uint64)
				g.P("if len(v)>", vallenlte, "{")
				g.P("return false")
				g.P("}")
			}
		case protoreflect.MessageKind:
			if _, ok := allcheck[val.Message.GoIdent.String()]; ok {
				g.P("if v==nil{")
				g.P("continue")
				g.P("}")
				g.P("if !_", service.GoName, "WebCheckers[", strconv.Quote(val.Message.GoIdent.String()), "](v){")
				g.P("return false")
				g.P("}")
			}
		}
	}
	g.P("}")
}
func genPath(file *protogen.File, g *protogen.GeneratedFile) {
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		pathname := "_WebPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		g.P("var ", pathname, "=", strconv.Quote(pathurl))
	}
	g.P()
}
func genServer(file *protogen.File, g *protogen.GeneratedFile) {
	// Server interface.
	serverName := service.GoName + "WebServer"

	g.P("type ", serverName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")), ",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*", g.QualifiedGoIdent(method.Output.GoIdent), ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	// Server handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		fname := "func _" + service.GoName + "_" + method.GoName + "_" + "WebHandler"
		p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		freturn := g.QualifiedGoIdent(webPackage.Ident("OutsideHandler"))
		g.P(fname, "(", p1, ")", freturn, "{")
		g.P("return func(ctx *"+g.QualifiedGoIdent(webPackage.Ident("Context")), "){")
		g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
		g.P("if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(ctx.GetContentType(),", strconv.Quote("application/json"), "){")
		g.P("data,e:=ctx.GetBody()")
		g.P("if e!=nil{")
		g.P("ctx.AbortString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",e.Error())")
		g.P("return")
		g.P("}")
		g.P("if len(data)>0{")
		g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "(data,req);e!=nil{")
		g.P("ctx.AbortString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",", g.QualifiedGoIdent(errorPackage.Ident("ErrReq")), ".String())")
		g.P("return")
		g.P("}")
		g.P("}")
		g.P("}else if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(ctx.GetContentType(),", strconv.Quote("application/x-protobuf"), "){")
		g.P("data,e:=ctx.GetBody()")
		g.P("if e!=nil{")
		g.P("ctx.AbortString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",e.Error())")
		g.P("return")
		g.P("}")
		g.P("if len(data)>0{")
		g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(data,req);e!=nil{")
		g.P("ctx.AbortString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",", g.QualifiedGoIdent(errorPackage.Ident("ErrReq")), ".String())")
		g.P("return")
		g.P("}")
		g.P("}")
		g.P("}else{")
		g.P("if e:=ctx.ParseForm();e!=nil{")
		g.P("ctx.AbortString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",", g.QualifiedGoIdent(errorPackage.Ident("ErrReq")), ".String())")
		g.P("return")
		g.P("}")
		g.P("data:=", g.QualifiedGoIdent(bufpoolPackage.Ident("GetBuffer()")))
		g.P("defer ", g.QualifiedGoIdent(bufpoolPackage.Ident("PutBuffer(data)")))
		g.P("data.Append(", strconv.Quote("{"), ")")
		for i, field := range method.Input.Fields {
			fname := string(field.Desc.Name())
			g.P("data.Append(", strconv.Quote(strconv.Quote(fname)+":"), ")")
			switch field.Desc.Kind() {
			case protoreflect.BoolKind:
				g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)==0{")
				if field.Desc.IsList() {
					g.P("data.Append(", strconv.Quote("null"), ")")
				} else {
					g.P("data.Append(", strconv.Quote("false"), ")")
				}
				g.P("}else{")
				g.P("data.Append(form)")
				g.P("}")
			case protoreflect.EnumKind:
				fallthrough
			case protoreflect.Int32Kind:
				fallthrough
			case protoreflect.Sint32Kind:
				fallthrough
			case protoreflect.Uint32Kind:
				fallthrough
			case protoreflect.Int64Kind:
				fallthrough
			case protoreflect.Sint64Kind:
				fallthrough
			case protoreflect.Uint64Kind:
				fallthrough
			case protoreflect.Sfixed32Kind:
				fallthrough
			case protoreflect.Fixed32Kind:
				fallthrough
			case protoreflect.FloatKind:
				fallthrough
			case protoreflect.Sfixed64Kind:
				fallthrough
			case protoreflect.Fixed64Kind:
				fallthrough
			case protoreflect.DoubleKind:
				g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)==0{")
				if field.Desc.IsList() {
					g.P("data.Append(", strconv.Quote("null"), ")")
				} else {
					g.P("data.Append(", strconv.Quote("0"), ")")
				}
				g.P("}else{")
				g.P("data.Append(form)")
				g.P("}")
			case protoreflect.StringKind:
				fallthrough
			case protoreflect.BytesKind:
				g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)==0{")
				if field.Desc.IsList() {
					g.P("data.Append(", strconv.Quote("null"), ")")
					g.P("}else{")
					g.P("data.Append(form)")
					g.P("}")
				} else {
					g.P("data.Append(", strconv.Quote("\"\""), ")")
					g.P("}else if len(form)<2 || form[0] !='\"' || form[len(form)-1]!='\"'{")
					g.P("data.Append(", strconv.Quote("\""), ")")
					g.P("data.Append(form)")
					g.P("data.Append(", strconv.Quote("\""), ")")
					g.P("}else{")
					g.P("data.Append(form)")
					g.P("}")
				}
			case protoreflect.MessageKind:
				g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)==0{")
				g.P("data.Append(", strconv.Quote("null"), ")")
				g.P("}else{")
				g.P("data.Append(form)")
				g.P("}")
			}
			if i != len(method.Input.Fields)-1 {
				g.P("data.Append(", strconv.Quote(","), ")")
			}
		}
		g.P("data.Append(", strconv.Quote("}"), ")")
		g.P("if data.Len()>2{")
		g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "(data.Bytes(),req);e!=nil{")
		g.P("ctx.AbortString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",", g.QualifiedGoIdent(errorPackage.Ident("ErrReq")), ".String())")
		g.P("return")
		g.P("}")
		g.P("}")
		g.P("}")

		//check
		if _, ok := allcheck[method.Input.GoIdent.String()]; ok {
			g.P("if !_", service.GoName, "WebCheckers[", strconv.Quote(method.Input.GoIdent.String()), "](req){")
			g.P("ctx.AbortString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",", g.QualifiedGoIdent(errorPackage.Ident("ErrReq")), ".String())")
			g.P("return")
			g.P("}")
		}

		g.P("resp,e:=handler(ctx,req)")
		g.P("if e!=nil{")
		g.P("if ", g.QualifiedGoIdent(errorPackage.Ident("Equal")), "(e,", g.QualifiedGoIdent(errorPackage.Ident("ErrReq")), "){")
		g.P("ctx.AbortString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",e.Error())")
		g.P("}else{")
		g.P("ctx.AbortString(", g.QualifiedGoIdent(httpPackage.Ident("StatusInternalServerError")), ",e.Error())")
		g.P("}")
		g.P("return")
		g.P("}")
		g.P("if resp == nil{")
		g.P("resp = new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("}")
		g.P("respd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(resp)")
		g.P("ctx.Write(", g.QualifiedGoIdent(httpPackage.Ident("StatusOK")), ",respd)")
		g.P("}")
		g.P("}")
	}

	//Server Register
	g.P("func Register", serverName, "(engine *", g.QualifiedGoIdent(webPackage.Ident("WebServer")), ",svc ", serverName, ",allmids map[string]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), ")error{")
	g.P("//avoid lint")
	g.P("_=allmids")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		var timeout time.Duration
		if proto.HasExtension(mop, pbex.E_Timeout) {
			timeoutstr := proto.GetExtension(mop, pbex.E_Timeout).(string)
			var e error
			if timeout, e = time.ParseDuration(timeoutstr); e != nil {
				panic(fmt.Sprintf("method: %s in service: %s with timeout: %s format error:%s", method.Desc.Name(), service.Desc.Name(), timeoutstr, e))
			}
		}
		var mids []string
		if proto.HasExtension(mop, pbex.E_Midwares) {
			mids = proto.GetExtension(mop, pbex.E_Midwares).([]string)
		}
		fname := "_" + service.GoName + "_" + method.GoName + "_" + "WebHandler(svc." + method.GoName + ")"
		pathname := "_WebPath" + service.GoName + method.GoName
		if len(mids) > 0 {
			g.P("{")
			str := ""
			for _, mid := range mids {
				str += ","
				str += strconv.Quote(mid)
			}
			str = str[1:]
			g.P("requiredMids:=[]string{", str, "}")
			g.P("mids:=make([]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), ",0,", len(mids)+1, ")")
			g.P("for _,v:=range requiredMids{")
			g.P("if mid,ok:=allmids[v];ok{")
			g.P("mids = append(mids,mid)")
			g.P("}else{")
			g.P("return ", g.QualifiedGoIdent(errorPackage.Ident("ErrNoMids")))
			g.P("}")
			g.P("}")
			g.P("mids = append(mids,", fname, ")")
			switch httpmetohd {
			case http.MethodGet:
				g.P("if e := engine.Get(", pathname, ",", timeout.Nanoseconds(), ",mids...);e!=nil{")
			case http.MethodDelete:
				g.P("if e := engine.Delete(", pathname, ",", timeout.Nanoseconds(), ",mids...);e!=nil{")
			case http.MethodPost:
				g.P("if e := engine.Post(", pathname, ",", timeout.Nanoseconds(), ",mids...);e!=nil{")
			case http.MethodPut:
				g.P("if e := engine.Put(", pathname, ",", timeout.Nanoseconds(), ",mids...);e!=nil{")
			case http.MethodPatch:
				g.P("if e := engine.Patch(", pathname, ",", timeout.Nanoseconds(), ",mids...);e!=nil{")
			}
			g.P("return e")
			g.P("}")
			g.P("}")
		} else {
			switch httpmetohd {
			case http.MethodGet:
				g.P("if e := engine.Get(", pathname, ",", timeout.Nanoseconds(), ",", fname, ");e!=nil{")
			case http.MethodDelete:
				g.P("if e := engine.Delete(", pathname, ",", timeout.Nanoseconds(), ",", fname, ");e!=nil{")
			case http.MethodPost:
				g.P("if e := engine.Post(", pathname, ",", timeout.Nanoseconds(), ",", fname, ");e!=nil{")
			case http.MethodPut:
				g.P("if e := engine.Put(", pathname, ",", timeout.Nanoseconds(), ",", fname, ");e!=nil{")
			case http.MethodPatch:
				g.P("if e := engine.Patch(", pathname, ",", timeout.Nanoseconds(), ",", fname, ");e!=nil{")
			}
			g.P("return e")
			g.P("}")
		}
	}
	g.P("return nil")
	g.P("}")
}

func genClient(file *protogen.File, g *protogen.GeneratedFile) {
	// Client interface.
	clientName := service.GoName + "WebClient"
	lowclientName := strings.ToLower(clientName[:1]) + clientName[1:]

	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")), ",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*", g.QualifiedGoIdent(method.Output.GoIdent), ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	g.P("type ", lowclientName, " struct{")
	g.P("cc *", g.QualifiedGoIdent(webPackage.Ident("WebClient")))
	g.P("}")
	g.P("func New", clientName, "(c *", g.QualifiedGoIdent(webPackage.Ident("ClientConfig")), ",selfgroup,selfname,peergroup,peername string)(", clientName, ",error){")
	g.P("cc,e:=", g.QualifiedGoIdent(webPackage.Ident("NewWebClient")), "(c,selfgroup,selfname,peergroup,peername)")
	g.P("if e != nil {")
	g.P("return nil, e")
	g.P("}")
	g.P("return &", lowclientName, "{cc:cc},nil")
	g.P("}")
	g.P()
	// Client handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		pathname := "_WebPath" + service.GoName + method.GoName
		p1 := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")", freturn, "{")
		g.P("if req == nil {")
		g.P("return nil,", g.QualifiedGoIdent(errorPackage.Ident("ErrReq")))
		g.P("}")

		//check
		if _, ok := allcheck[method.Input.GoIdent.String()]; ok {
			g.P("if !_", service.GoName, "WebCheckers[", strconv.Quote(method.Input.GoIdent.String()), "](req){")
			g.P("return nil,", g.QualifiedGoIdent(errorPackage.Ident("ErrReq")))
			g.P("}")
		}

		//TODO
		g.P("reqd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(req)")
		if proto.HasExtension(mop, pbex.E_Timeout) {
			var timeout time.Duration
			timeoutstr := proto.GetExtension(mop, pbex.E_Timeout).(string)
			if timeoutstr != "" {
				var e error
				timeout, e = time.ParseDuration(timeoutstr)
				if e != nil {
					panic(fmt.Sprintf("method: %s in service: %s with timeout: %s format error:%s", method.Desc.Name(), service.Desc.Name(), timeoutstr, e))
				}
			}
			g.P("respd,e:=c.cc.Call(ctx,", strconv.FormatInt(timeout.Nanoseconds(), 10), ",", pathname, ",reqd,", metadataPackage.Ident("GetAllMetadata"), "(ctx))")
		} else {
			g.P("respd,e:=c.cc.Call(ctx,0,", pathname, ",reqd,", metadataPackage.Ident("GetAllMetadata"), "(ctx))")
		}
		g.P("if e.(*", g.QualifiedGoIdent(errorPackage.Ident("Error")), ") != nil {")
		g.P("return nil,e")
		g.P("}")
		g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("if len(respd)==0{")
		g.P("return resp,nil")
		g.P("}")
		g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(respd,resp);e!=nil{")
		g.P("return nil,", g.QualifiedGoIdent(errorPackage.Ident("ErrResp")))
		g.P("}")
		g.P("return resp, nil")
		g.P("}")
	}
}

//func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
//        if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
//                return
//        }
//        countUndeprecatedMethod := 0
//        for _, method := range service.Methods {
//                if !method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
//                        countUndeprecatedMethod++
//                }
//        }
//        if countUndeprecatedMethod == 0 {
//                return
//        }
//        //Router path
//        for _, method := range service.Methods {
//                if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
//                        continue
//                }
//                pathname := "WebPath" + service.GoName + method.GoName
//                pathurl := "/" + *file.Proto.Package + "." + service.GoName + "/" + method.GoName
//                g.P("var ", pathname, "=", strconv.Quote(pathurl))
//        }

//        // Client interface.
//        clientName := service.GoName + "WebClient"
//        lowclientName := strings.ToLower(clientName[:1]) + clientName[1:]

//        g.P("// ", clientName, " is the client API for ", service.GoName, " service.")

//        g.P("type ", clientName, " interface {")
//        for _, method := range service.Methods {
//                if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
//                        continue
//                }
//                g.P(method.Comments.Leading,
//                        method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")),
//                        ",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*",
//                        g.QualifiedGoIdent(method.Output.GoIdent), ",error)")
//        }
//        g.P("}")
//        g.P()
//        g.P("type ", lowclientName, " struct{")
//        g.P("cc *", g.QualifiedGoIdent(webPackage.Ident("WebClient")))
//        g.P("}")
//        g.P("func New", clientName, "(c *", g.QualifiedGoIdent(webPackage.Ident("ClientConfig")), ",selfgroup,selfname string)(", clientName, ",error){")
//        g.P("cc,e:=", g.QualifiedGoIdent(webPackage.Ident("NewWebClient")), "(c,selfgroup,selfname,Group,Name)")
//        g.P("if e != nil{")
//        g.P("return nil,e")
//        g.P("}")
//        g.P("return &", lowclientName, "{cc:cc},nil")
//        g.P("}")
//        g.P()
//        // Client handler
//        for _, method := range service.Methods {
//                if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
//                        continue
//                }
//                pathname := "WebPath" + service.GoName + method.GoName
//                p1 := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
//                p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
//                freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
//                g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ")", freturn, "{")
//                g.P("if req == nil {")
//                g.P("return nil,", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"bad request:nil\")")
//                g.P("}")
//                r, e := parseMethodComment(string(method.Comments.Trailing))
//                if e != nil {
//                        panic(e)
//                }
//                if len(method.Input.Fields) > 0 && haschecker(method.Input) {
//                        checkerandheader("req.", method.Input, g, 1)
//                }
//                g.P("var header ", g.QualifiedGoIdent(httpPackage.Ident("Header")))
//                g.P("if realcrx,ok:=ctx.(*", g.QualifiedGoIdent(webPackage.Ident("Context")), ");ok{")
//                g.P("header = realcrx.GetHeaders()")
//                g.P("}")
//                g.P("if header == nil {")
//                g.P("header = make(", g.QualifiedGoIdent(httpPackage.Ident("Header")), ")")
//                g.P("}")
//                g.P("md:=", g.QualifiedGoIdent(metadataPackage.Ident("GetAllMetadata")), "(ctx)")
//                if r.method == http.MethodGet || r.method == http.MethodDelete {
//                        g.P("header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")")
//                        g.P("buf:=", g.QualifiedGoIdent(bufpoolPackage.Ident("GetBuffer")), "()")
//                        if len(method.Input.Fields) != 0 {
//                                for _, field := range method.Input.Fields {
//                                        switch field.Desc.Kind() {
//                                        case protoreflect.BoolKind:
//                                                //bool
//                                                fallthrough
//                                        case protoreflect.Int32Kind:
//                                                fallthrough
//                                        case protoreflect.Sint32Kind:
//                                                fallthrough
//                                        case protoreflect.Sfixed32Kind:
//                                                fallthrough
//                                        case protoreflect.EnumKind:
//                                                //int32
//                                                fallthrough
//                                        case protoreflect.Uint32Kind:
//                                                fallthrough
//                                        case protoreflect.Fixed32Kind:
//                                                //uint32
//                                                fallthrough
//                                        case protoreflect.Int64Kind:
//                                                fallthrough
//                                        case protoreflect.Sint64Kind:
//                                                fallthrough
//                                        case protoreflect.Sfixed64Kind:
//                                                //int64
//                                                fallthrough
//                                        case protoreflect.Uint64Kind:
//                                                fallthrough
//                                        case protoreflect.Fixed64Kind:
//                                                //uint64
//                                                fallthrough
//                                        case protoreflect.FloatKind:
//                                                fallthrough
//                                        case protoreflect.DoubleKind:
//                                                if field.Desc.IsList() {
//                                                        g.P("if len(req.", field.GoName, ")!=0{")
//                                                        g.P("buf.Append(\"&\")")
//                                                        g.P("buf.Append(\"", field.Desc.Name(), "\")")
//                                                        g.P("buf.Append(\"=\")")
//                                                        g.P("buf.Append(req.", field.GoName, ")")
//                                                        g.P("}")
//                                                } else {
//                                                        g.P("if req.", field.GoName, "!=0{")
//                                                        g.P("buf.Append(\"&\")")
//                                                        g.P("buf.Append(\"", field.Desc.Name(), "\")")
//                                                        g.P("buf.Append(\"=\")")
//                                                        g.P("buf.Append(req.", field.GoName, ")")
//                                                        g.P("}")
//                                                }
//                                        case protoreflect.BytesKind:
//                                                if field.Desc.IsList() {
//                                                        g.P("if len(req.", field.GoName, ")!=0{")
//                                                        g.P("buf.Append(\"&\")")
//                                                        g.P("buf.Append(\"", field.Desc.Name(), "\")")
//                                                        g.P("buf.Append(\"=[\")")
//                                                        g.P("for _,v:=range req.", field.GoName, "{")
//                                                        g.P("buf.Append(\"\\\"\")")
//                                                        g.P("buf.Append(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(v))")
//                                                        g.P("buf.Append(\"\\\",\")")
//                                                        g.P("}")
//                                                        g.P("buf.Bytes()[buf.Len()-1]=']'")
//                                                        g.P("}")
//                                                } else {
//                                                        g.P("if len(req.", field.GoName, ")!=0{")
//                                                        g.P("buf.Append(\"&\")")
//                                                        g.P("buf.Append(\"", field.Desc.Name(), "\")")
//                                                        g.P("buf.Append(\"=\\\"\")")
//                                                        g.P("buf.Append(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(req.", field.GoName, "))")
//                                                        g.P("buf.Append(\"\\\"\")")
//                                                        g.P("}")
//                                                }
//                                        case protoreflect.StringKind:
//                                                if field.Desc.IsList() {
//                                                        g.P("if len(req.", field.GoName, ")!=0{")
//                                                        g.P("buf.Append(\"&\")")
//                                                        g.P("buf.Append(\"", field.Desc.Name(), "\")")
//                                                        g.P("buf.Append(\"=[\")")
//                                                        g.P("for _,v:=range req.", field.GoName, "{")
//                                                        g.P("buf.Append(\"\\\"\")")
//                                                        g.P("buf.Append(v)")
//                                                        g.P("buf.Append(\"\\\",\")")
//                                                        g.P("}")
//                                                        g.P("buf.Bytes()[buf.Len()-1]=']'")
//                                                        g.P("}")
//                                                } else {
//                                                        g.P("if len(req.", field.GoName, ")!=0{")
//                                                        g.P("buf.Append(\"&\")")
//                                                        g.P("buf.Append(\"", field.Desc.Name(), "\")")
//                                                        g.P("buf.Append(\"=\\\"\")")
//                                                        g.P("buf.Append(req.", field.GoName, ")")
//                                                        g.P("buf.Append(\"\\\"\")")
//                                                        g.P("}")
//                                                }
//                                        case protoreflect.MessageKind:
//                                                if field.Desc.IsList() || field.Desc.IsMap() {
//                                                        //message list or map
//                                                        g.P("if len(req.", field.GoName, ")!=0{")
//                                                        g.P("buf.Append(\"&\")")
//                                                        g.P("buf.Append(\"", field.Desc.Name(), "\")")
//                                                        g.P("buf.Append(\"=\")")
//                                                        g.P("d,_:=", g.QualifiedGoIdent(jsonPackage.Ident("Marshal")), "(req.", field.GoName, ")")
//                                                        g.P("buf.Append(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(d))")
//                                                        g.P("}")
//                                                } else {
//                                                        //message
//                                                        g.P("if req.", field.GoName, "!=nil{")
//                                                        g.P("buf.Append(\"&\")")
//                                                        g.P("buf.Append(\"", field.Desc.Name(), "\")")
//                                                        g.P("buf.Append(\"=\")")
//                                                        g.P("d,_:=", g.QualifiedGoIdent(jsonPackage.Ident("Marshal")), "(req.", field.GoName, ")")
//                                                        g.P("buf.Append(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(d))")
//                                                        g.P("}")
//                                                }
//                                        default:
//                                                panic("unknown field type")
//                                        }
//                                }
//                        }
//                        g.P("if buf.Len()>0{")
//                        g.P("buf.Bytes()[0]='?'")
//                        g.P("}")
//                        switch r.method {
//                        case http.MethodGet:
//                                g.P("callback,e:=c.cc.Get(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, "+buf.String(),header,md)")
//                        case http.MethodDelete:
//                                g.P("callback,e:=c.cc.Delete(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, "+buf.String(),header,md)")
//                        }
//                        g.P(g.QualifiedGoIdent(bufpoolPackage.Ident("PutBuffer")), "(buf)")
//                } else {
//                        g.P("header.Set(\"Content-Type\", \"application/json\")")
//                        g.P("reqdata,_:=", g.QualifiedGoIdent(jsonPackage.Ident("Marshal")), "(req)")
//                        switch r.method {
//                        case http.MethodPost:
//                                g.P("callback,e:=c.cc.Post(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, ",header,md,reqdata)")
//                        case http.MethodPut:
//                                g.P("callback,e:=c.cc.Put(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, "header,md,reqdata)")
//                        case http.MethodPatch:
//                                g.P("callback,e:=c.cc.Patch(ctx,", strconv.FormatInt(int64(r.timeout), 10), ",", pathname, "header,md,reqdata)")
//                        }
//                }
//                g.P("if e != nil {")
//                g.P("return nil, ", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"call error:\"+e.Error())")
//                g.P("}")
//                g.P("defer callback.Body.Close()")
//                g.P("data, e := ", g.QualifiedGoIdent(ioPackage.Ident("ReadAll")), "(callback.Body)")
//                g.P("if e != nil {")
//                g.P("return nil, ", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"read response error:\"+e.Error())")
//                g.P("}")
//                g.P("if callback.StatusCode/100 == 5 || callback.StatusCode/100 == 4{")
//                g.P("return nil, ", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(", g.QualifiedGoIdent(commonPackage.Ident("Byte2str")), "(data))")
//                g.P("}")
//                g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
//                g.P("if len(data) > 0 {")
//                g.P("if e = ", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "(data, resp); e != nil {")
//                g.P("return nil, ", g.QualifiedGoIdent(fmtPackage.Ident("Errorf")), "(\"response data format errors\"+e.Error())")
//                g.P("}")
//                g.P("}")
//                g.P("return resp, nil")
//                g.P("}")
//        }

//        // Server interface.
//        serverName := service.GoName + "WebServer"

//        g.P("// ", serverName, " is the server API for ", service.GoName, " service.")
//        g.P("type ", serverName, " interface {")
//        for _, method := range service.Methods {
//                if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
//                        continue
//                }
//                g.P(method.Comments.Leading,
//                        method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")),
//                        ",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*",
//                        g.QualifiedGoIdent(method.Output.GoIdent), ",error)")
//        }
//        g.P("}")
//        g.P()

//        // Server handler
//        for _, method := range service.Methods {
//                if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
//                        continue
//                }
//                fname := "func _" + service.GoName + "_" + method.GoName + "_WebHandler"
//                p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
//                freturn := g.QualifiedGoIdent(webPackage.Ident("OutsideHandler"))
//                g.P(fname, "(", p1, ")", freturn, "{")
//                g.P("return func(ctx *" + g.QualifiedGoIdent(webPackage.Ident("Context")) + "){")
//                g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
//                g.P("if ctx.GetMethod()!=", g.QualifiedGoIdent(httpPackage.Ident("MethodGet")), " && ctx.GetContentType() == \"application/json\" {")
//                g.P("data, e := ctx.GetBody()")
//                g.P("if e != nil {")
//                g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusInternalServerError")), ",\"server error:read request body error:\"+e.Error())")
//                g.P("return")
//                g.P("}")
//                g.P("if len(data) != 0 {")
//                g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "(data,req);e!=nil{")
//                g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:json format error:\"+e.Error())")
//                g.P("return")
//                g.P("}")
//                g.P("}")
//                g.P("} else {")
//                g.P("if e := ctx.ParseForm(); e != nil {")
//                g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:form format error:\"+e.Error())")
//                g.P("return")
//                g.P("}")
//                g.P("buf:=", g.QualifiedGoIdent(bufpoolPackage.Ident("GetBuffer()")))
//                g.P("buf.Append(\"{\")")
//                g.P("hasfields:=false")
//                for _, field := range method.Input.Fields {
//                        g.P("if temp:=ctx.GetForm(\"", field.Desc.Name(), "\");len(temp)!=0 {")
//                        g.P("buf.Append(\"\\\"", field.Desc.Name(), "\\\":\")")
//                        g.P("buf.Append(temp)")
//                        g.P("buf.Append(\",\")")
//                        g.P("hasfields=true")
//                        g.P("}")
//                }
//                g.P("if hasfields{")
//                g.P("buf.Bytes()[buf.Len()-1]='}'")
//                g.P("}else{")
//                g.P("buf.Append(\"}\")")
//                g.P("}")
//                g.P("if buf.Len()>2{")
//                g.P("if e:=", g.QualifiedGoIdent(jsonPackage.Ident("Unmarshal")), "(buf.Bytes(),req);e!=nil{")
//                g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusBadRequest")), ",\"bad request:form format error:\"+e.Error())")
//                g.P("return")
//                g.P("}")
//                g.P("}")
//                g.P(g.QualifiedGoIdent(bufpoolPackage.Ident("PutBuffer(buf)")))
//                g.P("}")
//                if hasheader(method.Input) || haschecker(method.Input) {
//                        checkerandheader("req.", method.Input, g, 2)
//                }
//                g.P("resp,e:=handler(ctx,req)")
//                g.P("if e!=nil{")
//                g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusInternalServerError")), ",e.Error())")
//                g.P("}else if resp == nil{")
//                g.P("ctx.WriteString(", g.QualifiedGoIdent(httpPackage.Ident("StatusOK")), ",\"{}\")")
//                g.P("}else{")
//                g.P("respd,_:=", g.QualifiedGoIdent(jsonPackage.Ident("Marshal")), "(resp)")
//                g.P("ctx.Write(", g.QualifiedGoIdent(httpPackage.Ident("StatusOK")), ",respd)")
//                g.P("}")
//                g.P("}")
//                g.P("}")
//        }

//        //Server Register
//        g.P("func Register", serverName, "(engine *", g.QualifiedGoIdent(webPackage.Ident("WebServer")), ",svc ", serverName, ",allmids map[string]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), ")error{")
//        g.P("//avoid lint")
//        g.P("_=allmids")
//        for _, method := range service.Methods {
//                if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
//                        continue
//                }
//                r, e := parseMethodComment(string(method.Comments.Trailing))
//                if e != nil {
//                        panic(e)
//                }
//                fname := "_" + service.GoName + "_" + method.GoName + "_WebHandler(svc." + method.GoName + ")"
//                pathname := "WebPath" + service.GoName + method.GoName
//                if len(r.mids) > 0 {
//                        g.P("{")
//                        str := ""
//                        for _, mid := range r.mids {
//                                str += ","
//                                str += strconv.Quote(mid)
//                        }
//                        str = str[1:]
//                        g.P("requiredMids:=[]string{", str, "}")
//                        g.P("mids:=make([]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), ",0)")
//                        g.P("for _,v:=range requiredMids{")
//                        g.P("if mid,ok:=allmids[v];ok{")
//                        g.P("mids = append(mids,mid)")
//                        g.P("}")
//                        g.P("}")
//                        g.P("mids = append(mids,", fname, ")")
//                        switch r.method {
//                        case http.MethodGet:
//                                g.P("if e:=engine.Get(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        case http.MethodPost:
//                                g.P("if e:=engine.Post(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        case http.MethodPut:
//                                g.P("if e:=engine.Put(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        case http.MethodPatch:
//                                g.P("if e:=engine.Patch(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        case http.MethodDelete:
//                                g.P("if e:=engine.Delete(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",mids...);e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        }
//                        g.P("}")
//                } else {
//                        switch r.method {
//                        case http.MethodGet:
//                                g.P("if e:=engine.Get(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        case http.MethodPost:
//                                g.P("if e:=engine.Post(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        case http.MethodPut:
//                                g.P("if e:=engine.Put(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        case http.MethodPatch:
//                                g.P("if e:=engine.Patch(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        case http.MethodDelete:
//                                g.P("if e:=engine.Delete(", pathname, ",", strconv.FormatInt(int64(r.timeout), 10), ",", fname, ");e!=nil{")
//                                g.P("return e")
//                                g.P("}")
//                        }
//                }
//        }
//        g.P("return nil")
//        g.P("}")
//}
