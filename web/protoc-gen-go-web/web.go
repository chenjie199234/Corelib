package main

import (
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/chenjie199234/Corelib/internal/version"
	"github.com/chenjie199234/Corelib/pbex"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	stringsPackage   = protogen.GoImportPath("strings")
	urlPackage       = protogen.GoImportPath("net/url")
	httpPackage      = protogen.GoImportPath("net/http")
	ioPackage        = protogen.GoImportPath("io")
	contextPackage   = protogen.GoImportPath("context")
	base64Package    = protogen.GoImportPath("encoding/base64")
	stdjsonPackage   = protogen.GoImportPath("encoding/json")
	strconvPackage   = protogen.GoImportPath("strconv")
	protoPackage     = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protojsonPackage = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	webPackage       = protogen.GoImportPath("github.com/chenjie199234/Corelib/web")
	commonPackage    = protogen.GoImportPath("github.com/chenjie199234/Corelib/util/common")
	metadataPackage  = protogen.GoImportPath("github.com/chenjie199234/Corelib/metadata")
	poolPackage      = protogen.GoImportPath("github.com/chenjie199234/Corelib/pool")
	cerrorPackage    = protogen.GoImportPath("github.com/chenjie199234/Corelib/cerror")
	logPackage       = protogen.GoImportPath("github.com/chenjie199234/Corelib/log")
)

// generateFile generates a _web.pb.go file containing web service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_web.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		genService(file, service, g)
	}
	return g
}
func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-go-web. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-go-web ", version.String(), "<br />")
	g.P("// \tprotoc            ", protocVersion, "<br />")
	g.P("// source: ", file.Desc.Path(), "<br />")
	g.P()
}

func genService(file *protogen.File, s *protogen.Service, g *protogen.GeneratedFile) {
	genPath(file, s, g)
	genClient(file, s, g)
	genServer(file, s, g)
}

func genPath(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		pathname := "_WebPath" + service.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		g.P("var ", pathname, "=", strconv.Quote(pathurl))
	}
	g.P()
}

func genServer(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Server interface.
	serverName := service.GoName + "WebServer"

	g.P("type ", serverName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		g.P(method.Comments.Leading,
			method.GoName, "(", g.QualifiedGoIdent(contextPackage.Ident("Context")), ",*", g.QualifiedGoIdent(method.Input.GoIdent), ")(*", g.QualifiedGoIdent(method.Output.GoIdent), ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	// Server handler
	for _, method := range service.Methods {
		pathurl := "/" + *file.Proto.Package + "." + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
		simplefields := true
		for _, f := range method.Input.Fields {
			if f.Desc.Kind() == protoreflect.MessageKind {
				simplefields = false
				break
			}
		}
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		fname := "func _" + service.GoName + "_" + method.GoName + "_" + "WebHandler"
		p1 := "handler func (" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ",*" + g.QualifiedGoIdent(method.Input.GoIdent) + ")(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		freturn := g.QualifiedGoIdent(webPackage.Ident("OutsideHandler"))
		g.P(fname, "(", p1, ")", freturn, "{")
		g.P("return func(ctx *", g.QualifiedGoIdent(webPackage.Ident("Context")), "){")
		g.P("req:=new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
		if len(method.Input.Fields) > 0 {
			if httpmetohd == http.MethodPost || httpmetohd == http.MethodPut || httpmetohd == http.MethodPatch {
				g.P("if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(ctx.GetContentType(),", strconv.Quote("application/json"), "){")
				g.P("data, e := ctx.GetBody()")
				g.P("if e!=nil{")
				g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] get body failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
				g.P("ctx.Abort(e)")
				g.P("return")
				g.P("}")
				g.P("if len(data)>0{")
				g.P("if e := (", g.QualifiedGoIdent(protojsonPackage.Ident("UnmarshalOptions")), "{AllowPartial: true,DiscardUnknown: true}).Unmarshal(data,req);e!=nil{")
				g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] unmarshal json body failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
				g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
				g.P("return")
				g.P("}")
				g.P("}")
				g.P("}else if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(ctx.GetContentType(),", strconv.Quote("application/x-protobuf"), "){")
				g.P("data, e := ctx.GetBody()")
				g.P("if e!=nil{")
				g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] get body failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
				g.P("ctx.Abort(e)")
				g.P("return")
				g.P("}")
				g.P("if len(data)>0{")
				g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(data,req);e!=nil{")
				g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] unmarshal proto body failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
				g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
				g.P("return")
				g.P("}")
				g.P("}")
				g.P("}else{")
			}
			if !simplefields {
				g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] request message contain nested message or map,Content-Type must be application/json or application/x-protobuf\")")
				g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
				g.P("return")
			} else {
				g.P("if e:=ctx.ParseForm();e!=nil{")
				g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] parse form failed\",", g.QualifiedGoIdent(logPackage.Ident("CError")), "(e))")
				g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
				g.P("return")
				g.P("}")
				oneof := make(map[string]*struct{})
				for _, field := range method.Input.Fields {
					if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						if _, ok := oneof[field.Oneof.GoIdent.String()]; !ok {
							oneof[field.Oneof.GoIdent.String()] = nil
							g.P("//req.", field.Oneof.GoName)
							g.P("oneof", field.Oneof.GoName, ":=false")
						}
						g.P("//req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ")")
					} else {
						g.P("//req.", field.GoName)
					}
					fname := string(field.Desc.Name())
					switch field.Desc.Kind() {
					case protoreflect.BoolKind:
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=make([]bool,0,len(forms))")
							g.P("for _,form:=range forms{")
							g.P("if form == ", strconv.Quote("true"), "{")
							g.P("req.", field.GoName, "= append(req.", field.GoName, ",true)")
							g.P("}else if form == ", strconv.Quote("false"), "{")
							g.P("req.", field.GoName, "= append(req.", field.GoName, ",false)")
							g.P("}else{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}")
							g.P("}")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form!=", strconv.Quote("null"), "{")
							}
							g.P("if form==", strconv.Quote("true"), "{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{true}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("tmp:=true")
								g.P("req.", field.GoName, "=&tmp")
							} else {
								g.P("req.", field.GoName, "=true")
							}
							g.P("}else if form==", strconv.Quote("false"), "{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{false}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("tmp:=false")
								g.P("req.", field.GoName, "=&tmp")
							} else {
								g.P("req.", field.GoName, "=false")
							}
							g.P("}else{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}")
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.EnumKind:
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=make([]", g.QualifiedGoIdent(field.Enum.GoIdent), ",0,len(forms))")
							g.P("for _,form:=range forms{")
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseInt")), "(form,10,32);e!=nil || num < 0{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							g.P("req.", field.GoName, "=append(req.", field.GoName, ",", g.QualifiedGoIdent(field.Enum.GoIdent), "(num))")
							g.P("}")
							g.P("}")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form != ", strconv.Quote("null"), "{")
							}
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseInt")), "(form,10,32);e!=nil || num < 0{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("tmp:=", g.QualifiedGoIdent(field.Enum.GoIdent), "(num)")
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{tmp}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("tmp:=", g.QualifiedGoIdent(field.Enum.GoIdent), "(num)")
								g.P("req.", field.GoName, "=&tmp")
							} else {
								g.P("req.", field.GoName, "=", g.QualifiedGoIdent(field.Enum.GoIdent), "(num)")
							}
							g.P("}")
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.Sint32Kind:
						fallthrough
					case protoreflect.Sfixed32Kind:
						fallthrough
					case protoreflect.Int32Kind:
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=make([]int32,0,len(forms))")
							g.P("for _,form:=range forms{")
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseInt")), "(form,10,32);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							g.P("req.", field.GoName, "=append(req.", field.GoName, ",int32(num))")
							g.P("}")
							g.P("}")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form != ", strconv.Quote("null"), "{")
							}
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseInt")), "(form,10,32);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{int32(num)}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("tmp:=int32(num)")
								g.P("req.", field.GoName, "=&tmp")
							} else {
								g.P("req.", field.GoName, "=int32(num)")
							}
							g.P("}")
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.Fixed32Kind:
						fallthrough
					case protoreflect.Uint32Kind:
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=make([]uint32,0,len(forms))")
							g.P("for _,form:=range forms{")
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseUint")), "(form,10,32);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							g.P("req.", field.GoName, "=append(req.", field.GoName, ",uint32(num))")
							g.P("}")
							g.P("}")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form != ", strconv.Quote("null"), "{")
							}
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseUint")), "(form,10,32);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{uint32(num)}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("tmp:=uint32(num)")
								g.P("req.", field.GoName, "=&tmp")
							} else {
								g.P("req.", field.GoName, "=uint32(num)")
							}
							g.P("}")
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.Sfixed64Kind:
						fallthrough
					case protoreflect.Int64Kind:
						fallthrough
					case protoreflect.Sint64Kind:
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=make([]int64,0,len(forms))")
							g.P("for _,form:=range forms{")
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseInt")), "(form,10,64);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							g.P("req.", field.GoName, "=append(req.", field.GoName, ",num)")
							g.P("}")
							g.P("}")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form != ", strconv.Quote("null"), "{")
							}
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseInt")), "(form,10,64);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{num}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("req.", field.GoName, "=&num")
							} else {
								g.P("req.", field.GoName, "=num")
							}
							g.P("}")
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.Fixed64Kind:
						fallthrough
					case protoreflect.Uint64Kind:
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=make([]uint64,0,len(forms))")
							g.P("for _,form:=range forms{")
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseUint")), "(form,10,64);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							g.P("req.", field.GoName, "=append(req.", field.GoName, ",num)")
							g.P("}")
							g.P("}")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form != ", strconv.Quote("null"), "{")
							}
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseUint")), "(form,10,64);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{num}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("req.", field.GoName, "=&num")
							} else {
								g.P("req.", field.GoName, "=num")
							}
							g.P("}")
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.FloatKind:
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=make([]float32,0,len(forms))")
							g.P("for _,form:=range forms{")
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseFloat")), "(form,32);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							g.P("req.", field.GoName, "=append(req.", field.GoName, ",float32(num))")
							g.P("}")
							g.P("}")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form != ", strconv.Quote("null"), "{")
							}
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseFloat")), "(form,32);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{float32(num)}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("tmp:=float32(num)")
								g.P("req.", field.GoName, "=&tmp")
							} else {
								g.P("req.", field.GoName, "=float32(num)")
							}
							g.P("}")
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.DoubleKind:
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=make([]float64,0,len(forms))")
							g.P("for _,form:=range forms{")
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseFloat")), "(form,64);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							g.P("req.", field.GoName, "=append(req.", field.GoName, ",num)")
							g.P("}")
							g.P("}")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form != ", strconv.Quote("null"), "{")
							}
							g.P("if num,e:=", g.QualifiedGoIdent(strconvPackage.Ident("ParseFloat")), "(form,64);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{num}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("req.", field.GoName, "=&num")
							} else {
								g.P("req.", field.GoName, "=num")
							}
							g.P("}")
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.BytesKind:
						g.P("//req.", field.GoName, "'s type in protobuf is bytes,value should be standard base64 encoded")
						g.P("//https://developers.google.com/protocol-buffers/docs/proto3#json")
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=make([][]byte,0,len(forms))")
							g.P("for _,form:=range forms{")
							g.P("if str,e:=", base64Package.Ident("StdEncoding.DecodeString"), "(form);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							g.P("req.", field.GoName, "=append(req.", field.GoName, ",str)")
							g.P("}")
							g.P("}")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form != ", strconv.Quote("null"), "{")
							}
							g.P("if str,e:=", base64Package.Ident("StdEncoding.DecodeString"), "(form);e!=nil{")
							g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] data format wrong\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(", strconv.Quote("field"), ",", strconv.Quote(fname), "))")
							g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
							g.P("return")
							g.P("}else{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{str}")
							} else {
								g.P("req.", field.GoName, "=str")
							}
							g.P("}")
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.StringKind:
						if field.Desc.IsList() {
							g.P("if forms:=ctx.GetForms(", strconv.Quote(fname), ");len(forms)>0{")
							g.P("req.", field.GoName, "=forms")
							g.P("}")
						} else {
							g.P("if form:=ctx.GetForm(", strconv.Quote(fname), ");len(form)!=0{")
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("if oneof", field.Oneof.GoName, "{")
								g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] oneof field conflict\")")
								g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
								g.P("return")
								g.P("}")
								g.P("oneof", field.Oneof.GoName, "=true")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("if form != ", strconv.Quote("null"), "{")
							}
							if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
								g.P("req.", field.Oneof.GoName, "=&", g.QualifiedGoIdent(field.GoIdent), "{form}")
							} else if field.Desc.HasOptionalKeyword() {
								g.P("req.", field.GoName, "=&form")
							} else {
								g.P("req.", field.GoName, "=form")
							}
							if field.Desc.HasOptionalKeyword() {
								g.P("}")
							}
							g.P("}")
						}
					case protoreflect.MessageKind:
						panic(fmt.Sprintf("method: %s in service: %s with httpmetohd: %s,it's request message can't contain nested message and map", method.Desc.Name(), service.Desc.Name(), httpmetohd))
					}
				}
			}
			if httpmetohd == http.MethodPost || httpmetohd == http.MethodPut || httpmetohd == http.MethodPatch {
				g.P("}")
			}
		}

		//check
		if pbex.NeedValidate(method.Input) {
			g.P("if errstr := req.Validate(); errstr != \"\"{")
			g.P(g.QualifiedGoIdent(logPackage.Ident("Error")), "(ctx,\"[", pathurl, "] validate failed\",", g.QualifiedGoIdent(logPackage.Ident("String")), "(\"validate\",errstr))")
			g.P("ctx.Abort(", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")), ")")
			g.P("return")
			g.P("}")
		}

		g.P("resp,e:=handler(ctx,req)")
		g.P("ee := ", g.QualifiedGoIdent(cerrorPackage.Ident("ConvertStdError")), "(e)")
		g.P("if ee!=nil{")
		g.P("ctx.Abort(ee)")
		g.P("return")
		g.P("}")
		g.P("if resp == nil{")
		g.P("resp = new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("}")
		g.P("if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(ctx.GetAcceptType(),", strconv.Quote("application/x-protobuf"), "){")
		g.P("respd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(resp)")
		g.P("ctx.Write(\"application/x-protobuf\",respd)")
		g.P("}else{")
		g.P("respd,_:=", g.QualifiedGoIdent(protojsonPackage.Ident("MarshalOptions")), "{AllowPartial: true,UseProtoNames: true, UseEnumNumbers: true, EmitUnpopulated: true}.Marshal(resp)")
		g.P("ctx.Write(\"application/json\",respd)")
		g.P("}")
		g.P("}")
		g.P("}")
	}

	//Server Register
	g.P("func Register", serverName, "(router *", g.QualifiedGoIdent(webPackage.Ident("Router")), ",svc ", serverName, ",allmids map[string]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), "){")
	g.P("//avoid lint")
	g.P("_=allmids")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		var mids []string
		if proto.HasExtension(mop, pbex.E_WebMidwares) {
			mids = proto.GetExtension(mop, pbex.E_WebMidwares).([]string)
		}
		fname := "_" + service.GoName + "_" + method.GoName + "_" + "WebHandler(svc." + method.GoName + ")"
		pathname := "_WebPath" + service.GoName + method.GoName
		if len(mids) > 0 {
			g.P("{")
			str := ""
			for _, mid := range mids {
				str += ","
				str += strconv.Quote(mid)
			}
			str = str[1:]
			g.P("requiredMids:=[]string{", str, "}")
			g.P("mids:=make([]", g.QualifiedGoIdent(webPackage.Ident("OutsideHandler")), ",0,", len(mids)+1, ")")
			g.P("for _,v:=range requiredMids{")
			g.P("if mid,ok:=allmids[v];ok{")
			g.P("mids = append(mids,mid)")
			g.P("}else{")
			g.P("panic(\"missing midware:\"+v)")
			g.P("}")
			g.P("}")
			g.P("mids = append(mids,", fname, ")")
			switch httpmetohd {
			case http.MethodGet:
				g.P("router.Get(", pathname, ",mids...)")
			case http.MethodDelete:
				g.P("router.Delete(", pathname, ",mids...)")
			case http.MethodPost:
				g.P("router.Post(", pathname, ",mids...)")
			case http.MethodPut:
				g.P("router.Put(", pathname, ",mids...)")
			case http.MethodPatch:
				g.P("router.Patch(", pathname, ",mids...)")
			}
			g.P("}")
		} else {
			switch httpmetohd {
			case http.MethodGet:
				g.P("router.Get(", pathname, ",", fname, ")")
			case http.MethodDelete:
				g.P("router.Delete(", pathname, ",", fname, ")")
			case http.MethodPost:
				g.P("router.Post(", pathname, ",", fname, ")")
			case http.MethodPut:
				g.P("router.Put(", pathname, ",", fname, ")")
			case http.MethodPatch:
				g.P("router.Patch(", pathname, ",", fname, ")")
			}
		}
	}
	g.P("}")
}

func genClient(file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	// Client interface.
	clientName := service.GoName + "WebClient"
	lowclientName := strings.ToLower(clientName[:1]) + clientName[1:]

	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		p1 := g.QualifiedGoIdent(contextPackage.Ident("Context"))
		p2 := g.QualifiedGoIdent(method.Input.GoIdent)
		p3 := g.QualifiedGoIdent(httpPackage.Ident("Header"))
		r := g.QualifiedGoIdent(method.Output.GoIdent)
		g.P(method.Comments.Leading,
			method.GoName, "(", p1, ",*", p2, ",", p3, ")(*", r, ",error)",
			method.Comments.Trailing)
	}
	g.P("}")
	g.P()
	g.P("type ", lowclientName, " struct{")
	g.P("cc *", g.QualifiedGoIdent(webPackage.Ident("WebClient")))
	g.P("}")
	g.P("func New", clientName, "(c *", g.QualifiedGoIdent(webPackage.Ident("WebClient")), ")(", clientName, "){")
	g.P("return &", lowclientName, "{cc:c}")
	g.P("}")
	g.P()
	// Client handler
	for _, method := range service.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", method.Desc.Name(), service.Desc.Name(), httpmetohd))
		}
		pathname := "_WebPath" + service.GoName + method.GoName
		p1 := "ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
		p2 := "req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		p3 := "header " + g.QualifiedGoIdent(httpPackage.Ident("Header"))
		freturn := "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ",error)"
		g.P("func (c *", lowclientName, ")", method.GoName, "(", p1, ",", p2, ",", p3, ")", freturn, "{")
		g.P("if req == nil {")
		g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrReq")))
		g.P("}")

		g.P("if header == nil {")
		g.P("header = make(", g.QualifiedGoIdent(httpPackage.Ident("Header")), ")")
		g.P("}")

		if httpmetohd == http.MethodGet || httpmetohd == http.MethodDelete {
			g.P("header.Set(", strconv.Quote("Content-Type"), ",", strconv.Quote("application/x-www-form-urlencoded"), ")")
			g.P("header.Set(", strconv.Quote("Accept"), ",", strconv.Quote("application/x-protobuf"), ")")
			g.P("query :=", g.QualifiedGoIdent(poolPackage.Ident("GetPool")), "().Get(0)")
			g.P("defer ", g.QualifiedGoIdent(poolPackage.Ident("GetPool")), "().Put(&query)")
			for _, field := range method.Input.Fields {
				if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
					g.P("//req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ")")
				} else {
					g.P("//req.", field.GoName)
				}
				fname := string(field.Desc.Name())
				switch field.Desc.Kind() {
				case protoreflect.BoolKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+7)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendBool")), "(query,v)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+7)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendBool")), "(query,x.", field.GoName, ")")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						}
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+7)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendBool")), "(query,req.Get", field.GoName, "())")
						g.P("query=append(query,'&')")
						if field.Desc.HasOptionalKeyword() {
							g.P("}")
						}
					}
				case protoreflect.EnumKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(v),10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(x.", field.GoName, "),10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						}
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(req.Get", field.GoName, "()),10)")
						g.P("query=append(query,'&')")
						if field.Desc.HasOptionalKeyword() {
							g.P("}")
						}
					}
				case protoreflect.Sfixed32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Int32Kind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+12)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(v),10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+12)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(x.", field.GoName, "),10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						}
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+12)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,int64(req.Get", field.GoName, "()),10)")
						g.P("query=append(query,'&')")
						if field.Desc.HasOptionalKeyword() {
							g.P("}")
						}
					}
				case protoreflect.Sfixed64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Int64Kind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,v,10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,x.", field.GoName, ",10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						}
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendInt")), "(query,req.Get", field.GoName, "(),10)")
						g.P("query=append(query,'&')")
						if field.Desc.HasOptionalKeyword() {
							g.P("}")
						}
					}
				case protoreflect.Fixed32Kind:
					fallthrough
				case protoreflect.Uint32Kind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,uint64(v),10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,uint64(x.", field.GoName, "),10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						}
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+11)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,uint64(req.Get", field.GoName, "()),10)")
						g.P("query=append(query,'&')")
						if field.Desc.HasOptionalKeyword() {
							g.P("}")
						}
					}
				case protoreflect.Fixed64Kind:
					fallthrough
				case protoreflect.Uint64Kind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,v,10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,x.", field.GoName, ",10)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						}
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+22)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=", g.QualifiedGoIdent(strconvPackage.Ident("AppendUint")), "(query,req.Get", field.GoName, "(),10)")
						g.P("query=append(query,'&')")
						if field.Desc.HasOptionalKeyword() {
							g.P("}")
						}
					}
				case protoreflect.FloatKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("tmp:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(float64(v),'g',-1,32)")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(tmp)")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("tmp:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(float64(x.", field.GoName, "),'g',-1,32)")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(tmp)")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						} else {
							g.P("{")
						}
						g.P("tmp:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(float64(req.Get", field.GoName, "()),'g',-1,32)")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(tmp)")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					}
				case protoreflect.DoubleKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("tmp:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(v,'g',-1,64)")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(tmp)")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("tmp:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(x.", field.GoName, ",'g',-1,64)")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(tmp)")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						} else {
							g.P("{")
						}
						g.P("tmp:=", g.QualifiedGoIdent(strconvPackage.Ident("FormatFloat")), "(req.Get", field.GoName, "(),'g',-1,64)")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(tmp)")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					}
				case protoreflect.StringKind:
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("ev := ", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(v)")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(x.", field.GoName, ")")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						} else {
							g.P("{")
						}
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(req.Get", field.GoName, "())")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					}
				case protoreflect.BytesKind:
					g.P("//[]byte should be standard base64 encoded")
					g.P("//https://developers.google.com/protocol-buffers/docs/proto3#json")
					if field.Desc.IsList() {
						g.P("for _,v:=range req.Get", field.GoName, "(){")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(base64Package.Ident("StdEncoding.EncodeToString")), "(v))")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
						g.P("if x,ok:=req.", field.Oneof.GoName, ".(*", g.QualifiedGoIdent(field.GoIdent), ");ok{")
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(base64Package.Ident("StdEncoding.EncodeToString")), "(x.", field.GoName, "))")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					} else {
						if field.Desc.HasOptionalKeyword() {
							g.P("if req.", field.GoName, "!=nil{")
						} else {
							g.P("{")
						}
						g.P("ev:=", g.QualifiedGoIdent(urlPackage.Ident("QueryEscape")), "(", g.QualifiedGoIdent(base64Package.Ident("StdEncoding.EncodeToString")), "(req.Get", field.GoName, "()))")
						g.P("query=", g.QualifiedGoIdent(poolPackage.Ident("CheckCap")), "(&query,len(query)+", len(fname), "+len(ev)+2)")
						g.P("query=append(query,", strconv.Quote(fname+"="), "...)")
						g.P("query=append(query,ev...)")
						g.P("query=append(query,'&')")
						g.P("}")
					}
				case protoreflect.MessageKind:
					panic(fmt.Sprintf("method: %s in service: %s with httpmethod: %s,it's request message can't contain nested message and map", method.Desc.Name(), service.Desc.Name(), httpmetohd))
				}
			}
			g.P("if len(query)>0{")
			g.P("//drop last &")
			g.P("query=query[:len(query)-1]")
			g.P("}")
			g.P("querystr:=", g.QualifiedGoIdent(commonPackage.Ident("BTS")), "(query)")
			switch httpmetohd {
			case http.MethodGet:
				g.P("r,e:=c.cc.Get(ctx,", pathname, ",querystr,header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx))")
			case http.MethodDelete:
				g.P("r,e:=c.cc.Delete(ctx,", pathname, ",querystr,header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx))")
			}
		} else {
			g.P("header.Set(", strconv.Quote("Content-Type"), ",", strconv.Quote("application/x-protobuf"), ")")
			g.P("header.Set(", strconv.Quote("Accept"), ",", strconv.Quote("application/x-protobuf"), ")")
			g.P("reqd,_:=", g.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(req)")
			switch httpmetohd {
			case http.MethodPost:
				g.P("r,e:=c.cc.Post(ctx,", pathname, ",\"\",header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx),reqd)")
			case http.MethodPut:
				g.P("r,e:=c.cc.Put(ctx,", pathname, ",\"\",header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx),reqd)")
			case http.MethodPatch:
				g.P("r,e:=c.cc.Patch(ctx,", pathname, ",\"\",header,", g.QualifiedGoIdent(metadataPackage.Ident("GetMetadata")), "(ctx),reqd)")
			}
		}
		g.P("if e != nil {")
		g.P("return nil,e")
		g.P("}")
		g.P("data,e:=", g.QualifiedGoIdent(ioPackage.Ident("ReadAll")), "(r.Body)")
		g.P("r.Body.Close()")
		g.P("if e!=nil {")
		g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ConvertStdError")), "(e)")
		g.P("}")
		g.P("resp := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("if len(data)==0{")
		g.P("return resp,nil")
		g.P("}")
		g.P("if ", g.QualifiedGoIdent(stringsPackage.Ident("HasPrefix")), "(r.Header.Get(\"Content-Type\"), \"application/x-protobuf\"){")
		g.P("if e:=", g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(data,resp);e!=nil{")
		g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrResp")))
		g.P("}")
		g.P("} else if e:=(", g.QualifiedGoIdent(protojsonPackage.Ident("UnmarshalOptions")), "{AllowPartial: true,DiscardUnknown: true}).Unmarshal(data,resp);e!=nil{")
		g.P("return nil,", g.QualifiedGoIdent(cerrorPackage.Ident("ErrResp")))
		g.P("}")
		g.P("return resp, nil")
		g.P("}")
	}
}
