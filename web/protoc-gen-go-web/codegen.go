package main

import (
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func genfile(plugin *protogen.Plugin, file *protogen.File) {
	f := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+"_web.pb.go", file.GoImportPath)
	//package
	dealPackage(f, file)
	//import
	dealImports(f, file)
	//struct
	dealStruct(f, file)
	//handlefunc
	dealHandlefunc(f, file)
	//path
	dealPath(f, file)
	//server
	dealServer(f, file)
}
func dealPackage(f *protogen.GeneratedFile, file *protogen.File) {
	f.P("// Code generated by protoc-gen-go-web. DO NOT EDIT.")
	f.P()
	f.P(fmt.Sprintf("package %s", file.GoPackageName))
	f.P()
}
func dealImports(f *protogen.GeneratedFile, file *protogen.File) {
	deal := func(imports map[string]struct{}) {
		if len(imports) == 0 {
			return
		}
		temp := make([]string, len(imports))
		count := 0
		for v := range imports {
			temp[count] = v
			count++
		}
		sort.Strings(temp)
		for _, v := range temp {
			f.P(fmt.Sprintf("%s", v))
		}
	}
	//std package
	importsSTD := make(map[string]struct{})
	//importsSTD[strconv.Quote("fmt")] = struct{}{}
	importsSTD[strconv.Quote("encoding/json")] = struct{}{}
	importsSTD[strconv.Quote("net/http")] = struct{}{}
	importsSTD[strconv.Quote("net/url")] = struct{}{}
	importsSTD[strconv.Quote("strings")] = struct{}{}

	//third package
	importsTHIRD := make(map[string]struct{})
	importsTHIRD[strconv.Quote("github.com/chenjie199234/Corelib/web")] = struct{}{}
	importsTHIRD[strconv.Quote("google.golang.org/protobuf/proto")] = struct{}{}
	//self package
	importsSELF := make(map[string]struct{})
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if method.Input.GoIdent.GoImportPath.String() != "" && method.Input.GoIdent.GoImportPath.String() != file.GoImportPath.String() {
				importsSELF[method.Input.GoIdent.GoImportPath.String()] = struct{}{}
			}
			if method.Output.GoIdent.GoImportPath.String() != "" && method.Input.GoIdent.GoImportPath.String() != file.GoImportPath.String() {
				importsSELF[method.Output.GoIdent.GoImportPath.String()] = struct{}{}
			}
		}
	}
	f.P("import (")
	f.P("//std")
	deal(importsSTD)
	f.P()
	f.P("//third")
	deal(importsTHIRD)
	f.P()
	if len(importsSELF) > 0 {
		f.P("//project")
		deal(importsSELF)
	}
	f.P(")")
	f.P()
}
func dealStruct(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Web%sService", service.GoName)
		f.P(fmt.Sprintf("type %s struct {", structname))
		f.P("RegisterMidware func() map[string][]web.OutsideHandler")
		for _, method := range service.Methods {
			inputpac := method.Input.Desc.(protoreflect.Descriptor).ParentFile().Package()
			outputpac := method.Output.Desc.(protoreflect.Descriptor).ParentFile().Package()
			var input string
			var output string
			if string(inputpac) == string(file.GoPackageName) {
				input = fmt.Sprintf("%s", method.Input.GoIdent.GoName)
			} else {
				input = fmt.Sprintf("%s.%s", inputpac, method.Input.GoIdent.GoName)
			}
			if string(outputpac) == string(file.GoPackageName) {
				output = fmt.Sprintf("%s", method.Output.GoIdent.GoName)
			} else {
				output = fmt.Sprintf("%s.%s", outputpac, method.Output.GoIdent.GoName)
			}
			f.P(fmt.Sprintf("%s func(*web.Context, *%s) (*%s,error)", method.GoName, input, output))
		}
		f.P("}")
		f.P()
	}
}
func dealHandlefunc(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Web%sService", service.GoName)
		for _, method := range service.Methods {
			inputpac := method.Input.Desc.(protoreflect.Descriptor).ParentFile().Package()
			f.P(fmt.Sprintf("func (s *%s)%s(ctx *web.Context) {", structname, unexport(method.GoName)))
			if string(inputpac) == string(file.GoPackageName) {
				f.P(fmt.Sprintf("req := &%s{}", method.Input.GoIdent.GoName))
			} else {
				f.P(fmt.Sprintf("req := &%s.%s{}", inputpac, method.Input.GoIdent.GoName))
			}
			f.P("switch ctx.GetContentType() {")
			f.P("case \"\":fallthrough")
			f.P("case \"application/x-www-form-urlencoded\":")
			f.P("encoded := true")
			f.P("if data := ctx.GetForm(\"encode\"); data == \"0\" {")
			f.P("encoded = false")
			f.P("}")
			f.P("if data := ctx.GetForm(\"json\"); data != \"\" {")
			f.P("var e error")
			f.P("if encoded {")
			f.P("if data, e = url.QueryUnescape(data); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"encoded request data format error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("if e = json.Unmarshal(web.Str2byte(data), req); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"decode json request data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("} else if data := ctx.GetForm(\"proto\"); data != \"\" {")
			f.P("var e error")
			f.P("if encoded {")
			f.P("if data, e = url.QueryUnescape(data); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"encoded request data format error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("if e = proto.Unmarshal(web.Str2byte(data), req); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"decode proto request data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("case \"application/json\":")
			f.P("if body, _ := ctx.GetBody(); len(body) > 0 {")
			f.P("if e := json.Unmarshal(body, req); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"decode json request data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("case \"application/x-protobuf\":")
			f.P("if body, _ := ctx.GetBody(); len(body) > 0 {")
			f.P("if e := proto.Unmarshal(body, req); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"decode proto request data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("default:")
			f.P("ctx.WriteString(http.StatusBadRequest, \"unknown Content-Type:\"+ctx.GetContentType())")
			f.P("return")
			f.P("}")
			f.P(fmt.Sprintf("resp,e:=s.%s(ctx,req)", method.GoName))
			f.P("if e!=nil{")
			f.P("ctx.WriteString(http.StatusInternalServerError, e.Error())")
			f.P("return")
			f.P("}")
			f.P("if strings.Contains(ctx.GetAcceptType(), \"application/x-protobuf\") {")
			f.P("data, e := proto.Marshal(resp)")
			f.P("if e != nil {")
			f.P("ctx.WriteString(http.StatusInternalServerError, \"encode proto response data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("ctx.Write(http.StatusOK, data)")
			f.P("} else {")
			f.P("data, e := json.Marshal(resp)")
			f.P("if e != nil {")
			f.P("ctx.WriteString(http.StatusInternalServerError, \"encode json response data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("ctx.Write(http.StatusOK, data)")
			f.P("}")
			f.P("}")
		}
	}
}
func dealPath(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		for _, method := range service.Methods {
			pathname := fmt.Sprintf("PathWeb%s%s", service.GoName, method.GoName)
			path := fmt.Sprintf("/%s/%s", service.GoName, method.GoName)
			f.P(fmt.Sprintf("var %s = %s", pathname, strconv.Quote(path)))
		}
		f.P()
	}
}
func dealServer(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Web%sService", service.GoName)
		f.P(fmt.Sprintf("func Register%s(engine *web.Web, instance *%s) {", structname, structname))
		f.P("var pathmids map[string][]web.OutsideHandler")
		f.P("if instance.RegisterMidware != nil {")
		f.P("pathmids = instance.RegisterMidware()")
		f.P("}")
		for _, method := range service.Methods {
			pathname := fmt.Sprintf("PathWeb%s%s", service.GoName, method.GoName)
			f.P(fmt.Sprintf("//%s", method.GoName))
			f.P(fmt.Sprintf("if instance.%s == nil {", method.GoName))
			switch strings.ToUpper(strings.TrimSuffix(string(method.Comments.Trailing), "\n")) {
			case "":
				fallthrough
			case http.MethodGet:
				f.P(fmt.Sprintf("engine.GET(%s,func(ctx *web.Context){ctx.WriteString(http.StatusNotFound, \"method %s not implemented\")})", pathname, method.GoName))
			case http.MethodPost:
				f.P(fmt.Sprintf("engine.POST(%s,func(ctx *web.Context){ctx.WriteString(http.StatusNotFound, \"method %s not implemented\")})", pathname, method.GoName))
			case http.MethodPatch:
				f.P(fmt.Sprintf("engine.PATCH(%s,func(ctx *web.Context){ctx.WriteString(http.StatusNotFound, \"method %s not implemented\")})", pathname, method.GoName))
			case http.MethodPut:
				f.P(fmt.Sprintf("engine.PUT(%s,func(ctx *web.Context){ctx.WriteString(http.StatusNotFound, \"method %s not implemented\")})", pathname, method.GoName))
			case http.MethodDelete:
				f.P(fmt.Sprintf("engine.DELETE(%s,func(ctx *web.Context){ctx.WriteString(http.StatusNotFound, \"method %s not implemented\")})", pathname, method.GoName))
			case http.MethodHead:
				f.P(fmt.Sprintf("engine.HEAD(%s,func(ctx *web.Context){ctx.WriteString(http.StatusNotFound, \"method %s not implemented\")})", pathname, method.GoName))
			case http.MethodOptions:
				f.P(fmt.Sprintf("engine.OPTIONS(%s,func(ctx *web.Context){ctx.WriteString(http.StatusNotFound, \"method %s not implemented\")})", pathname, method.GoName))
			default:
				panic("unknown http method:" + strings.ToUpper(strings.TrimSuffix(string(method.Comments.Trailing), "\n")))
			}
			f.P(fmt.Sprintf("} else if mids, ok := pathmids[%s]; ok && len(mids) > 0 {", pathname))
			switch strings.ToUpper(strings.TrimSuffix(string(method.Comments.Trailing), "\n")) {
			case "":
				fallthrough
			case http.MethodGet:
				f.P(fmt.Sprintf("engine.GET(%s,append(mids,instance.%s)...)", pathname, unexport(method.GoName)))
			case http.MethodPost:
				f.P(fmt.Sprintf("engine.POST(%s,append(mids,instance.%s)...)", pathname, unexport(method.GoName)))
			case http.MethodPatch:
				f.P(fmt.Sprintf("engine.PATCH(%s,append(mids,instance.%s)...)", pathname, unexport(method.GoName)))
			case http.MethodPut:
				f.P(fmt.Sprintf("engine.PUT(%s,append(mids,instance.%s)...)", pathname, unexport(method.GoName)))
			case http.MethodDelete:
				f.P(fmt.Sprintf("engine.DELETE(%s,append(mids,instance.%s)...)", pathname, unexport(method.GoName)))
			case http.MethodHead:
				f.P(fmt.Sprintf("engine.HEAD(%s,append(mids,instance.%s)...)", pathname, unexport(method.GoName)))
			case http.MethodOptions:
				f.P(fmt.Sprintf("engine.OPTIONS(%s,append(mids,instance.%s)...)", pathname, unexport(method.GoName)))
			default:
				panic("unknown http method:" + strings.ToUpper(strings.TrimSuffix(string(method.Comments.Trailing), "\n")))
			}
			f.P("} else {")
			switch strings.ToUpper(strings.TrimSuffix(string(method.Comments.Trailing), "\n")) {
			case "":
				fallthrough
			case http.MethodGet:
				f.P(fmt.Sprintf("engine.GET(%s,instance.%s)", pathname, unexport(method.GoName)))
			case http.MethodPost:
				f.P(fmt.Sprintf("engine.POST(%s,instance.%s)", pathname, unexport(method.GoName)))
			case http.MethodPatch:
				f.P(fmt.Sprintf("engine.PATCH(%s,instance.%s)", pathname, unexport(method.GoName)))
			case http.MethodPut:
				f.P(fmt.Sprintf("engine.PUT(%s,instance.%s)", pathname, unexport(method.GoName)))
			case http.MethodDelete:
				f.P(fmt.Sprintf("engine.DELETE(%s,instance.%s)", pathname, unexport(method.GoName)))
			case http.MethodHead:
				f.P(fmt.Sprintf("engine.HEAD(%s,instance.%s)", pathname, unexport(method.GoName)))
			case http.MethodOptions:
				f.P(fmt.Sprintf("engine.OPTIONS(%s,instance.%s)", pathname, unexport(method.GoName)))
			default:
				panic("unknown http method:" + strings.ToUpper(strings.TrimSuffix(string(method.Comments.Trailing), "\n")))
			}
			f.P("}")
		}
		f.P("}")
		f.P()
	}
}
func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }
