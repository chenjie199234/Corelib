package main

import (
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func genfile(plugin *protogen.Plugin, file *protogen.File) {
	f := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+"_web.pb.go", file.GoImportPath)
	//package
	dealPackage(f, file)
	//import
	dealImports(f, file)
	//path
	dealPath(f, file)
	//struct
	dealServerStruct(f, file)
	//handlefunc
	dealServerHandlefunc(f, file)
	//server
	dealServerRegister(f, file)
}
func dealPackage(f *protogen.GeneratedFile, file *protogen.File) {
	f.P("// Code generated by protoc-gen-go-web. DO NOT EDIT.")
	f.P()
	f.P(fmt.Sprintf("package %s", file.GoPackageName))
	f.P()
}
func dealImports(f *protogen.GeneratedFile, file *protogen.File) {
	deal := func(imports map[string]struct{}) {
		if len(imports) == 0 {
			return
		}
		temp := make([]string, len(imports))
		count := 0
		for v := range imports {
			temp[count] = v
			count++
		}
		sort.Strings(temp)
		for _, v := range temp {
			f.P(fmt.Sprintf("%s", v))
		}
	}
	//std package
	importsSTD := make(map[string]struct{})
	importsSTD[strconv.Quote("encoding/json")] = struct{}{}
	importsSTD[strconv.Quote("net/http")] = struct{}{}
	importsSTD[strconv.Quote("net/url")] = struct{}{}
	importsSTD[strconv.Quote("strings")] = struct{}{}

	//third package
	importsTHIRD := make(map[string]struct{})
	importsTHIRD[strconv.Quote("github.com/chenjie199234/Corelib/web")] = struct{}{}
	importsTHIRD[strconv.Quote("google.golang.org/protobuf/proto")] = struct{}{}
	//self package
	importsSELF := make(map[string]struct{})
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if method.Input.GoIdent.GoImportPath.String() != "" && method.Input.GoIdent.GoImportPath.String() != file.GoImportPath.String() {
				importsSELF[method.Input.GoIdent.GoImportPath.String()] = struct{}{}
			}
			if method.Output.GoIdent.GoImportPath.String() != "" && method.Input.GoIdent.GoImportPath.String() != file.GoImportPath.String() {
				importsSELF[method.Output.GoIdent.GoImportPath.String()] = struct{}{}
			}
		}
	}
	f.P("import (")
	f.P("//std")
	deal(importsSTD)
	f.P()
	f.P("//third")
	deal(importsTHIRD)
	f.P()
	if len(importsSELF) > 0 {
		f.P("//project")
		deal(importsSELF)
	}
	f.P(")")
	f.P()
}
func dealPath(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		for _, method := range service.Methods {
			pathname := fmt.Sprintf("PathWeb%s%s", service.GoName, method.GoName)
			path := fmt.Sprintf("/%s/%s", service.GoName, method.GoName)
			f.P(fmt.Sprintf("var %s = %s", pathname, strconv.Quote(path)))
		}
		f.P()
	}
}
func dealServerStruct(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Web%sService", service.GoName)
		f.P(fmt.Sprintf("type %s struct {", structname))
		f.P("Midware func()map[string][]web.OutsideHandler")
		for _, method := range service.Methods {
			inputpac := method.Input.Desc.(protoreflect.Descriptor).ParentFile().Package()
			outputpac := method.Output.Desc.(protoreflect.Descriptor).ParentFile().Package()
			var input string
			var output string
			if string(inputpac) == string(file.GoPackageName) {
				input = fmt.Sprintf("%s", method.Input.GoIdent.GoName)
			} else {
				input = fmt.Sprintf("%s.%s", inputpac, method.Input.GoIdent.GoName)
			}
			if string(outputpac) == string(file.GoPackageName) {
				output = fmt.Sprintf("%s", method.Output.GoIdent.GoName)
			} else {
				output = fmt.Sprintf("%s.%s", outputpac, method.Output.GoIdent.GoName)
			}
			f.P(fmt.Sprintf("%s func(*web.Context, *%s) (*%s,error)", method.GoName, input, output))
		}
		f.P("}")
		f.P()
	}
}
func dealServerHandlefunc(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Web%sService", service.GoName)
		for _, method := range service.Methods {
			inputpac := method.Input.Desc.(protoreflect.Descriptor).ParentFile().Package()
			f.P(fmt.Sprintf("func (s *%s)%s(ctx *web.Context) {", structname, unexport(method.GoName)))
			if string(inputpac) == string(file.GoPackageName) {
				f.P(fmt.Sprintf("req := &%s{}", method.Input.GoIdent.GoName))
			} else {
				f.P(fmt.Sprintf("req := &%s.%s{}", inputpac, method.Input.GoIdent.GoName))
			}
			f.P("switch ctx.GetContentType() {")
			f.P("case \"\":fallthrough")
			f.P("case \"application/x-www-form-urlencoded\":")
			f.P("encoded := true")
			f.P("if data := ctx.GetForm(\"encode\"); data == \"0\" {")
			f.P("encoded = false")
			f.P("}")
			f.P("if data := ctx.GetForm(\"json\"); data != \"\" {")
			f.P("var e error")
			f.P("if encoded {")
			f.P("if data, e = url.QueryUnescape(data); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"encoded request data format error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("if e = json.Unmarshal(web.Str2byte(data), req); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"decode json request data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("} else if data := ctx.GetForm(\"proto\"); data != \"\" {")
			f.P("var e error")
			f.P("if encoded {")
			f.P("if data, e = url.QueryUnescape(data); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"encoded request data format error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("if e = proto.Unmarshal(web.Str2byte(data), req); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"decode proto request data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("case \"application/json\":")
			f.P("if body, _ := ctx.GetBody(); len(body) > 0 {")
			f.P("if e := json.Unmarshal(body, req); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"decode json request data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("case \"application/x-protobuf\":")
			f.P("if body, _ := ctx.GetBody(); len(body) > 0 {")
			f.P("if e := proto.Unmarshal(body, req); e != nil {")
			f.P("ctx.WriteString(http.StatusBadRequest, \"decode proto request data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("}")
			f.P("default:")
			f.P("ctx.WriteString(http.StatusBadRequest, \"unknown Content-Type:\"+ctx.GetContentType())")
			f.P("return")
			f.P("}")
			f.P(fmt.Sprintf("resp,e:=s.%s(ctx,req)", method.GoName))
			f.P("if e!=nil{")
			f.P("ctx.WriteString(http.StatusInternalServerError, e.Error())")
			f.P("return")
			f.P("}")
			f.P("if strings.Contains(ctx.GetAcceptType(), \"application/x-protobuf\") {")
			f.P("data, e := proto.Marshal(resp)")
			f.P("if e != nil {")
			f.P("ctx.WriteString(http.StatusInternalServerError, \"encode proto response data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("ctx.Write(http.StatusOK, data)")
			f.P("} else {")
			f.P("data, e := json.Marshal(resp)")
			f.P("if e != nil {")
			f.P("ctx.WriteString(http.StatusInternalServerError, \"encode json response data error:\"+e.Error())")
			f.P("return")
			f.P("}")
			f.P("ctx.Write(http.StatusOK, data)")
			f.P("}")
			f.P("}")
		}
	}
}
func dealServerRegister(f *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		structname := fmt.Sprintf("Web%sService", service.GoName)
		f.P(fmt.Sprintf("func Register%s(engine *web.Web, instance *%s) {", structname, structname))
		f.P("var allmids map[string][]web.OutsideHandler")
		f.P("if instance.Midware!=nil{allmids=instance.Midware()}")
		for _, method := range service.Methods {
			pathname := fmt.Sprintf("PathWeb%s%s", service.GoName, method.GoName)
			f.P(fmt.Sprintf("//%s", method.GoName))
			httpmethod, timeout := commentTrail(strings.TrimSpace(strings.TrimSuffix(string(method.Comments.Trailing), "\n")))
			f.P(fmt.Sprintf("if instance.%s == nil {", method.GoName))
			switch httpmethod {
			case "":
				fallthrough
			case http.MethodGet:
				f.P(fmt.Sprintf("engine.GET(%s,%d,func(ctx *web.Context){ctx.WriteString(http.StatusNotFound, \"method %s not implemented\")})", pathname, timeout, method.GoName))
			case http.MethodPost:
				f.P(fmt.Sprintf("engine.POST(%s,%d,func(ctx *web.Context){ctx.WriteString(http.StatusNotFound, \"method %s not implemented\")})", pathname, timeout, method.GoName))
			default:
				panic("unknown http method:" + httpmethod)
			}
			f.P(fmt.Sprintf("} else if mids,ok := allmids[%s];ok && len(mids)!=0{", pathname))
			switch httpmethod {
			case "":
				fallthrough
			case http.MethodGet:
				f.P(fmt.Sprintf("engine.GET(%s,%d,append(mids,instance.%s)...)", pathname, timeout, unexport(method.GoName)))
			case http.MethodPost:
				f.P(fmt.Sprintf("engine.POST(%s,%d,append(mids,instance.%s)...)", pathname, timeout, unexport(method.GoName)))
			default:
				panic("unknown http method:" + httpmethod)
			}
			f.P("} else {")
			switch httpmethod {
			case "":
				fallthrough
			case http.MethodGet:
				f.P(fmt.Sprintf("engine.GET(%s,%d,instance.%s)", pathname, timeout, unexport(method.GoName)))
			case http.MethodPost:
				f.P(fmt.Sprintf("engine.POST(%s,%d,instance.%s)", pathname, timeout, unexport(method.GoName)))
			default:
				panic("unknown http method:" + httpmethod)
			}
			f.P("}")
		}
		f.P("}")
		f.P()
	}
}
func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }

func commentTrail(trail string) (string, int64) {
	if trail == "" {
		return "GET", 0
	}
	trails := strings.Split(trail, ",")
	if len(trails) > 1 && trails[1] != "" {
		var number string
		var unit string
		for i := 0; i < len(trails[1]); i++ {
			if trails[1][i] < '0' || trails[1][i] > '9' {
				number = trails[1][:i]
				unit = trails[1][i:]
				break
			}
			if i == len(trails[1])-1 {
				number = trails[1]
			}
		}
		if number == "" {
			return strings.TrimSpace(strings.TrimSuffix(strings.ToUpper(trails[0]), "\n")), 0
		}
		timeout, e := strconv.ParseInt(number, 10, 64)
		if e != nil {
			panic(fmt.Sprintf("trail comment %s format error", e))
		}
		if timeout < 0 {
			panic("timeout can't < 0")
		}
		switch unit {
		case "":
		case "ms":
		case "s":
			timeout = timeout * 1000
		default:
			panic("timeout unit only support 'ms' and 's'")
		}
		return strings.TrimSpace(strings.TrimSuffix(strings.ToUpper(trails[0]), "\n")), timeout
	} else {
		return strings.TrimSpace(strings.TrimSuffix(strings.ToUpper(trails[0]), "\n")), 0
	}
}
