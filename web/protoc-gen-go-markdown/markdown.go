package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/chenjie199234/Corelib/pbex"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

// generateFile generates a _web.pb.go file containing web service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_markdown.md"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		genService(file, service, g)
	}
	return g
}
func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-go-markdown. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-go-markdown ", version)
	g.P("// \tprotoc                 ", protocVersion)
	g.P("// source: ", file.Desc.Path())
	g.P()
}

func genService(file *protogen.File, s *protogen.Service, g *protogen.GeneratedFile) {
	first := true
	for _, m := range s.Methods {
		mop := m.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() {
			continue
		}
		if !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		httpmetohd := strings.ToUpper(proto.GetExtension(mop, pbex.E_Method).(string))
		if httpmetohd != http.MethodGet && httpmetohd != http.MethodPost && httpmetohd != http.MethodPut && httpmetohd != http.MethodDelete && httpmetohd != http.MethodPatch {
			panic(fmt.Sprintf("method: %s in service: %s with not supported httpmetohd: %s", m.Desc.Name(), s.Desc.Name(), httpmetohd))
		}
		if first {
			first = false
			g.P("## ", s.Desc.Name())
		}
		path := "/" + *file.Proto.Package + "." + string(s.Desc.Name()) + "/" + string(m.Desc.Name())
		g.P("### ", path)
		g.P(m.Comments.Leading.String() + m.Comments.Trailing.String())
		g.P("#### Req:")
		g.P("```")
		g.P("Method:       ", httpmetohd)
		if httpmetohd == "POST" || httpmetohd == "PUT" || httpmetohd == "PATCH" {
			g.P("Content-Type: application/json")
		} else {
			g.P("Content-Type: application/x-www-form-urlencoded")
		}
		g.P("```")
		g.P("#### Resp:")
		g.P("```")
		g.P("Fail:    httpcode:4xx/5xx")
		g.P("{\"code\":123,\"msg\":\"error message\"}")
		g.P("Success: httpcode:200")
		jsondoc(g, m.Input, false)
		g.P("```")
	}
}
func jsondoc(g *protogen.GeneratedFile, m *protogen.Message, skipoptions bool) map[string]*protogen.Message {
	g.P("{")
	for i, f := range m.Fields {
		fop := f.Desc.Options().(*descriptorpb.FieldOptions)
		comments := strings.TrimSuffix(f.Comments.Leading.String()+f.Comments.Trailing.String(), "\n")
		if comments != "" {
			g.P(comments)
		}
		line := strconv.Quote(string(f.Desc.Name())) + ":"
		switch f.Desc.Kind() {
		case protoreflect.BoolKind:
			if f.Desc.IsList() {
				line += "[true,true]"
			} else {
				line += "true"
			}
			if i != len(m.Fields)-1 {
				line += ","
			}
			line += "//bool"
			if proto.HasExtension(fop, pbex.E_BoolEq) {
				eq := proto.GetExtension(fop, pbex.E_BoolEq).(bool)
				if f.Desc.IsList() {
					g.P("\telement value must be ", eq)
				} else {
					g.P("\tvalue must be ", eq)
				}
			}
		case protoreflect.EnumKind:
			if f.Desc.IsList() {
				line += "[1,2]"
			} else {
				line += "0"
			}
			if i != len(m.Fields)-1 {
				line += ","
			}
			line += "//int32"
			origin := make([]int32, 0, len(f.Enum.Values))
			for _, v := range f.Enum.Values {
				origin = append(origin, int32(v.Desc.Number()))
			}
			d, _ := json.Marshal(origin)
			if f.Desc.IsList() {
				g.P("//element value must in ", string(d))
			} else {
				g.P("//value must in ", string(d))
			}
			if proto.HasExtension(fop, pbex.E_EnumIn) {
				ins := proto.GetExtension(fop, pbex.E_EnumIn).([]int64)
				d, _ := json.Marshal(ins)
				if f.Desc.IsList() {
					g.P("//element value must in ", string(d))
				} else {
					g.P("//value must in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_EnumNotIn) {
				notins := proto.GetExtension(fop, pbex.E_EnumNotIn).([]int64)
				d, _ := json.Marshal(notins)
				if f.Desc.IsList() {
					g.P("//element value must not in ", string(d))
				} else {
					g.P("//value must not in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_EnumGt) {
				gt := proto.GetExtension(fop, pbex.E_EnumGt).(int64)
				if f.Desc.IsList() {
					g.P("//element value must > ", gt)
				} else {
					g.P("//value must > ", gt)
				}
			}
			if proto.HasExtension(fop, pbex.E_EnumGte) {
				gte := proto.GetExtension(fop, pbex.E_EnumGte).(int64)
				if f.Desc.IsList() {
					g.P("//element value must >= ", gte)
				} else {
					g.P("//value must >= ", gte)
				}
			}
			if proto.HasExtension(fop, pbex.E_EnumLt) {
				lt := proto.GetExtension(fop, pbex.E_EnumLt).(int64)
				if f.Desc.IsList() {
					g.P("//element value must < ", lt)
				} else {
					g.P("//value must < ", lt)
				}
			}
			if proto.HasExtension(fop, pbex.E_EnumLte) {
				lte := proto.GetExtension(fop, pbex.E_EnumLte).(int64)
				if f.Desc.IsList() {
					g.P("//element value must <= ", lte)
				} else {
					g.P("//value must <= ", lte)
				}
			}
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Sfixed32Kind:
			//int32
			fallthrough
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Sfixed64Kind:
			//int64
			if f.Desc.IsList() {
				if f.Desc.Kind() == protoreflect.Int32Kind ||
					f.Desc.Kind() == protoreflect.Sint32Kind ||
					f.Desc.Kind() == protoreflect.Sfixed32Kind {
					line += "[1,2]"
				} else {
					line += "[\"1\",\"2\"]"
				}
			} else {
				if f.Desc.Kind() == protoreflect.Int32Kind ||
					f.Desc.Kind() == protoreflect.Sint32Kind ||
					f.Desc.Kind() == protoreflect.Sfixed32Kind {
					line += "0"
				} else {
					line += "\"0\""
				}
			}
			if i != len(m.Fields)-1 {
				line += ","
			}
			if f.Desc.Kind() == protoreflect.Int64Kind ||
				f.Desc.Kind() == protoreflect.Sint64Kind ||
				f.Desc.Kind() == protoreflect.Sfixed64Kind {
				line += "//int64 use string to avoid overflow"
			} else {
				line += "//int32"
			}
			if proto.HasExtension(fop, pbex.E_IntIn) {
				ins := proto.GetExtension(fop, pbex.E_IntIn).([]int64)
				d, _ := json.Marshal(ins)
				if f.Desc.IsList() {
					g.P("//element value must in ", string(d))
				} else {
					g.P("//value must in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_IntNotIn) {
				notins := proto.GetExtension(fop, pbex.E_IntNotIn).([]int64)
				d, _ := json.Marshal(notins)
				if f.Desc.IsList() {
					g.P("//element value must not in ", string(d))
				} else {
					g.P("//value must not in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_IntGt) {
				gt := proto.GetExtension(fop, pbex.E_IntGt).(int64)
				if f.Desc.IsList() {
					g.P("//element value must > ", gt)
				} else {
					g.P("//value must > ", gt)
				}
			}
			if proto.HasExtension(fop, pbex.E_IntGte) {
				gte := proto.GetExtension(fop, pbex.E_IntGte).(int64)
				if f.Desc.IsList() {
					g.P("//element value must >= ", gte)
				} else {
					g.P("//value must >= ", gte)
				}
			}
			if proto.HasExtension(fop, pbex.E_IntLt) {
				lt := proto.GetExtension(fop, pbex.E_IntLt).(int64)
				if f.Desc.IsList() {
					g.P("//element value must < ", lt)
				} else {
					g.P("//value must < ", lt)
				}
			}
			if proto.HasExtension(fop, pbex.E_IntLte) {
				lte := proto.GetExtension(fop, pbex.E_IntLte).(int64)
				if f.Desc.IsList() {
					g.P("//element value must <= ", lte)
				} else {
					g.P("//value must <= ", lte)
				}
			}
		case protoreflect.Uint32Kind:
			fallthrough
		case protoreflect.Fixed32Kind:
			//uint32
			fallthrough
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Fixed64Kind:
			//uint64
			if f.Desc.IsList() {
				if f.Desc.Kind() == protoreflect.Uint32Kind ||
					f.Desc.Kind() == protoreflect.Fixed32Kind {
					line += "[1,2]"
				} else {
					line += "[\"1\",\"2\"]"
				}
			} else {
				if f.Desc.Kind() == protoreflect.Uint32Kind ||
					f.Desc.Kind() == protoreflect.Fixed32Kind {
					line += "0"
				} else {
					line += "\"0\""
				}
			}
			if i != len(m.Fields)-1 {
				line += ","
			}
			if f.Desc.Kind() == protoreflect.Uint64Kind ||
				f.Desc.Kind() == protoreflect.Fixed64Kind {
				line += "//uint64 use string to avoid overflow"
			} else {
				line += "//uint32"
			}
			if proto.HasExtension(fop, pbex.E_UintIn) {
				ins := proto.GetExtension(fop, pbex.E_UintIn).([]uint64)
				d, _ := json.Marshal(ins)
				if f.Desc.IsList() {
					g.P("//element value must in ", string(d))
				} else {
					g.P("//value must in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_UintNotIn) {
				notins := proto.GetExtension(fop, pbex.E_UintNotIn).([]uint64)
				d, _ := json.Marshal(notins)
				if f.Desc.IsList() {
					g.P("//element value must not in ", string(d))
				} else {
					g.P("//value must not in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_UintGt) {
				gt := proto.GetExtension(fop, pbex.E_UintGt).(uint64)
				if f.Desc.IsList() {
					g.P("//element value must > ", gt)
				} else {
					g.P("//value must > ", gt)
				}
			}
			if proto.HasExtension(fop, pbex.E_UintGte) {
				gte := proto.GetExtension(fop, pbex.E_UintGte).(uint64)
				if f.Desc.IsList() {
					g.P("//element value must >= ", gte)
				} else {
					g.P("//value must >= ", gte)
				}
			}
			if proto.HasExtension(fop, pbex.E_UintLt) {
				lt := proto.GetExtension(fop, pbex.E_UintLt).(uint64)
				if f.Desc.IsList() {
					g.P("element value must < ", lt)
				} else {
					g.P("value must < ", lt)
				}
			}
			if proto.HasExtension(fop, pbex.E_UintLte) {
				lte := proto.GetExtension(fop, pbex.E_UintLte).(uint64)
				if f.Desc.IsList() {
					g.P("element value must <= ", lte)
				} else {
					g.P("value must <= ", lte)
				}
			}
		case protoreflect.FloatKind:
			//float32
			fallthrough
		case protoreflect.DoubleKind:
			//float64
			if f.Desc.IsList() {
				line += "[0.1,0.2]"
			} else {
				line += "0.1"

			}
			if i != len(m.Fields)-1 {
				line += ","
			}
			if f.Desc.Kind() == protoreflect.FloatKind {
				line += "//float32"
			} else {
				line += "//float64"
			}
			if proto.HasExtension(fop, pbex.E_FloatIn) {
				ins := proto.GetExtension(fop, pbex.E_FloatIn).([]float64)
				d, _ := json.Marshal(ins)
				if f.Desc.IsList() {
					g.P("//element value must in ", string(d))
				} else {
					g.P("//value must in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_FloatNotIn) {
				notins := proto.GetExtension(fop, pbex.E_FloatNotIn).([]float64)
				d, _ := json.Marshal(notins)
				if f.Desc.IsList() {
					g.P("//element value must not in ", string(d))
				} else {
					g.P("//value must not in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_FloatGt) {
				gt := proto.GetExtension(fop, pbex.E_FloatGt).(float64)
				if f.Desc.IsList() {
					g.P("//element value must > ", gt)
				} else {
					g.P("//value must > ", gt)
				}
			}
			if proto.HasExtension(fop, pbex.E_FloatGte) {
				gte := proto.GetExtension(fop, pbex.E_FloatGte).(float64)
				if f.Desc.IsList() {
					g.P("//element value must >= ", gte)
				} else {
					g.P("//value must >= ", gte)
				}
			}
			if proto.HasExtension(fop, pbex.E_FloatLt) {
				lt := proto.GetExtension(fop, pbex.E_FloatLt).(float64)
				if f.Desc.IsList() {
					g.P("element value must < ", lt)
				} else {
					g.P("value must < ", lt)
				}
			}
			if proto.HasExtension(fop, pbex.E_FloatLte) {
				lte := proto.GetExtension(fop, pbex.E_FloatLte).(float64)
				if f.Desc.IsList() {
					g.P("element value must <= ", lte)
				} else {
					g.P("value must <= ", lte)
				}
			}
		case protoreflect.BytesKind:
			fallthrough
		case protoreflect.StringKind:
			if f.Desc.IsList() {
				if f.Desc.Kind() == protoreflect.BytesKind {
					line += "[\"base64 str\",\"base64 str\"]"
				} else {
					line += "[\"str\",\"str\"]"
				}
			} else {
				if f.Desc.Kind() == protoreflect.BytesKind {
					line += "\"base64 str\""
				} else {
					line += "\"str\""
				}
			}
			if i != len(m.Fields)-1 {
				line += ","
			}
			if proto.HasExtension(fop, pbex.E_StringBytesIn) {
				ins := proto.GetExtension(fop, pbex.E_StringBytesIn).([]string)
				d, _ := json.Marshal(ins)
				if f.Desc.IsList() {
					g.P("//element value must in ", string(d))
				} else {
					g.P("//value must in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesNotIn) {
				notins := proto.GetExtension(fop, pbex.E_StringBytesNotIn).([]string)
				d, _ := json.Marshal(notins)
				if f.Desc.IsList() {
					g.P("//element value must not in ", string(d))
				} else {
					g.P("//value must not in ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesRegMatch) {
				match := proto.GetExtension(fop, pbex.E_StringBytesRegMatch).([]string)
				d, _ := json.Marshal(match)
				if f.Desc.IsList() {
					g.P("//element value must match regexp ", string(d))
				} else {
					g.P("//value must match regexp ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesRegNotMatch) {
				notmatch := proto.GetExtension(fop, pbex.E_StringBytesRegNotMatch).([]string)
				d, _ := json.Marshal(notmatch)
				if f.Desc.IsList() {
					g.P("//element value must not match regexp ", string(d))
				} else {
					g.P("//value must not match regexp ", string(d))
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesLenEq) {
				eq := proto.GetExtension(fop, pbex.E_StringBytesLenEq).(uint64)
				if f.Desc.IsList() {
					g.P("//element value length must == ", eq)
				} else {
					g.P("//value length must == ", eq)
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesLenNotEq) {
				noteq := proto.GetExtension(fop, pbex.E_StringBytesLenNotEq).(uint64)
				if f.Desc.IsList() {
					g.P("//element value length must != ", noteq)
				} else {
					g.P("//value length must != ", noteq)
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesLenGt) {
				gt := proto.GetExtension(fop, pbex.E_StringBytesLenGt).(uint64)
				if f.Desc.IsList() {
					g.P("//element value length must > ", gt)
				} else {
					g.P("//value length must > ", gt)
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesLenGte) {
				gte := proto.GetExtension(fop, pbex.E_StringBytesLenGte).(uint64)
				if f.Desc.IsList() {
					g.P("//element value length must >= ", gte)
				} else {
					g.P("//value length must >= ", gte)
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesLenLt) {
				lt := proto.GetExtension(fop, pbex.E_StringBytesLenLt).(uint64)
				if f.Desc.IsList() {
					g.P("//element value length must < ", lt)
				} else {
					g.P("//value length must < ", lt)
				}
			}
			if proto.HasExtension(fop, pbex.E_StringBytesLenLte) {
				lte := proto.GetExtension(fop, pbex.E_StringBytesLenLte).(uint64)
				if f.Desc.IsList() {
					g.P("//element value length must <= ", lte)
				} else {
					g.P("//value length must <= ", lte)
				}
			}
		case protoreflect.MessageKind:
			if f.Desc.IsMap() {
				line += "{"
				tmp := ""
				key := f.Desc.MapKey()
				value := f.Desc.MapValue()
				switch key.Kind() {
				case protoreflect.BoolKind:
					//bool
					tmp += strconv.Quote("true")
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					//int32
					fallthrough
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					//int64
					fallthrough
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					//uint32
					fallthrough
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					//uint64
					tmp += strconv.Quote("0")
				case protoreflect.StringKind:
					tmp += strconv.Quote("str")
				}
				tmp += ":"
				switch value.Kind() {
				case protoreflect.BoolKind:
					//bool
					tmp += strconv.Quote("true")
				case protoreflect.EnumKind:
					fallthrough
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					//int32
					fallthrough
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					//uint32
					tmp += "0"
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					//int64
					fallthrough
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					//uint64
					tmp += strconv.Quote("0")
				case protoreflect.FloatKind:
					//float32
					fallthrough
				case protoreflect.DoubleKind:
					//float64
					tmp += "0.1"
				case protoreflect.BytesKind:
					//bytes
					tmp += strconv.Quote("base64 str")
				case protoreflect.StringKind:
					//string
					tmp += strconv.Quote("str")
				case protoreflect.MessageKind:
					//message
					tmp += "{}"
				}
				line += tmp
				line += ","
				line += tmp
				line += "}"
			} else if f.Desc.IsList() {
				line += "[{},{}]"
			} else {
				line += "{}"
			}
			if i != len(m.Fields)-1 {
				line += ","
			}
			if f.Desc.IsMap() {
				key := f.Desc.MapKey()
				value := f.Desc.MapValue()
				switch key.Kind() {
				case protoreflect.BoolKind:
					//bool
					line += "//key-bool "
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					//int32
					line += "//key-int32 "
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					//int64
					line += "//key-int64 "
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					//uint32
					line += "//key-uint32 "
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					//uint64
					line += "//key-uint64 "
				case protoreflect.StringKind:
					line += "//key-string "
				}
				switch value.Kind() {
				case protoreflect.BoolKind:
					//bool
					line += strconv.Quote("value-bool")
				case protoreflect.EnumKind:
					fallthrough
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					//int32
					line += "value-int32"
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					//uint32
					line += "value-uint32"
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					//int64
					line += "value-int64 use string to avoid overflow"
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					//uint64
					line += "value-uint64 use string to avoid overflow"
				case protoreflect.FloatKind:
					//float32
					line += "value-float32"
				case protoreflect.DoubleKind:
					//float64
					line += "value-float64"
				case protoreflect.BytesKind:
					//bytes
					break
				case protoreflect.StringKind:
					//string
					break
				case protoreflect.MessageKind:
					//message
					line += "value-object " + string(value.Message().Name())
				}
			} else {
				line += "//object " + string(f.Message.Desc.Name())
				if proto.HasExtension(fop, pbex.E_MessageNotNil) {
					if notnil := proto.GetExtension(fop, pbex.E_MessageNotNil).(bool); notnil {
						if f.Desc.IsList() {
							g.P("//element value must not be null")
						} else {
							g.P("//value must not be null")
						}
					}
				}
			}
		}
		g.P(line)
	}
	g.P("}")
	return nil
}
