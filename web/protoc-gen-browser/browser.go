package main

import (
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/chenjie199234/Corelib/internal/version"
	"github.com/chenjie199234/Corelib/pbex"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"

	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_browser.ts"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFileComment(gen, file, g)

	//gen req and resp
	enums, msgs, tojson, toform, fromobj, methodcount := prepare(file, g)
	if methodcount == 0 {
		return g
	}
	g.P("export interface LogicError{")
	g.P("\tcode: number;")
	g.P("\tmsg: string;")
	g.P("}")
	g.P()
	for _, e := range enums {
		genEnum(e, g)
	}
	for _, m := range msgs {
		_, gentojson := tojson[m.GoIdent.String()]
		_, gentoform := toform[m.GoIdent.String()]
		_, genfromobj := fromobj[m.GoIdent.String()]
		genMessage(m, g, gentojson, gentoform, genfromobj)
	}
	genCall(g)
	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		//gen path
		if genPath(file, service, g) == 0 {
			continue
		}
		genService(file, service, g)
	}
	return g
}

func genFileComment(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	//add version comments
	g.P("// Code generated by protoc-gen-browser. DO NOT EDIT.")
	g.P("// version:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-browser ", version.String(), "<br />")
	g.P("// \tprotoc             ", protocVersion, "<br />")
	g.P("// source: ", file.Desc.Path(), "<br />")
	g.P()
}

func prepare(file *protogen.File, _ *protogen.GeneratedFile) (enums []*protogen.Enum,
	msgs []*protogen.Message,
	tojson map[string]*struct{},
	toform map[string]*struct{},
	fromobj map[string]*struct{},
	methodcount uint32) {
	tmpenums := make(map[string]*protogen.Enum)
	tmpmsgs := make(map[string]*protogen.Message)
	tojson = make(map[string]*struct{})
	toform = make(map[string]*struct{})
	fromobj = make(map[string]*struct{})
	for _, service := range file.Services {
		if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
			continue
		}
		for _, method := range service.Methods {
			mop := method.Desc.Options().(*descriptorpb.MethodOptions)
			if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
				continue
			}
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
			need := ""
			for _, em := range emethod {
				em = strings.ToUpper(em)
				if em == "GET" || em == "POST" || em == "PUT" || em == "PATCH" || em == "DELETE" {
					need = em
					break
				}
			}
			if need == "" {
				continue
			}
			tmpmsgs[method.Input.GoIdent.String()] = method.Input
			if need == "GET" || need == "DELETE" {
				toform[method.Input.GoIdent.String()] = nil
			} else {
				tojson[method.Input.GoIdent.String()] = nil
			}
			tmpmsgs[method.Output.GoIdent.String()] = method.Output
			fromobj[method.Output.GoIdent.String()] = nil
			methodcount++
		}
	}
	//check nested
	nestcheck := tmpmsgs
	for len(nestcheck) > 0 {
		newnestcheck := make(map[string]*protogen.Message)
		for _, m := range nestcheck {
			for _, f := range m.Fields {
				if f.Desc.Kind() == protoreflect.EnumKind {
					tmpenums[f.Enum.GoIdent.String()] = f.Enum
					continue
				}
				if f.Desc.Kind() != protoreflect.MessageKind {
					continue
				}
				if !f.Desc.IsMap() {
					needcheck := false
					if _, ok := tmpmsgs[f.Message.GoIdent.String()]; !ok {
						tmpmsgs[f.Message.GoIdent.String()] = f.Message
						needcheck = true
					}
					if _, ok := tojson[m.GoIdent.String()]; ok {
						if _, ok = tojson[f.Message.GoIdent.String()]; !ok {
							tojson[f.Message.GoIdent.String()] = nil
							needcheck = true
						}
					}
					if _, ok := fromobj[m.GoIdent.String()]; ok {
						if _, ok = fromobj[f.Message.GoIdent.String()]; !ok {
							fromobj[f.Message.GoIdent.String()] = nil
							needcheck = true
						}
					}
					if needcheck {
						newnestcheck[f.Message.GoIdent.String()] = f.Message
					}
				} else if f.Message.Fields[1].Desc.Kind() == protoreflect.MessageKind {
					needcheck := false
					if _, ok := tmpmsgs[f.Message.Fields[1].Message.GoIdent.String()]; !ok {
						tmpmsgs[f.Message.Fields[1].Message.GoIdent.String()] = f.Message.Fields[1].Message
						needcheck = true
					}
					if _, ok := tojson[m.GoIdent.String()]; ok {
						if _, ok = tojson[f.Message.Fields[1].Message.GoIdent.String()]; !ok {
							tojson[f.Message.Fields[1].Message.GoIdent.String()] = nil
							needcheck = true
						}
					}
					if _, ok := fromobj[m.GoIdent.String()]; ok {
						if _, ok := fromobj[f.Message.Fields[1].Message.GoIdent.String()]; !ok {
							fromobj[f.Message.Fields[1].Message.GoIdent.String()] = nil
							needcheck = true
						}
					}
					if needcheck {
						newnestcheck[f.Message.Fields[1].Message.GoIdent.String()] = f.Message.Fields[1].Message
					}
				}
			}
		}
		nestcheck = newnestcheck
	}
	enums = make([]*protogen.Enum, 0, len(enums))
	for _, v := range tmpenums {
		enums = append(enums, v)
	}
	sort.Slice(enums, func(i, j int) bool {
		return enums[i].GoIdent.String() < enums[j].GoIdent.String()
	})
	msgs = make([]*protogen.Message, 0, len(tmpmsgs))
	for _, v := range tmpmsgs {
		msgs = append(msgs, v)
	}
	sort.Slice(msgs, func(i, j int) bool {
		return msgs[i].GoIdent.String() < msgs[j].GoIdent.String()
	})
	return
}
func genEnum(e *protogen.Enum, g *protogen.GeneratedFile) {
	g.P("export enum ", e.GoIdent.GoName, "{")
	for i, v := range e.Values {
		comments := strings.Split(strings.TrimSuffix(v.Comments.Leading.String(), "\n"), "\n")
		for _, comment := range comments {
			if comment == "" {
				continue
			}
			g.P("\t", comment)
		}
		if i == len(e.Values)-1 {
			if v.Comments.Trailing.String() != "" {
				g.P("\t", v.Desc.Name(), "=", v.Desc.Number(), strings.TrimSuffix(v.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t", v.Desc.Name(), "=", v.Desc.Number())
			}
		} else {
			if v.Comments.Trailing.String() != "" {
				g.P("\t", v.Desc.Name(), "=", v.Desc.Number(), ",", strings.TrimSuffix(v.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t", v.Desc.Name(), "=", v.Desc.Number(), ",")
			}
		}
	}
	g.P("}")
}
func genMessage(m *protogen.Message, g *protogen.GeneratedFile, gentojson, gentoform, genfromobj bool) {
	g.P("export class ", m.GoIdent.GoName, "{")
	oneof := make(map[string]*struct{})
	for _, f := range m.Fields {
		if f.Oneof != nil && !f.Desc.HasOptionalKeyword() {
			//oneof field
			if _, ok := oneof[f.Oneof.GoIdent.String()]; ok {
				continue
			}
			oneof[f.Oneof.GoIdent.String()] = nil
			g.P("\t", f.Oneof.Desc.Name(), ":")
			for _, oneoff := range f.Oneof.Fields {
				comments := strings.Split(strings.TrimSuffix(oneoff.Comments.Leading.String(), "\n"), "\n")
				for _, comment := range comments {
					if comment == "" {
						continue
					}
					g.P("\t\t", comment)
				}
				switch oneoff.Desc.Kind() {
				case protoreflect.BoolKind:
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: boolean}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				case protoreflect.EnumKind:
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: ", oneoff.Enum.Desc.Name(), "}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				case protoreflect.Sfixed32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Int32Kind:
					//int32
					g.P("\t\t//Warning!!!Value's type is int32,be careful of sign(+,-) and overflow")
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: number}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				case protoreflect.Fixed32Kind:
					fallthrough
				case protoreflect.Uint32Kind:
					//uint32
					g.P("\t\t//Warning!!!Value's type is uint32,be careful of sign(+) and overflow")
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: number}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				case protoreflect.Sfixed64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Int64Kind:
					//int64
					g.P("\t\t//Warning!!!Value's type is int64,be careful of sign(+,-)")
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: bigint}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				case protoreflect.Fixed64Kind:
					fallthrough
				case protoreflect.Uint64Kind:
					//uint64
					g.P("\t\t//Warning!!!Value's type is uint64,be careful of sign(+)")
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: bigint}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				case protoreflect.FloatKind:
					g.P("\t\t//Warning!!!Value's type is float32,be careful of overflow")
					fallthrough
				case protoreflect.DoubleKind:
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: number}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				case protoreflect.StringKind:
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: string}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				case protoreflect.BytesKind:
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: Uint8Array}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				case protoreflect.MessageKind:
					g.P("\t\t{$key: ", strconv.Quote(string(oneoff.Desc.Name())), ",value: ", oneoff.Message.GoIdent.GoName, "|null|undefined}|", strings.TrimSuffix(oneoff.Comments.Trailing.String(), "\n"))
				}
			}
			g.P("\t\tnull = null")
			continue
		}
		comments := strings.Split(strings.TrimSuffix(f.Comments.Leading.String(), "\n"), "\n")
		for _, comment := range comments {
			if comment == "" {
				continue
			}
			g.P("\t", comment)
		}
		switch f.Desc.Kind() {
		case protoreflect.BoolKind:
			if f.Desc.IsList() {
				g.P("\t", f.Desc.Name(), ": Array<boolean>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t", f.Desc.Name(), ": boolean|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t", f.Desc.Name(), ": boolean = false", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.EnumKind:
			if f.Desc.IsList() {
				g.P("\t", f.Desc.Name(), ": Array<", f.Enum.GoIdent.GoName, ">|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t", f.Desc.Name(), ": ", f.Enum.GoIdent.GoName, "|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t", f.Desc.Name(), ": ", f.Enum.GoIdent.GoName, " = 0", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.Sfixed32Kind:
			fallthrough
		case protoreflect.Sint32Kind:
			fallthrough
		case protoreflect.Int32Kind:
			//int32
			if f.Desc.IsList() {
				g.P("\t//Warning!!!Element type is int32,be careful of sign(+,-) and overflow")
				g.P("\t", f.Desc.Name(), ": Array<number>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t//Warning!!!Type is int32,be careful of sign(+,-) and overflow")
				g.P("\t", f.Desc.Name(), ": number|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t//Warning!!!Type is int32,be careful of sign(+,-) and overflow")
				g.P("\t", f.Desc.Name(), ": number = 0", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.Fixed32Kind:
			fallthrough
		case protoreflect.Uint32Kind:
			//uint32
			if f.Desc.IsList() {
				g.P("\t//Warning!!!Element type is uint32,be careful of sign(+) and overflow")
				g.P("\t", f.Desc.Name(), ": Array<number>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t//Warning!!!Type is uint32,be careful of sign(+) and overflow")
				g.P("\t", f.Desc.Name(), ": number|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t//Warning!!!Type is uint32,be careful of sign(+) and overflow")
				g.P("\t", f.Desc.Name(), ": number = 0", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.Sfixed64Kind:
			fallthrough
		case protoreflect.Sint64Kind:
			fallthrough
		case protoreflect.Int64Kind:
			//int64
			if f.Desc.IsList() {
				g.P("\t//Warning!!!Element type is int64,be careful of sign(+,-)")
				g.P("\t", f.Desc.Name(), ": Array<bigint>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t//Warning!!!Type is int64,be careful of sign(+,-)")
				g.P("\t", f.Desc.Name(), ": bigint|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t//Warning!!!Type is int64,be careful of sign(+,-)")
				g.P("\t", f.Desc.Name(), ": bigint = BigInt(0)", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.Fixed64Kind:
			fallthrough
		case protoreflect.Uint64Kind:
			//uint64
			if f.Desc.IsList() {
				g.P("\t//Warning!!!Element type is uint64,be careful of sign(+)")
				g.P("\t", f.Desc.Name(), ": Array<bigint>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t//Warning!!!Type is uint64,be careful of sign(+)")
				g.P("\t", f.Desc.Name(), ": bigint|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t//Warning!!!Type is uint64,be careful of sign(+)")
				g.P("\t", f.Desc.Name(), ": bigint = BigInt(0)", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.FloatKind:
			if f.Desc.IsList() {
				g.P("\t//Warning!!!Element type is float32,be careful of overflow")
				g.P("\t", f.Desc.Name(), ": Array<number>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t//Warning!!!Type is float32,be careful of overflow")
				g.P("\t", f.Desc.Name(), ": number|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t//Warning!!!Type is float32,be careful of overflow")
				g.P("\t", f.Desc.Name(), ": number = 0", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.DoubleKind:
			if f.Desc.IsList() {
				g.P("\t", f.Desc.Name(), ": Array<number>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t", f.Desc.Name(), ": number|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t", f.Desc.Name(), ": number = 0", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.StringKind:
			if f.Desc.IsList() {
				g.P("\t", f.Desc.Name(), ": Array<string>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t", f.Desc.Name(), ": string|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t", f.Desc.Name(), ": string = ''", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.BytesKind:
			if f.Desc.IsList() {
				g.P("\t", f.Desc.Name(), ": Array<Uint8Array>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.HasOptionalKeyword() {
				g.P("\t", f.Desc.Name(), ": Uint8Array|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t", f.Desc.Name(), ": Uint8Array = new Uint8Array(0)", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		case protoreflect.MessageKind:
			if f.Desc.IsMap() {
				var keytype string
				keywarn := "\t//Warning!!!"
				var valuetype string
				valuewarn := "\t//Warning!!!"
				switch f.Message.Fields[0].Desc.Kind() {
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					//int32
					keytype = "number"
					keywarn += "map's key's type is int32,be careful of sign(+,-) and overflow"
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					//uint32
					keytype = "number"
					keywarn += "map's key's type is uint32,be careful of sign(+) and overflow"
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					//int64
					keytype = "bigint"
					keywarn += "map's key's type is int64,be careful of sign(+,-)"
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					//uint64
					keytype = "bigint"
					keywarn += "map's key's type is uint64,be carefule of sign(+)"
				case protoreflect.StringKind:
					keytype = "string"
				}
				switch f.Message.Fields[1].Desc.Kind() {
				case protoreflect.BoolKind:
					valuetype = "boolean"
				case protoreflect.EnumKind:
					valuetype = f.Message.Fields[1].Enum.GoIdent.GoName
				case protoreflect.Int32Kind:
					fallthrough
				case protoreflect.Sint32Kind:
					fallthrough
				case protoreflect.Sfixed32Kind:
					//int32
					valuetype = "number"
					valuewarn += "map's value's type is int32,be careful of sign(+,-) and overflow"
				case protoreflect.Uint32Kind:
					fallthrough
				case protoreflect.Fixed32Kind:
					//uint32
					valuetype = "number"
					valuewarn += "map's value's type is uint32,be careful of sign(+) and overflow"
				case protoreflect.Int64Kind:
					fallthrough
				case protoreflect.Sint64Kind:
					fallthrough
				case protoreflect.Sfixed64Kind:
					//int64
					valuetype = "bigint"
					valuewarn += "map's value's type is int64,be careful of sign(+,-)"
				case protoreflect.Uint64Kind:
					fallthrough
				case protoreflect.Fixed64Kind:
					//uint64
					valuetype = "bigint"
					valuewarn += "map's value's type is uint64,be careful of sign(+)"
				case protoreflect.FloatKind:
					valuetype = "number"
					valuewarn += "map's value's type is float32,be careful of overflow"
				case protoreflect.DoubleKind:
					valuetype = "number"
				case protoreflect.StringKind:
					valuetype = "string"
				case protoreflect.BytesKind:
					valuetype = "Uint8Array"
				case protoreflect.MessageKind:
					valuetype = f.Message.Fields[1].Message.GoIdent.GoName + "|null"
				}
				if keywarn != "\t//Warning!!!" {
					g.P(keywarn)
				}
				if valuewarn != "\t//Warning!!!" {
					g.P(valuewarn)
				}
				g.P("\t", f.Desc.Name(), ": Map<", keytype, ",", valuetype, ">|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else if f.Desc.IsList() {
				g.P("\t", f.Desc.Name(), ": Array<", f.Message.GoIdent.GoName, "|null>|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			} else {
				g.P("\t", f.Desc.Name(), ": ", f.Message.GoIdent.GoName, "|null = null", strings.TrimSuffix(f.Comments.Trailing.String(), "\n"))
			}
		}
	}
	if genfromobj {
		if len(m.Fields) == 0 {
			g.P("\tfromOBJ(_obj:Object){")
		} else {
			g.P("\tfromOBJ(obj:Object){")
		}
		oneofs := make(map[string]*struct{})
		for _, f := range m.Fields {
			if f.Oneof != nil && !f.Desc.HasOptionalKeyword() {
				if _, ok := oneofs[f.Oneof.GoIdent.String()]; ok {
					continue
				}
				oneofs[f.Oneof.GoIdent.String()] = nil
				g.P("\t\tlet oneof", f.Oneof.GoName, "=false")
				for _, oneoff := range f.Oneof.Fields {
					g.P("\t\tif(obj[", strconv.Quote(string(oneoff.Desc.Name())), "]){")
					g.P("\t\t\tif(oneof", f.Oneof.GoName, "){")
					g.P("\t\t\t\tthrow \"response's oneof field conflict\"")
					g.P("\t\t\t}")
					g.P("\t\t\toneof", f.Oneof.GoName, "=true")
					if oneoff.Desc.Kind() == protoreflect.Sfixed64Kind ||
						oneoff.Desc.Kind() == protoreflect.Sint64Kind ||
						oneoff.Desc.Kind() == protoreflect.Int64Kind ||
						oneoff.Desc.Kind() == protoreflect.Fixed64Kind ||
						oneoff.Desc.Kind() == protoreflect.Uint64Kind {
						g.P("\t\t\tlet v=obj[", strconv.Quote(string(oneoff.Desc.Name())), "]")
						g.P("\t\t\tthis.", f.Oneof.Desc.Name(), "={$key:", strconv.Quote(string(oneoff.Desc.Name())), ",value:BigInt(v)}")
					} else if oneoff.Desc.Kind() == protoreflect.BytesKind {
						g.P("\t\t\t//bytes type in protobuf is standard base64 encoded")
						g.P("\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
						g.P("\t\t\tlet rawstr=window.atob(obj[", strconv.Quote(string(oneoff.Desc.Name())), "])")
						g.P("\t\t\tlet tmp=new Uint8Array(rawstr.length)")
						g.P("\t\t\tfor(let i=0;i<rawstr.length;i++){")
						g.P("\t\t\t\ttmp[i]=rawstr.charCodeAt(i)")
						g.P("\t\t\t}")
						g.P("\t\t\tthis.", f.Oneof.Desc.Name(), "={$key:", strconv.Quote(string(oneoff.Desc.Name())), ",value:tmp}")
					} else {
						g.P("\t\t\tlet v=obj[", strconv.Quote(string(oneoff.Desc.Name())), "]")
						g.P("\t\t\tthis.", f.Oneof.Desc.Name(), "={$key:", strconv.Quote(string(oneoff.Desc.Name())), ",value:v}")
					}
					g.P("\t\t}")
				}
				continue
			}
			if !f.Desc.IsMap() {
				if f.Desc.IsList() {
					g.P("\t\tif(obj[", strconv.Quote(string(f.Desc.Name())), "] && obj[", strconv.Quote(string(f.Desc.Name())), "].length>0){")
				} else {
					g.P("\t\tif(obj[", strconv.Quote(string(f.Desc.Name())), "]){")
				}
				if f.Desc.Kind() == protoreflect.Sfixed64Kind ||
					f.Desc.Kind() == protoreflect.Sint64Kind ||
					f.Desc.Kind() == protoreflect.Int64Kind ||
					f.Desc.Kind() == protoreflect.Fixed64Kind ||
					f.Desc.Kind() == protoreflect.Uint64Kind {
					if f.Desc.IsList() {
						g.P("\t\t\tthis.", f.Desc.Name(), "=new Array<bigint>()")
						g.P("\t\t\tfor(let value of obj[", strconv.Quote(string(f.Desc.Name())), "]){")
						g.P("\t\t\t\tthis.", f.Desc.Name(), ".push(BigInt(value))")
						g.P("\t\t\t}")
					} else {
						g.P("\t\t\tthis.", f.Desc.Name(), "=BigInt(obj[", strconv.Quote(string(f.Desc.Name())), "])")
					}
				} else if f.Desc.Kind() == protoreflect.BytesKind {
					g.P("\t\t\t//bytes type in protobuf is standard base64 encoded")
					g.P("\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
					if f.Desc.IsList() {
						g.P("\t\t\tthis.", f.Desc.Name(), "=new Array<Uint8Array>()")
						g.P("\t\t\tfor(let value of obj[", strconv.Quote(string(f.Desc.Name())), "]){")
						g.P("\t\t\t\tlet rawstr=window.atob(value)")
						g.P("\t\t\t\tlet tmp=new Uint8Array(rawstr.length)")
						g.P("\t\t\t\tfor(let i=0;i<rawstr.length;i++){")
						g.P("\t\t\t\t\ttmp[i]=rawstr.charCodeAt(i)")
						g.P("\t\t\t\t}")
						g.P("\t\t\t\tthis.", f.Desc.Name(), ".push(tmp)")
						g.P("\t\t\t}")
					} else {
						g.P("\t\t\tlet rawstr=window.atob(obj[", strconv.Quote(string(f.Desc.Name())), "])")
						g.P("\t\t\tthis.", f.Desc.Name(), "=new Uint8Array(rawstr.length)")
						g.P("\t\t\tfor(let i=0;i<rawstr.length;i++){")
						g.P("\t\t\t\tthis.", f.Desc.Name(), "[i]=rawstr.charCodeAt(i)")
						g.P("\t\t\t}")
					}
				} else if f.Desc.Kind() == protoreflect.MessageKind {
					if f.Desc.IsList() {
						g.P("\t\t\tthis.", f.Desc.Name(), "=new Array<", f.Message.GoIdent.GoName, "|null>()")
						g.P("\t\t\tfor(let value of obj[", strconv.Quote(string(f.Desc.Name())), "]){")
						g.P("\t\t\t\tif(value){")
						g.P("\t\t\t\t\tlet tmp=new ", f.Message.GoIdent.GoName, "()")
						g.P("\t\t\t\t\ttmp.fromOBJ(value)")
						g.P("\t\t\t\t\tthis.", f.Desc.Name(), ".push(tmp)")
						g.P("\t\t\t\t}else{")
						g.P("\t\t\t\t\tthis.", f.Desc.Name(), ".push(null)")
						g.P("\t\t\t\t}")
						g.P("\t\t\t}")
					} else {
						g.P("\t\t\tthis.", f.Desc.Name(), "=new ", f.Message.GoIdent.GoName, "()")
						g.P("\t\t\tthis.", f.Desc.Name(), ".fromOBJ(obj[", strconv.Quote(string(f.Desc.Name())), "])")
					}
				} else {
					g.P("\t\t\tthis.", f.Desc.Name(), "=obj[", strconv.Quote(string(f.Desc.Name())), "]")
				}
				g.P("\t\t}")
				continue
			}
			var keytype string
			var valuetype string
			if f.Message.Fields[0].Desc.Kind() == protoreflect.Sint32Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Sfixed32Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Int32Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Fixed32Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Uint32Kind {
				keytype = "number"
			} else if f.Message.Fields[0].Desc.Kind() == protoreflect.Sint64Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Sfixed64Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Int64Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Fixed64Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Uint64Kind {
				keytype = "bigint"
			} else {
				keytype = "string"
			}
			if f.Message.Fields[1].Desc.Kind() == protoreflect.Sint32Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Sfixed32Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Int32Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Fixed32Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Uint32Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.FloatKind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.DoubleKind {
				valuetype = "number"
			} else if f.Message.Fields[1].Desc.Kind() == protoreflect.Sint64Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Sfixed64Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Int64Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Fixed64Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Uint64Kind {
				valuetype = "bigint"
			} else if f.Message.Fields[1].Desc.Kind() == protoreflect.BoolKind {
				valuetype = "bool"
			} else if f.Message.Fields[1].Desc.Kind() == protoreflect.EnumKind {
				valuetype = f.Message.Fields[1].Enum.GoIdent.GoName
			} else if f.Message.Fields[1].Desc.Kind() == protoreflect.StringKind {
				valuetype = "string"
			} else if f.Message.Fields[1].Desc.Kind() == protoreflect.BytesKind {
				valuetype = "Uint8Array"
			} else {
				valuetype = f.Message.Fields[1].Message.GoIdent.GoName + "|null"
			}
			g.P("\t\tif(obj[", strconv.Quote(string(f.Desc.Name())), "] && Object.keys(obj[", strconv.Quote(string(f.Desc.Name())), "]).length>0){")
			g.P("\t\t\tthis.", f.Desc.Name(), "=new Map<", keytype, ",", valuetype, ">()")
			g.P("\t\t\tfor(let key of Object.keys(obj[", strconv.Quote(string(f.Desc.Name())), "])){")
			if f.Message.Fields[0].Desc.Kind() == protoreflect.Sint32Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Sfixed32Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Int32Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Fixed32Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Uint32Kind {
				if f.Message.Fields[1].Desc.Kind() == protoreflect.Sint64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Sfixed64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Int64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Fixed64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Uint64Kind {
					g.P("\t\t\t\tthis.", f.Desc.Name(), ".set(Number(key),BigInt(obj[", strconv.Quote(string(f.Desc.Name())), "][key]))")
				} else if f.Message.Fields[1].Desc.Kind() == protoreflect.BytesKind {
					g.P("\t\t\t\t//bytes type in protobuf is standard base64 encoded")
					g.P("\t\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
					g.P("\t\t\t\tlet rawstr=window.atob(obj[", strconv.Quote(string(f.Desc.Name())), "][key])")
					g.P("\t\t\t\tlet tmp=new Uint8Array(rawstr.length)")
					g.P("\t\t\t\tfor(let i=0;i<rawstr.length;i++){")
					g.P("\t\t\t\t\ttmp[i]=rawstr.charCodeAt(i)")
					g.P("\t\t\t\t}")
					g.P("\t\t\t\tthis.", f.Desc.Name(), ".set(Number(key),tmp)")
				} else if f.Message.Fields[1].Desc.Kind() == protoreflect.MessageKind {
					g.P("\t\t\t\tif(obj[", strconv.Quote(string(f.Desc.Name())), "][key]){")
					g.P("\t\t\t\t\tlet tmp = new ", f.Message.Fields[1].Message.GoIdent.GoName, "()")
					g.P("\t\t\t\t\ttmp.fromOBJ(obj[", strconv.Quote(string(f.Desc.Name())), "][key])")
					g.P("\t\t\t\t\tthis.", f.Desc.Name(), ".set(Number(key),tmp)")
					g.P("\t\t\t\t}else{")
					g.P("\t\t\t\t\tthis.", f.Desc.Name(), ".set(Number(key),null)")
					g.P("\t\t\t\t}")
				} else {
					g.P("\t\t\t\tthis.", f.Desc.Name(), ".set(Number(key),obj[", strconv.Quote(string(f.Desc.Name())), "][key])")
				}
			} else if f.Message.Fields[0].Desc.Kind() == protoreflect.Sint64Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Sfixed64Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Int64Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Fixed64Kind ||
				f.Message.Fields[0].Desc.Kind() == protoreflect.Uint64Kind {
				if f.Message.Fields[1].Desc.Kind() == protoreflect.Sint64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Sfixed64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Int64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Fixed64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Uint64Kind {
					g.P("\t\t\t\tthis.", f.Desc.Name(), ".set(BigInt(key),BigInt(obj[", strconv.Quote(string(f.Desc.Name())), "][key]))")
				} else if f.Message.Fields[1].Desc.Kind() == protoreflect.BytesKind {
					g.P("\t\t\t\t//bytes type in protobuf is standard base64 encoded")
					g.P("\t\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
					g.P("\t\t\t\tlet rawstr=window.atob(obj[", strconv.Quote(string(f.Desc.Name())), "][key])")
					g.P("\t\t\t\tlet tmp=new Uint8Array(rawstr.length)")
					g.P("\t\t\t\tfor(let i=0;i<rawstr.length;i++){")
					g.P("\t\t\t\t\ttmp[i]=rawstr.charCodeAt(i)")
					g.P("\t\t\t\t}")
					g.P("\t\t\t\tthis.", f.Desc.Name(), ".set(BigInt(key),tmp)")
				} else if f.Message.Fields[1].Desc.Kind() == protoreflect.MessageKind {
					g.P("\t\t\t\tif(obj[", strconv.Quote(string(f.Desc.Name())), "][key]){")
					g.P("\t\t\t\t\tlet tmp = new ", f.Message.Fields[1].Message.GoIdent.GoName, "()")
					g.P("\t\t\t\t\ttmp.fromOBJ(obj[", strconv.Quote(string(f.Desc.Name())), "][key])")
					g.P("\t\t\t\t\tthis.", f.Desc.Name(), ".set(BigInt(key),tmp)")
					g.P("\t\t\t\t}else{")
					g.P("\t\t\t\t\tthis.", f.Desc.Name(), ".set(BigInt(key),null)")
					g.P("\t\t\t\t}")
				} else {
					g.P("\t\t\t\tthis.", f.Desc.Name(), ".set(BigInt(key),obj[", strconv.Quote(string(f.Desc.Name())), "][key])")
				}
			} else {
				if f.Message.Fields[1].Desc.Kind() == protoreflect.Sint64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Sfixed64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Int64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Fixed64Kind ||
					f.Message.Fields[1].Desc.Kind() == protoreflect.Uint64Kind {
					g.P("\t\t\t\tthis.", f.Desc.Name(), ".set(key,BigInt(obj[", strconv.Quote(string(f.Desc.Name())), "][key]))")
				} else if f.Message.Fields[1].Desc.Kind() == protoreflect.BytesKind {
					g.P("\t\t\t\t//bytes type in protobuf is standard base64 encoded")
					g.P("\t\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
					g.P("\t\t\t\tlet rawstr=window.atob(obj[", strconv.Quote(string(f.Desc.Name())), "][key])")
					g.P("\t\t\t\tlet tmp=new Uint8Array(rawstr.length)")
					g.P("\t\t\t\tfor(let i=0;i<rawstr.length;i++){")
					g.P("\t\t\t\t\ttmp[i]=rawstr.charCodeAt(i)")
					g.P("\t\t\t\t}")
					g.P("\t\t\t\tthis.", f.Desc.Name(), ".set(key,tmp)")
				} else if f.Message.Fields[1].Desc.Kind() == protoreflect.MessageKind {
					g.P("\t\t\t\tif(obj[", strconv.Quote(string(f.Desc.Name())), "][key]){")
					g.P("\t\t\t\t\tlet tmp = new ", f.Message.Fields[1].Message.GoIdent.GoName, "()")
					g.P("\t\t\t\t\ttmp.fromOBJ(obj[", strconv.Quote(string(f.Desc.Name())), "][key])")
					g.P("\t\t\t\t\tthis.", f.Desc.Name(), ".set(key,tmp)")
					g.P("\t\t\t\t}else{")
					g.P("\t\t\t\t\tthis.", f.Desc.Name(), ".set(key,null)")
					g.P("\t\t\t\t}")
				} else {
					g.P("\t\t\t\tthis.", f.Desc.Name(), ".set(key,obj[", strconv.Quote(string(f.Desc.Name())), "][key])")
				}
			}
			g.P("\t\t\t}")
			g.P("\t\t}")
		}
		g.P("\t}")
	}
	if gentojson {
		g.P("\ttoJSON(){")
		g.P("\t\tlet tmp = {}")
		oneofs := make(map[string]*struct{})
		for _, f := range m.Fields {
			if f.Oneof != nil && !f.Desc.HasOptionalKeyword() {
				if _, ok := oneofs[f.Oneof.GoIdent.String()]; ok {
					continue
				}
				oneofs[f.Oneof.GoIdent.String()] = nil
				g.P("\t\tif(this.", f.Oneof.Desc.Name(), "){")
				g.P("\t\t\tswitch(this.", f.Oneof.Desc.Name(), ".$key){")
				for _, oneoff := range f.Oneof.Fields {
					g.P("\t\t\t\tcase ", strconv.Quote(string(oneoff.Desc.Name())), ":{")
					if oneoff.Desc.Kind() == protoreflect.Sfixed64Kind ||
						oneoff.Desc.Kind() == protoreflect.Sint64Kind ||
						oneoff.Desc.Kind() == protoreflect.Int64Kind ||
						oneoff.Desc.Kind() == protoreflect.Fixed64Kind ||
						oneoff.Desc.Kind() == protoreflect.Uint64Kind {
						g.P("\t\t\t\t\ttmp[", strconv.Quote(string(oneoff.Desc.Name())), "]=this.", f.Oneof.Desc.Name(), ".value.toString()")
					} else if oneoff.Desc.Kind() == protoreflect.BytesKind {
						g.P("\t\t\t\t\t//bytes type in protobuf should be standard base64 encoded")
						g.P("\t\t\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
						g.P("\t\t\t\t\tlet rawstr=''")
						g.P("\t\t\t\t\tthis.", f.Oneof.Desc.Name(), ".value.forEach((element)=>{rawstr+=String.fromCharCode(element)})")
						g.P("\t\t\t\t\ttmp[", strconv.Quote(string(oneoff.Desc.Name())), "]=window.btoa(rawstr)")
					} else {
						g.P("\t\t\t\t\ttmp[", strconv.Quote(string(oneoff.Desc.Name())), "]=this.", f.Oneof.Desc.Name(), ".value")
					}
					g.P("\t\t\t\t\tbreak")
					g.P("\t\t\t\t}")
				}
				g.P("\t\t\t}")
				g.P("\t\t}")
				continue
			}
			if !f.Desc.IsMap() {
				if f.Desc.IsList() {
					g.P("\t\tif(this.", f.Desc.Name(), " && this.", f.Desc.Name(), ".length>0){")
				} else {
					g.P("\t\tif(this.", f.Desc.Name(), "){")
				}
				if f.Desc.Kind() == protoreflect.Sfixed64Kind ||
					f.Desc.Kind() == protoreflect.Sint64Kind ||
					f.Desc.Kind() == protoreflect.Int64Kind ||
					f.Desc.Kind() == protoreflect.Fixed64Kind ||
					f.Desc.Kind() == protoreflect.Uint64Kind {
					if f.Desc.IsList() {
						g.P("\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "]=new Array<string>()")
						g.P("\t\t\tfor(let value of this.", f.Desc.Name(), "){")
						g.P("\t\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "].push(value.toString())")
						g.P("\t\t\t}")
					} else {
						g.P("\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "]=this.", f.Desc.Name(), ".toString()")
					}
				} else if f.Desc.Kind() == protoreflect.BytesKind {
					g.P("\t\t\t//bytes type in protobuf should be standard base64 encoded")
					g.P("\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
					if f.Desc.IsList() {
						g.P("\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "]=new Array<string>()")
						g.P("\t\t\tfor(let value of this.", f.Desc.Name(), "){")
						g.P("\t\t\t\tlet rawstr=''")
						g.P("\t\t\t\tvalue.forEach((element)=>{rawstr+=String.fromCharCode(element)})")
						g.P("\t\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "].push(window.btoa(rawstr))")
						g.P("\t\t\t}")
					} else {
						g.P("\t\t\tlet rawstr=''")
						g.P("\t\t\tthis.", f.Desc.Name(), ".forEach((element)=>{rawstr+=String.fromCharCode(element)})")
						g.P("\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "]=window.btoa(rawstr)")
					}
				} else {
					g.P("\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "]=this.", f.Desc.Name())
				}
				g.P("\t\t}")
				continue
			}
			g.P("\t\tif(this.", f.Desc.Name(), " && this.", f.Desc.Name(), ".size>0){")
			g.P("\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "]={}")
			g.P("\t\t\tfor(let [k,v] of this.", f.Desc.Name(), "){")
			if f.Message.Fields[1].Desc.Kind() == protoreflect.Sfixed64Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Sint64Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Int64Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Fixed64Kind ||
				f.Message.Fields[1].Desc.Kind() == protoreflect.Uint64Kind {
				if f.Message.Fields[0].Desc.Kind() == protoreflect.Sfixed64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Sint64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Int64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Fixed64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Uint64Kind {
					g.P("\t\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "][k.toString()]=v.toString()")
				} else {
					g.P("\t\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "][k]=v.toString()")
				}
			} else if f.Message.Fields[1].Desc.Kind() == protoreflect.BytesKind {
				g.P("\t\t\t\tlet rawstr=''")
				g.P("\t\t\t\tv.forEach((element)=>{rawstr+=String.fromCharCode(element)})")
				if f.Message.Fields[0].Desc.Kind() == protoreflect.Sfixed64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Sint64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Int64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Fixed64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Uint64Kind {
					g.P("\t\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "][k.toString()]=window.btoa(rawstr)")
				} else {
					g.P("\t\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "][k]=window.btoa(rawstr)")
				}
			} else {
				if f.Message.Fields[0].Desc.Kind() == protoreflect.Sfixed64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Sint64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Int64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Fixed64Kind ||
					f.Message.Fields[0].Desc.Kind() == protoreflect.Uint64Kind {
					g.P("\t\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "][k.toString()]=v")
				} else {
					g.P("\t\t\t\ttmp[", strconv.Quote(string(f.Desc.Name())), "][k]=v")
				}
			}
			g.P("\t\t\t}")
			g.P("\t\t}")
		}
		g.P("\t\treturn tmp")
		g.P("\t}")
	}
	if gentoform {
		g.P("\ttoFORM(){")
		g.P("\t\tlet query=new Array<string>()")
		oneofs := make(map[string]*struct{})
		for _, f := range m.Fields {
			if f.Desc.Kind() == protoreflect.MessageKind {
				panic("form request message can't contain nested message and map")
			}
			if f.Oneof != nil && !f.Desc.HasOptionalKeyword() {
				if _, ok := oneofs[f.Oneof.GoIdent.String()]; ok {
					continue
				}
				oneofs[f.Oneof.GoIdent.String()] = nil
				g.P("\t\tif(this.", f.Oneof.Desc.Name(), "){")
				g.P("\t\t\tswitch(this.", f.Oneof.Desc.Name(), ".$key){")
				for _, oneoff := range f.Oneof.Fields {
					g.P("\t\t\t\tcase ", strconv.Quote(string(oneoff.Desc.Name())), ":{")
					if oneoff.Desc.Kind() == protoreflect.BytesKind {
						g.P("\t\t\t\t\t//bytes type in protobuf should be standard base64 encoded")
						g.P("\t\t\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
						g.P("\t\t\t\t\tlet rawstr=''")
						g.P("\t\t\t\t\tthis.", f.Oneof.Desc.Name(), ".value.forEach((element)=>{rawstr+=String.fromCharCode(element)})")
						g.P("\t\t\t\t\tlet tmp=", strconv.Quote(string(f.Desc.Name())+"="), "+window.btoa(rawstr)")
					} else {
						g.P("\t\t\t\t\tlet tmp=", strconv.Quote(string(f.Desc.Name())+"="), "+this.", f.Oneof.Desc.Name(), ".value")
					}
					g.P("\t\t\t\t\tquery.push(tmp)")
					g.P("\t\t\t\t\tbreak")
					g.P("\t\t\t\t}")
				}
				g.P("\t\t\t}")
				g.P("\t\t}")
				continue
			}
			if f.Desc.IsList() {
				g.P("\t\tif(this.", f.Desc.Name(), " && this.", f.Desc.Name(), ".length>0){")
				g.P("\t\t\tfor(let value of this.", f.Desc.Name(), "){")
				if f.Desc.Kind() == protoreflect.BytesKind {
					g.P("\t\t\t\t//bytes type in protobuf should be standard base64 encoded")
					g.P("\t\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
					g.P("\t\t\t\tlet rawstr=''")
					g.P("\t\t\t\tvalue.forEach((element)=>{rawstr+=String.fromCharCode(element)})")
					g.P("\t\t\t\tlet tmp=", strconv.Quote(string(f.Desc.Name())+"="), "+window.btoa(rawstr)")
				} else {
					g.P("\t\t\t\tlet tmp=", strconv.Quote(string(f.Desc.Name())+"="), "+value")
				}
				g.P("\t\t\t\tquery.push(tmp)")
				g.P("\t\t\t}")
				g.P("\t\t}")
			} else {
				g.P("\t\tif(this.", f.Desc.Name(), "){")
				if f.Desc.Kind() == protoreflect.BytesKind {
					g.P("\t\t\t//bytes type in protobuf should be standard base64 encoded")
					g.P("\t\t\t//https://developers.google.com/protocol-buffers/docs/proto3#json")
					g.P("\t\t\tlet rawstr=''")
					g.P("\t\t\tthis.", f.Desc.Name(), ".forEach((element)=>{rawstr+=String.fromCharCode(element)})")
					g.P("\t\t\tlet tmp=", strconv.Quote(string(f.Desc.Name())+"="), "+window.btoa(rawstr)")
				} else {
					g.P("\t\t\tlet tmp=", strconv.Quote(string(f.Desc.Name())+"="), "+this.", f.Desc.Name())
				}
				g.P("\t\t\tquery.push(tmp)")
				g.P("\t\t}")
			}
		}
		g.P("\t\treturn encodeURIComponent(query.join('&'))")
		g.P("\t}")
	}
	g.P("}")
}

func genPath(file *protogen.File, s *protogen.Service, g *protogen.GeneratedFile) int {
	count := 0
	for _, method := range s.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := false
		for _, em := range emethod {
			em = strings.ToUpper(em)
			if em == "GET" || em == "POST" || em == "PUT" || em == "PATCH" || em == "DELETE" {
				need = true
				break
			}
		}
		if !need {
			continue
		}
		count++
		pathname := "_WebPath" + s.GoName + method.GoName
		pathurl := "/" + *file.Proto.Package + "." + string(s.Desc.Name()) + "/" + string(method.Desc.Name())
		g.P("const ", pathname, ": string =", strconv.Quote(pathurl), ";")
	}
	return count
}
func genService(_ *protogen.File, s *protogen.Service, g *protogen.GeneratedFile) {
	clientName := s.GoName + "BrowserClientToC"
	g.P("//ToC means this is for users")
	g.P("export class ", clientName, " {")
	g.P("\tconstructor(host: string){")
	g.P("\t\tif(!host || host.length==0){")
	g.P("\t\t\tthrow \"", clientName, "'s host missing\"")
	g.P("\t\t}")
	g.P("\t\tthis.host=host")
	g.P("\t}")
	for _, method := range s.Methods {
		mop := method.Desc.Options().(*descriptorpb.MethodOptions)
		if mop.GetDeprecated() || !proto.HasExtension(mop, pbex.E_Method) {
			continue
		}
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		emethod := proto.GetExtension(mop, pbex.E_Method).([]string)
		need := ""
		for _, em := range emethod {
			em = strings.ToUpper(em)
			if em == "GET" || em == "POST" || em == "PATCH" || em == "PUT" || em == "DELETE" {
				need = em
				break
			}
		}
		if need == "" {
			continue
		}
		pathname := "_WebPath" + s.GoName + method.GoName
		g.P("\t//timeout's unit is millisecond,it will be used when > 0")
		g.P("\t", method.Desc.Name(), "(header: Object,req: ", method.Input.GoIdent.GoName, ",timeout: number,error: (arg: LogicError)=>void,success: (arg: ", method.Output.GoIdent.GoName, ")=>void){")
		g.P("\t\tif(!header){")
		g.P("\t\t\theader={}")
		g.P("\t\t}")
		if need == "GET" || need == "DELETE" {
			g.P("\t\theader[\"Content-Type\"] = \"application/x-www-form-urlencoded\"")
			g.P("\t\tcall(timeout,this.host+", pathname, "+\"?\"+req.toFORM(),{method:", strconv.Quote(need), ",headers:header},error,function(arg: Object){")
			g.P("\t\t\tlet r=new ", method.Output.GoIdent.GoName, "()")
			g.P("\t\t\tr.fromOBJ(arg)")
			g.P("\t\t\tsuccess(r)")
			g.P("\t\t})")
		} else {
			g.P("\t\theader[\"Content-Type\"] = \"application/json\"")
			g.P("\t\tcall(timeout,this.host+", pathname, ",{method:", strconv.Quote(need), ",headers:header,body:JSON.stringify(req)},error,function(arg: Object){")
			g.P("\t\t\tlet r=new ", method.Output.GoIdent.GoName, "()")
			g.P("\t\t\tr.fromOBJ(arg)")
			g.P("\t\t\tsuccess(r)")
			g.P("\t\t})")
		}
		g.P("\t}")
	}
	g.P("\tprivate host: string")
	g.P("}")
}

func genCall(g *protogen.GeneratedFile) {
	g.P("//timeout's unit is millisecond,it will be used when > 0")
	g.P("function call(timeout: number,url: string,opts: Object,error: (arg: LogicError)=>void,success: (arg: Object)=>void){")
	g.P("\tlet tid: number|null = null")
	g.P("\tif(timeout>0){")
	g.P("\t\tconst c = new AbortController()")
	g.P("\t\topts[\"signal\"] = c.signal")
	g.P("\t\ttid = setTimeout(()=>{c.abort()},timeout)")
	g.P("\t}")
	g.P("\tlet ok=false")
	g.P("\tfetch(url,opts)")
	g.P("\t.then(r=>{")
	g.P("\t\tok=r.ok")
	g.P("\t\tif(r.ok){")
	g.P("\t\t\treturn r.json()")
	g.P("\t\t}")
	g.P("\t\treturn r.text()")
	g.P("\t})")
	g.P("\t.then(d=>{")
	g.P("\t\tif(!ok){")
	g.P("\t\t\tthrow d")
	g.P("\t\t}")
	g.P("\t\tsuccess(d)")
	g.P("\t})")
	g.P("\t.catch(e=>{")
	g.P("\t\tif(e instanceof Error){")
	g.P("\t\t\terror({code:-1,msg:e.message})")
	g.P("\t\t}else if(e.length>0 && e[0]=='{' && e[e.length-1]=='}'){")
	g.P("\t\t\terror(JSON.parse(e))")
	g.P("\t\t}else{")
	g.P("\t\t\terror({code:-1,msg:e})")
	g.P("\t\t}")
	g.P("\t})")
	g.P("\t.finally(()=>{")
	g.P("\t\tif(tid){")
	g.P("\t\t\tclearTimeout(tid)")
	g.P("\t\t}")
	g.P("\t})")
	g.P("}")
}
